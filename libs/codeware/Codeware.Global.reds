// Codeware 1.15.0

public abstract native class Codeware {
    public static native func Require(version: String) -> Bool
    public static native func Version() -> String
}

@addField(CameraComponent)
native let animParamFovOverrideWeight: CName;
@addField(CameraComponent)
native let animParamFovOverrideValue: CName;
@addField(CameraComponent)
native let animParamZoomOverrideWeight: CName;
@addField(CameraComponent)
native let animParamZoomOverrideValue: CName;
@addField(CameraComponent)
native let animParamZoomWeaponOverrideWeight: CName;
@addField(CameraComponent)
native let animParamZoomWeaponOverrideValue: CName;
@addField(CameraComponent)
native let animParamdofIntensity: CName;
@addField(CameraComponent)
native let animParamdofNearBlur: CName;
@addField(CameraComponent)
native let animParamdofNearFocus: CName;
@addField(CameraComponent)
native let animParamdofFarBlur: CName;
@addField(CameraComponent)
native let animParamdofFarFocus: CName;
@addField(CameraComponent)
native let animParamWeaponNearPlaneCM: CName;
@addField(CameraComponent)
native let animParamWeaponFarPlaneCM: CName;
@addField(CameraComponent)
native let animParamWeaponEdgesSharpness: CName;
@addField(CameraComponent)
native let animParamWeaponVignetteIntensity: CName;
@addField(CameraComponent)
native let animParamWeaponVignetteRadius: CName;
@addField(CameraComponent)
native let animParamWeaponVignetteCircular: CName;
@addField(CameraComponent)
native let animParamWeaponBlurIntensity: CName;
@addField(CameraComponent)
native let weaponPlane: SWeaponPlaneParams;

@addField(entCameraComponent)
native let fov: Float;
@addField(entCameraComponent)
native let zoom: Float;
@addField(entCameraComponent)
native let nearPlaneOverride: Float;
@addField(entCameraComponent)
native let farPlaneOverride: Float;
@addField(entCameraComponent)
native let motionBlurScale: Float;

@addField(gameLightComponent)
native let emissiveOnly: Bool;
@addField(gameLightComponent)
native let materialZone: gameEMaterialZone;
@addField(gameLightComponent)
native let meshBrokenAppearance: CName;
@addField(gameLightComponent)
native let onStrength: Float;
@addField(gameLightComponent)
native let turnOnByDefault: Bool;
@addField(gameLightComponent)
native let turnOnTime: Float;
@addField(gameLightComponent)
native let turnOnCurve: CName;
@addField(gameLightComponent)
native let turnOffTime: Float;
@addField(gameLightComponent)
native let turnOffCurve: CName;
@addField(gameLightComponent)
native let loopTime: Float;
@addField(gameLightComponent)
native let loopCurve: CName;
@addField(gameLightComponent)
native let synchronizedLoop: Bool;
@addField(gameLightComponent)
native let isDestructible: Bool;
@addField(gameLightComponent)
native let colliderName: CName;
@addField(gameLightComponent)
native let colliderTag: CName;
@addField(gameLightComponent)
native let destructionEffect: ResourceAsyncRef; // raRef<worldEffect>
@addField(gameLightComponent)
native let genericCurveSetOverride: ResourceRef; // rRef<CurveSet>

@addField(IComponent)
native let name: CName;
@addField(IComponent)
native let isReplicable: Bool;
@addField(IComponent)
native let id: CRUID;
@addField(IComponent)
native let appearanceName: CName;
@addField(IComponent)
native let appearancePath: ResRef;

@addField(inkCircle)
native let segmentsNumber: Uint32;

@addField(inkGridController)
native let height: Uint32;
@addField(inkGridController)
native let width: Uint32;
@addField(inkGridController)
native let items: array<inkGridItem>;
@addField(inkGridController)
native let slotSize: Vector2;
@addField(inkGridController)
native let itemTemplates: array<inkGridItemTemplate>;

@addField(inkImage)
native let useExternalDynamicTexture: Bool;
@addField(inkImage)
native let externalDynamicTexture: CName;
@addField(inkImage)
native let useNineSliceScale: Bool;
@addField(inkImage)
native let nineSliceScale: inkMargin;
@addField(inkImage)
native let mirrorType: inkBrushMirrorType;
@addField(inkImage)
native let tileType: inkBrushTileType;
@addField(inkImage)
native let horizontalTileCrop: Float;
@addField(inkImage)
native let verticalTileCrop: Float;
@addField(inkImage)
native let textureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
@addField(inkImage)
native let texturePart: CName;
@addField(inkImage)
native let contentHAlign: inkEHorizontalAlign;
@addField(inkImage)
native let contentVAlign: inkEVerticalAlign;
@addField(inkImage)
native let tileHAlign: inkEHorizontalAlign;
@addField(inkImage)
native let tileVAlign: inkEVerticalAlign;

@addField(inkInputDisplayController)
native let iconRef: inkWidgetRef;
@addField(inkInputDisplayController)
native let nameRef: inkWidgetRef;
@addField(inkInputDisplayController)
native let canvasRef: inkWidgetRef;
@addField(inkInputDisplayController)
native let holdIndicatorContainerRef: inkCompoundRef;
@addField(inkInputDisplayController)
native let gamepadHoldIndicatorLibraryRef: inkWidgetLibraryReference;
@addField(inkInputDisplayController)
native let keyboardHoldIndicatorLibraryRef: inkWidgetLibraryReference;
@addField(inkInputDisplayController)
native let holdIndicationType: inkInputHintHoldIndicationType;
@addField(inkInputDisplayController)
native let inputActionName: CName;
@addField(inkInputDisplayController)
native let fixedIconHeight: Float;

@addField(inkMask)
native let textureAtlas: ResourceAsyncRef;
@addField(inkMask)
native let texturePart: CName;
@addField(inkMask)
native let dynamicTextureMask: CName;
@addField(inkMask)
native let dataSource: inkMaskDataSource;
@addField(inkMask)
native let invertMask: Bool;
@addField(inkMask)
native let maskTransparency: Float;

@addField(inkPuppetPreviewGameController)
public native let cameraController: gameuiPuppetPreviewCameraController;

@addField(inkScrollArea)
native let constrainContentPosition: Bool;
@addField(inkScrollArea)
native let fitToContentDirection: inkFitToContentDirection;
@addField(inkScrollArea)
native let useInternalMask: Bool;
@addField(inkScrollArea)
native let horizontalScrolling: Float;
@addField(inkScrollArea)
native let verticalScrolling: Float;

@addField(inkScrollController)
native let ScrollArea: inkScrollAreaRef;
@addField(inkScrollController)
native let VerticalScrollBarRef: inkWidgetRef;
@addField(inkScrollController)
native let navigableCompoundWidget: inkWidgetRef;
@addField(inkScrollController)
native let CompoundWidgetRef: inkCompoundRef;
@addField(inkScrollController)
native let autoHideVertical: Bool;
@addField(inkScrollController)
native let scrollSpeedGamepad: Float;
@addField(inkScrollController)
native let scrollSpeedMouse: Float;
@addField(inkScrollController)
native let direction: inkEScrollDirection;
@addField(inkScrollController)
native let useGlobalInput: Bool;
@addField(inkScrollController)
native let desiredSetupPosition: Float;
@addField(inkScrollController)
native let contentSmallerThanViewport: Bool;
@addField(inkScrollController)
native let position: Float;
@addField(inkScrollController)
native let contentSize: Vector2;
@addField(inkScrollController)
native let viewportSize: Vector2;
@addField(inkScrollController)
native let scrollDelta: Float;

@addField(inkShape)
native let shapeResource: ResourceRef;
@addField(inkShape)
native let shapeName:  CName;
@addField(inkShape)
native let shapeVariant:inkEShapeVariant;
@addField(inkShape)
native let keepInBounds: Bool;
@addField(inkShape)
native let nineSliceScale: inkMargin;
@addField(inkShape)
native let useNineSlice: Bool;
@addField(inkShape)
native let contentHAlign: inkEHorizontalAlign;
@addField(inkShape)
native let contentVAlign: inkEVerticalAlign;
@addField(inkShape)
native let borderColor: HDRColor;
@addField(inkShape)
native let borderOpacity: Float;
@addField(inkShape)
native let fillOpacity: Float;
@addField(inkShape)
native let lineThickness: Float;
@addField(inkShape)
native let endCapStyle: inkEEndCapStyle;
@addField(inkShape)
native let jointStyle: inkEJointStyle;
@addField(inkShape)
native let vertexList: array<Vector2>;

@addField(inkSliderController)
native let slidingAreaRef: inkWidgetRef;
@addField(inkSliderController)
native let handleRef: inkWidgetRef;
@addField(inkSliderController)
native let nextRef: inkWidgetRef;
@addField(inkSliderController)
native let priorRef: inkWidgetRef;
@addField(inkSliderController)
native let direction: inkESliderDirection;
@addField(inkSliderController)
native let autoSizeHandle: Bool;
@addField(inkSliderController)
native let minHandleSize: Float;
@addField(inkSliderController)
native let maxHandleSize: Float;
@addField(inkSliderController)
native let percentHandleSize: Float;
@addField(inkSliderController)
native let currentProgress: Float;
@addField(inkSliderController)
native let minimumValue: Float;
@addField(inkSliderController)
native let maximumValue: Float;
@addField(inkSliderController)
native let step: Float;

@addField(inkText)
native let contentHAlign: inkEHorizontalAlign;
@addField(inkText)
native let contentVAlign: inkEVerticalAlign;
@addField(inkText)
native let justification: textJustificationType;
@addField(inkText)
native let textOverflowPolicy: textOverflowPolicy;
@addField(inkText)
native let wrappingInfo: textWrappingInfo;
@addField(inkText)
native let lineHeightPercentage: Float;
@addField(inkText)
native let lockFontInGame: Bool;

@addField(inkVirtualListController)
native let itemTemplates: array<inkWidgetLibraryReference>;
@addField(inkVirtualListController)
native let cycleNavigation: Bool;

@addField(inkVirtualUniformListController)
native let itemTemplate: inkWidgetLibraryReference;

@addField(inkWidget)
native let parentWidget: wref<inkWidget>;
@addField(inkWidget)
native let logicController: ref<inkLogicController>;
@addField(inkWidget)
native let secondaryControllers: array<ref<inkLogicController>>;
@addField(inkWidget)
native let userData: array<ref<inkUserData>>;
@addField(inkWidget)
native let canSupportFocus: Bool;
@addField(inkWidget)
native let effects: array<ref<inkIEffect>>;

@addField(IPlacedComponent)
native let localTransform: WorldTransform;
@addField(IPlacedComponent)
native let worldTransform: WorldTransform;
@addField(IPlacedComponent)
native let parentTransform: ref<entITransformBinding>;

@addMethod(IScriptable)
public final native func Clone() -> ref<IScriptable>

@addField(IVisualComponent)
native let autoHideDistance: Float;
@addField(IVisualComponent)
native let forceLODLevel: Int8;

@addField(JournalBriefingMapSection)
native let mapLocation: Vector3;

@addField(JournalBriefingVideoSection)
native let videoResource: ResourceAsyncRef; // raRef<Bink>

@addField(JournalCodexCategory)
native let categoryName: LocalizationString;

@addField(JournalCodexDescription)
native let subTitle: LocalizationString;
@addField(JournalCodexDescription)
native let textContent: LocalizationString;

@addField(JournalCodexEntry)
native let title: LocalizationString;
@addField(JournalCodexEntry)
native let imageId: TweakDBID;
@addField(JournalCodexEntry)
native let linkImageId: TweakDBID;

@addField(JournalCodexGroup)
native let groupName: LocalizationString;
@addField(JournalCodexGroup)
native let isSorted: Bool;

@addField(JournalContact)
native let name: LocalizationString;
@addField(JournalContact)
native let avatarID: TweakDBID;
@addField(JournalContact)
native let type: gameContactType;
@addField(JournalContact)
native let useFlatMessageLayout: Bool;
@addField(JournalContact)
native let isCallableDefault: Bool;

@addField(JournalContainerEntry)
native let entries: array<ref<JournalEntry>>;

@addField(JournalEmail)
native let sender: LocalizationString;
@addField(JournalEmail)
native let addressee: LocalizationString;
@addField(JournalEmail)
native let title: LocalizationString;
@addField(JournalEmail)
native let content: LocalizationString;
@addField(JournalEmail)
native let videoResource: ResourceAsyncRef; // raRef<Bink>
@addField(JournalEmail)
native let pictureTweak: TweakDBID;

@addField(JournalEntry)
native let id: String;

@addField(JournalEntryOverrideData)
native let overriddenLocalizationString: LocalizationString;

@addField(JournalFile)
native let title: LocalizationString;
@addField(JournalFile)
native let content: LocalizationString;
@addField(JournalFile)
native let videoResource: ResourceAsyncRef; // raRef<Bink>
@addField(JournalFile)
native let pictureTweak: TweakDBID;

@addField(JournalImageEntry)
native let imageId: TweakDBID;
@addField(JournalImageEntry)
native let thumbnailImageId: TweakDBID;

@addField(JournalInternetBase)
native let name: CName;
@addField(JournalInternetBase)
native let linkAddress: String;
@addField(JournalInternetBase)
native let tintColor: Color;
@addField(JournalInternetBase)
native let hoverTintColor: Color;

@addField(JournalInternetCanvas)
native let isHidden: Bool;

@addField(JournalInternetImage)
native let textureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
@addField(JournalInternetImage)
native let texturePart: CName;

@addField(JournalInternetPage)
native let address: String;
@addField(JournalInternetPage)
native let factsToSet: array<JournalFactNameValue>;
@addField(JournalInternetPage)
native let additionallyFilledFromScripts: Bool;
@addField(JournalInternetPage)
native let reloadOnZoomIn: Bool;
@addField(JournalInternetPage)
native let widgetFile: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
@addField(JournalInternetPage)
native let scale: Float;
@addField(JournalInternetPage)
native let texts: array<ref<JournalInternetText>>;
@addField(JournalInternetPage)
native let rectangles: array<ref<JournalInternetRectangle>>;
@addField(JournalInternetPage)
native let images: array<ref<JournalInternetImage>>;
@addField(JournalInternetPage)
native let videos: array<ref<JournalInternetVideo>>;
@addField(JournalInternetPage)
native let canvases: array<ref<JournalInternetCanvas>>;

@addField(JournalInternetSite)
native let shortName: LocalizationString;
@addField(JournalInternetSite)
native let mainPagePath: ref<gameJournalPath>;
@addField(JournalInternetSite)
native let ignoredAtDesktop: Bool;
@addField(JournalInternetSite)
native let textureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
@addField(JournalInternetSite)
native let texturePart: CName;

@addField(JournalInternetText)
native let text: LocalizationString;

@addField(JournalInternetVideo)
native let videoResource: ResourceAsyncRef; // raRef<Bink>

@addField(JournalMetaQuest)
native let title: LocalizationString;

@addField(JournalMetaQuestObjective)
native let description: LocalizationString;
@addField(JournalMetaQuestObjective)
native let progressPercent: Uint32;
@addField(JournalMetaQuestObjective)
native let iconID: TweakDBID;

@addField(JournalOnscreen)
native let tag: CName;
@addField(JournalOnscreen)
native let title: LocalizationString;
@addField(JournalOnscreen)
native let description: LocalizationString;
@addField(JournalOnscreen)
native let iconID: TweakDBID;

@addField(JournalPhoneChoiceEntry)
native let text: LocalizationString;
@addField(JournalPhoneChoiceEntry)
native let isQuestImportant: Bool;
@addField(JournalPhoneChoiceEntry)
native let questCondition: ref<questIBaseCondition>;

@addField(JournalPhoneConversation)
native let title: LocalizationString;

@addField(JournalPhoneMessage)
native let sender: gameMessageSender;
@addField(JournalPhoneMessage)
native let text: LocalizationString;
@addField(JournalPhoneMessage)
native let imageId: TweakDBID;
@addField(JournalPhoneMessage)
native let delay: Float;
@addField(JournalPhoneMessage)
native let attachment: ref<gameJournalPath>;
@addField(JournalPhoneMessage)
native let isQuestImportant: Bool;

@addField(JournalQuest)
native let title: LocalizationString;
@addField(JournalQuest)
native let type: gameJournalQuestType;
@addField(JournalQuest)
native let recommendedLevelID: TweakDBID;
@addField(JournalQuest)
native let districtID: String;

@addField(JournalQuestCodexLink)
native let path: ref<gameJournalPath>;

@addField(JournalQuestDescription)
native let description: LocalizationString;

@addField(JournalQuestGuidanceMarker)
native let nodeRef: NodeRef;
@addField(JournalQuestGuidanceMarker)
native let pathfindingType: gameQuestGuidanceMarkerPathfindingType;
@addField(JournalQuestGuidanceMarker)
native let isPortal: Bool;

@addField(JournalQuestMapPin)
native let reference: EntityReference;
@addField(JournalQuestMapPin)
native let slotName: CName;
@addField(JournalQuestMapPin)
native let mappinData: MappinData;
@addField(JournalQuestMapPin)
native let offset: Vector3;
@addField(JournalQuestMapPin)
native let uiAnimation: TweakDBID;

@addField(JournalQuestMapPinBase)
native let enableGPS: Bool;

@addField(JournalQuestMapPinLink)
native let path: ref<gameJournalPath>;

@addField(JournalQuestObjectiveBase)
native let description: LocalizationString;
@addField(JournalQuestObjectiveBase)
native let counter: Uint32;
@addField(JournalQuestObjectiveBase)
native let optional: Bool;
@addField(JournalQuestObjectiveBase)
native let locationPrefabRef: NodeRef;
@addField(JournalQuestObjectiveBase)
native let itemID: TweakDBID;
@addField(JournalQuestObjectiveBase)
native let districtID: String;

@addField(JournalQuestPhase)
native let locationPrefabRef: NodeRef;

@addField(JournalTarot)
native let index: Int32;
@addField(JournalTarot)
native let name: LocalizationString;
@addField(JournalTarot)
native let description: LocalizationString;
@addField(JournalTarot)
native let imagePart: CName;

@addField(LightComponent)
native let type: ELightType;
@addField(LightComponent)
native let color: Color;
@addField(LightComponent)
native let radius: Float;
@addField(LightComponent)
native let unit: ELightUnit;
@addField(LightComponent)
native let intensity: Float;
@addField(LightComponent)
native let EV: Float;
@addField(LightComponent)
native let temperature: Float;
@addField(LightComponent)
native let sceneDiffuse: Bool;
@addField(LightComponent)
native let sceneSpecularScale: Uint8;
@addField(LightComponent)
native let directional: Bool;
@addField(LightComponent)
native let roughnessBias: Int8;
@addField(LightComponent)
native let scaleGI: Uint8;
@addField(LightComponent)
native let scaleEnvProbes: Uint8;
@addField(LightComponent)
native let useInTransparents: Bool;
@addField(LightComponent)
native let scaleVolFog: Uint8;
@addField(LightComponent)
native let useInParticles: Bool;
@addField(LightComponent)
native let attenuation: rendLightAttenuation;
@addField(LightComponent)
native let clampAttenuation: Bool;
@addField(LightComponent)
native let group: rendLightGroup;
@addField(LightComponent)
native let areaShape: EAreaLightShape;
@addField(LightComponent)
native let areaTwoSided: Bool;
@addField(LightComponent)
native let spotCapsule: Bool;
@addField(LightComponent)
native let sourceRadius: Float;
@addField(LightComponent)
native let capsuleLength: Float;
@addField(LightComponent)
native let areaRectSideA: Float;
@addField(LightComponent)
native let areaRectSideB: Float;
@addField(LightComponent)
native let innerAngle: Float;
@addField(LightComponent)
native let outerAngle: Float;
@addField(LightComponent)
native let softness: Float;
@addField(LightComponent)
native let enableLocalShadows: Bool;
@addField(LightComponent)
native let enableLocalShadowsForceStaticsOnly: Bool;
@addField(LightComponent)
native let contactShadows: rendContactShadowReciever;
@addField(LightComponent)
native let shadowAngle: Float;
@addField(LightComponent)
native let shadowRadius: Float;
@addField(LightComponent)
native let shadowFadeDistance: Float;
@addField(LightComponent)
native let shadowFadeRange: Float;
@addField(LightComponent)
native let shadowSoftnessMode: ELightShadowSoftnessMode;
@addField(LightComponent)
native let rayTracedShadowsPlatform: rendRayTracedShadowsPlatform;
@addField(LightComponent)
native let rayTracingLightSourceRadius: Float;
@addField(LightComponent)
native let rayTracingContactShadowRange: Float;
@addField(LightComponent)
native let iesProfile: ResourceAsyncRef; // raRef<CIESDataResource>
@addField(LightComponent)
native let flicker: rendSLightFlickering;
@addField(LightComponent)
native let envColorGroup: EEnvColorGroup;
@addField(LightComponent)
native let colorGroupSaturation: Uint8;
@addField(LightComponent)
native let portalAngleCutoff: Uint8;
@addField(LightComponent)
native let allowDistantLight: Bool;
@addField(LightComponent)
native let rayTracingIntensityScale: Float;
@addField(LightComponent)
native let pathTracingLightUsage: rendEPathTracingLightUsage;
@addField(LightComponent)
native let pathTracingOverrideScaleGI: Bool;
@addField(LightComponent)
native let rtxdiShadowStartingDistance: Float;
@addField(LightComponent)
native let isEnabled: Bool;

@addField(MeshComponent)
native let mesh: ResourceAsyncRef;
@addField(MeshComponent)
native let meshResource: ref<CMesh>;
@addField(MeshComponent)
native let meshAppearance: CName;
@addField(MeshComponent)
native let castShadows: shadowsShadowCastingMode;
@addField(MeshComponent)
native let castLocalShadows: shadowsShadowCastingMode;
@addField(MeshComponent)
native let castRayTracedGlobalShadows: shadowsShadowCastingMode;
@addField(MeshComponent)
native let castRayTracedLocalShadows: shadowsShadowCastingMode;
@addField(MeshComponent)
native let motionBlurScale: Float;
@addField(MeshComponent)
native let visualScale: Vector3;
@addField(MeshComponent)
native let renderingPlane: ERenderingPlane;
@addField(MeshComponent)
native let objectTypeID: ERenderObjectType;
@addField(MeshComponent)
native let numInstances: Uint32;
@addField(MeshComponent)
native let chunkMask: Uint64;
@addField(MeshComponent)
native let order: Uint8;
@addField(MeshComponent)
native let isEnabled: Bool;
@addField(MeshComponent)
native let LODMode: entMeshComponentLODMode;
@addField(MeshComponent)
native let forcedLodDistance: entForcedLodDistance;
@addField(MeshComponent)
native let overrideMeshNavigationImpact: Bool;
@addField(MeshComponent)
native let navigationImpact: NavGenNavigationSetting;

@addField(PhysicalDestructionComponent)
native let mesh: ResourceAsyncRef; // raRef<CMesh>
@addField(PhysicalDestructionComponent)
native let meshAppearance: CName;
@addField(PhysicalDestructionComponent)
native let forceAutoHideDistance: Float;
@addField(PhysicalDestructionComponent)
native let destructionParams: physicsDestructionParams;
@addField(PhysicalDestructionComponent)
native let destructionLevelData: array<physicsDestructionLevelData>;
@addField(PhysicalDestructionComponent)
native let isEnabled: Bool;
@addField(PhysicalDestructionComponent)
native let audioMetadata: CName;
@addField(PhysicalDestructionComponent)
native let systemsToNotifyFlags: Uint16;

@addField(soundComponent)
native let subSystems: array<gameaudioSoundComponentSubSystemWrapper>;
@addField(soundComponent)
native let voEventOverride: CName;
@addField(soundComponent)
native let minVocalizationRepeatTime: Float;
@addField(soundComponent)
native let streamingDistance: Float;

@addField(SoundComponentBase)
native let audioName: CName;
@addField(SoundComponentBase)
native let applyObstruction: Bool;
@addField(SoundComponentBase)
native let applyAcousticOcclusion: Bool;
@addField(SoundComponentBase)
native let applyAcousticRepositioning: Bool;
@addField(SoundComponentBase)
native let obstructionChangeTime: Float;
@addField(SoundComponentBase)
native let maxPlayDistance: Float;

@addField(vehicleController)
native let alarmCurve: CName;
@addField(vehicleController)
native let alarmTime: Float;
@addField(vehicleController)
native let overrideHeadlightsSettingsForPlayer: Bool;

@addField(vehicleControllerPS)
native persistent let state: vehicleEState;
@addField(vehicleControllerPS)
native persistent let lightMode: vehicleELightMode;
@addField(vehicleControllerPS)
native persistent let isAlarmOn: Bool;
@addField(vehicleControllerPS)
native persistent let lightTypeMask: Int32;

@addField(VehicleObject)
native let isOnGround: Bool;
@addField(VehicleObject)
native let acceleration: Float;
@addField(VehicleObject)
native let deceleration: Float;
@addField(VehicleObject)
native let isReversing: Bool;
@addField(VehicleObject)
native let burnout: Float;

@addField(worlduiWidgetComponent)
native let cursorResource: ResourceRef; // rRef<inkWidgetLibraryResource>
@addField(worlduiWidgetComponent)
native let widgetResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
@addField(worlduiWidgetComponent)
native let itemNameToSpawn: CName;
@addField(worlduiWidgetComponent)
native let staticTextureResource: ResourceAsyncRef; // raRef<CBitmapTexture>
@addField(worlduiWidgetComponent)
native let sceneWidgetProperties: worlduiSceneWidgetProperties;
@addField(worlduiWidgetComponent)
native let spawnDistanceOverride: Float;
@addField(worlduiWidgetComponent)
native let limitedSpawnDistanceFromVehicle: Bool;

public native class AbortSummoningActionEvent extends ActionEvent {}

public native struct AbsolutePathSerializable {
  native let Path: String;
}

public native class AcousticPortalComponent extends IPlacedComponent {
  native let radius: Uint8;
  native let nominalRadius: Uint8;
  native let initialyOpen: Bool;
}

public native struct ActionParameterBool {
  native let name: CName;
  native let value: Bool;
}

public native struct ActionParameterCName {
  native let name: CName;
  native let value: CName;
}

public native struct ActionParameterDouble {
  native let name: CName;
  native let value: Double;
}

public native struct ActionParameterFloat {
  native let name: CName;
  native let value: Float;
}

public native struct ActionParameterInt {
  native let name: CName;
  native let value: Int32;
}

public native struct ActionParameterIScriptable {
  native let name: CName;
  native let value: ref<IScriptable>;
}

public native struct ActionParameterTweakDBID {
  native let name: CName;
  native let value: TweakDBID;
}

public native struct ActionParameterVector {
  native let name: CName;
  native let value: Vector4;
}

public native struct ActionParameterWeakIScriptable {
  native let name: CName;
  native let value: wref<IScriptable>;
}

public native class ActionScript extends IObjectScriptBase {
  native let actionFlags: Uint32;
  public final native func EnableUpdate()
  public final native func GetAITime()
}

public native class ActivityCardsSystem extends IActivityCardsSystem {}

public native class AddedAsHostileThreat extends AIEvent {
  native let threateningEntity: wref<TargetTrackerComponent>;
  native let threateningEntityCanTriggersCombat: Bool;
}

public native class AdjustableStreamingRangeTarget extends GameObject {
  native let minStreamingDistance: Float;
}

enum AdvertisementFormat {
  Format_0_7x1 = 0,
  Format_1x1 = 1,
  Format_1x0_7 = 2,
  Format_1x1_5 = 3,
  Format_1x2 = 4,
  Format_1x3_3 = 5,
  Format_1_5x1 = 6,
  Format_2x1 = 7,
  Format_3_3x1 = 8,
  Format_3x4 = 9,
  Format_4x3 = 10,
  Format_9x16 = 11,
  Format_9x21 = 12,
  Format_16x9 = 13,
  Format_21x9 = 14,
  Format_a = 15,
  Format_b = 16,
  Format_c = 17,
  Format_d = 18,
  Format_e = 19,
  Format_f = 20,
  Format_i = 21,
  Format_o = 22,
  Format_k = 23,
}

enum AdvertisementLoadMode {
  TweakDB = 0,
  Override = 1,
}

public native class AdvertisementWidgetComponent extends IWorldWidgetComponent {
  native let format: AdvertisementFormat;
  native let adGroupTDBID: TweakDBID;
  native let enableOverride: Bool;
  native let adOverrideTDBID: TweakDBID;
  native let adVersion: Uint32;
  native let useOnlyAttachedLights: Bool;
  public final native func GetLocalizedDescription()
}

public native class AdvertTranslationLogicController extends inkGameController {
  native let advertText: inkTextRef;
}

public native class AIActionSpot extends AISmartSpot {
  native let resource: ResourceAsyncRef; // raRef<workWorkspotResource>
  native let ActorBodytypeE3: AISocketsForRig;
  native let masterNodeRef: NodeRef;
  native let enabledWhenMasterOccupied: Bool;
  native let snapToGround: Bool;
  native let useClippingSpace: Bool;
  native let clippingSpaceOrientation: Float;
  native let clippingSpaceRange: Float;
}

public native struct AIAIBlackboardSerializableID {
  native let id: BlackboardSerializableID;
}

public native class AIArchetype extends CResource {
  native let behaviorDefinition: ref<AIbehaviorParameterizedBehavior>;
}

public native class AIArchetypeSet extends CResource {
  native let archetypeResources: array<AIArchetypeSetEntry>;
}

public native struct AIArchetypeSetEntry {
  native let name: CName;
  native let resource: ResourceRef; // rRef<AIArchetype>
}

public native class AIArgumentBoolValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: Bool;
}

public native class AIArgumentCNameValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: CName;
}

public abstract native class AIArgumentDefinition extends ISerializable {
  native let name: CName;
  native let isPersistent: Bool;
  native let behaviorCallbackName: CName;
}

public native class AIArgumentEnumValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let enumClass: CName;
  native let defaultValue: Int64;
}

public native class AIArgumentFloatValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: Float;
}

public native class AIArgumentGlobalNodeIdValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: GlobalNodeID;
}

public abstract native class AIArgumentInstancePS extends ISerializable {
  native persistent let name: CName;
}

public native class AIArgumentIntValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: Int32;
}

public native class AIArgumentNodeRefValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: NodeRef;
}

public native class AIArgumentObjectValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: wref<GameObject>;
}

public native struct AIArgumentOverrideWrapper {
  native let name: CName;
  native let type: AIArgumentType;
  native let definition: ref<AIArgumentDefinition>;
}

public native class AIArgumentPuppetRefValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: EntityReference;
}

public native class AIArgumentReference extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: Variant;
  native let rttiClassName: CName;
}

public native class AIArgumentSerializableValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: ref<ISerializable>;
}

public native class AIArgumentTreeRefValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: ref<AIbehaviorParameterizedBehavior>;
}

public native class AIArgumentUint64Value extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: Uint64;
}

public native class AIArgumentVectorValue extends AIArgumentDefinition {
  native let type: AIArgumentType;
  native let defaultValue: Vector3;
}

public native class AIAudioSquad extends SquadBase {}

public native class AIbehaviorActionAnimationCurvePathDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let nodeReference: ref<AIArgumentMapping>;
  native let controllersSetupName: ref<AIArgumentMapping>;
  native let useStart: ref<AIArgumentMapping>;
  native let useStop: ref<AIArgumentMapping>;
  native let blendTime: ref<AIArgumentMapping>;
  native let globalInBlendTime: ref<AIArgumentMapping>;
  native let globalOutBlendTime: ref<AIArgumentMapping>;
  native let turnCharacterToMatchVelocity: ref<AIArgumentMapping>;
  native let customStartAnimationName: ref<AIArgumentMapping>;
  native let customMainAnimationName: ref<AIArgumentMapping>;
  native let customStopAnimationName: ref<AIArgumentMapping>;
  native let startSnapToTerrain: ref<AIArgumentMapping>;
  native let mainSnapToTerrain: ref<AIArgumentMapping>;
  native let stopSnapToTerrain: ref<AIArgumentMapping>;
  native let startSnapToTerrainBlendTime: ref<AIArgumentMapping>;
  native let stopSnapToTerrainBlendTime: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionDieTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {}

public native class AIbehaviorActionDroneMoveSplineTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let spline: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionDroneMoveTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let moveType: ref<AIArgumentMapping>;
  native let target: ref<AIArgumentMapping>;
  native let movementTarget: ref<AIArgumentMapping>;
  native let toleranceRadius: ref<AIArgumentMapping>;
  native let desiredDistanceFromTarget: ref<AIArgumentMapping>;
  native let strafingTarget: ref<AIArgumentMapping>;
  native let stopWhenDestinationReached: ref<AIArgumentMapping>;
  native let rotateEntity: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionDynamicMoveTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let moveType: ref<AIArgumentMapping>;
  native let target: ref<AIArgumentMapping>;
  native let targetPosition: ref<AIArgumentMapping>;
  native let toleranceRadius: ref<AIArgumentMapping>;
  native let desiredDistanceFromTarget: ref<AIArgumentMapping>;
  native let strafingTarget: ref<AIArgumentMapping>;
  native let stopWhenDestinationReached: ref<AIArgumentMapping>;
  native let rotateEntity: ref<AIArgumentMapping>;
  native let ignoreNavigation: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionEquipItemNodeDefinition extends AIbehaviorActionItemHandlingNodeDefinition {
  native let slotId: ref<AIArgumentMapping>;
  native let itemId: ref<AIArgumentMapping>;
  native let duration: ref<AIArgumentMapping>;
  native let failIfItemNotFound: ref<AIArgumentMapping>;
  native let spawnDelay: ref<AIArgumentMapping>;
}

public abstract native class AIbehaviorActionItemHandlingNodeDefinition extends AIbehaviorActionTreeNodeDefinition {}

public abstract native class AIbehaviorActionMountHandlingNodeDefinition extends AIbehaviorActionTreeNodeDefinition {}

public native class AIbehaviorActionMountNodeDefinition extends AIbehaviorActionMountHandlingNodeDefinition {
  native let mountData: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionMoveOnSplineNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let spline: ref<AIArgumentMapping>;
  native let strafingTarget: ref<AIArgumentMapping>;
  native let movementType: ref<AIArgumentMapping>;
  native let ignoreNavigation: ref<AIArgumentMapping>;
  native let snapToTerrain: ref<AIArgumentMapping>;
  native let rotateEntity: ref<AIArgumentMapping>;
  native let startFromClosestPoint: ref<AIArgumentMapping>;
  native let splineRecalculation: ref<AIArgumentMapping>;
  native let useStart: ref<AIArgumentMapping>;
  native let useStop: ref<AIArgumentMapping>;
  native let reverse: ref<AIArgumentMapping>;
  native let isBackAndForth: ref<AIArgumentMapping>;
  native let isInfinite: ref<AIArgumentMapping>;
  native let numberOfLoops: ref<AIArgumentMapping>;
  native let useOffMeshLinkReservation: ref<AIArgumentMapping>;
  native let disableFootIK: ref<AIArgumentMapping>;
  native let allowCrowdOnPath: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionMoveToSmartObjectNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let smartObjectId: ref<AIArgumentMapping>;
  native let lookAtTarget: ref<AIArgumentMapping>;
  native let movementType: ref<AIArgumentMapping>;
  native let tolerance: ref<AIArgumentMapping>;
  native let ignoreNavigation: ref<AIArgumentMapping>;
  native let rotateEntity: ref<AIArgumentMapping>;
  native let useStart: ref<AIArgumentMapping>;
  native let useStop: ref<AIArgumentMapping>;
  native let forcedEntryAnimation: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionMoveToWorkspotNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let workspotSetup: ref<AIArgumentMapping>;
  native let lookAtTarget: ref<AIArgumentMapping>;
  native let movementType: ref<AIArgumentMapping>;
  native let tolerance: ref<AIArgumentMapping>;
  native let ignoreNavigation: ref<AIArgumentMapping>;
  native let rotateEntity: ref<AIArgumentMapping>;
  native let useStart: ref<AIArgumentMapping>;
  native let spotReservation: ref<AIArgumentMapping>;
  native let startTangent: ref<AIArgumentMapping>;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
  native let ignoreExploration: ref<AIArgumentMapping>;
  native let failWhenStoppedByCollision: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionMoveTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let movementTarget: ref<AIArgumentMapping>;
  native let lookAtTarget: ref<AIArgumentMapping>;
  native let movementType: ref<AIArgumentMapping>;
  native let tolerance: ref<AIArgumentMapping>;
  native let ignoreNavigation: ref<AIArgumentMapping>;
  native let rotateEntity: ref<AIArgumentMapping>;
  native let useStart: ref<AIArgumentMapping>;
  native let useStop: ref<AIArgumentMapping>;
  native let destinationTangent: ref<AIArgumentMapping>;
  native let startTangent: ref<AIArgumentMapping>;
  native let spotReservation: ref<AIArgumentMapping>;
  native let ignoreRestrictedArea: ref<AIArgumentMapping>;
  native let ignoreCollisionsWhenCloseToTarget: ref<AIArgumentMapping>;
  native let failWhenStoppedByCollision: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionMoveWithPolicyTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let stopWhenDestinationReached: Bool;
}

public abstract native class AIbehaviorActionRotateBaseTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let target: ref<AIArgumentMapping>;
  native let angleOffset: ref<AIArgumentMapping>;
  native let angleTolerance: ref<AIArgumentMapping>;
  native let speed: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionRotateByAngleTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let angle: ref<AIArgumentMapping>;
  native let angleTolerance: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionRotateToObjectConstTimeTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let target: ref<AIArgumentMapping>;
  native let angleOffset: ref<AIArgumentMapping>;
  native let angleTolerance: ref<AIArgumentMapping>;
  native let time: ref<AIArgumentMapping>;
  native let keepUpdatingTarget: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionRotateToObjectHeadingTreeNodeDefinition extends AIbehaviorActionRotateBaseTreeNodeDefinition {}

public native class AIbehaviorActionRotateToObjectTreeNodeDefinition extends AIbehaviorActionRotateBaseTreeNodeDefinition {
  native let completeWhenRotated: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionRotateToPositionTreeNodeDefinition extends AIbehaviorActionRotateBaseTreeNodeDefinition {}

public native class AIbehaviorActionSceneAnimationMotionNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let params: ref<AIArgumentMapping>;
  native let mountData: ref<AIArgumentMapping>;
}

public abstract native class AIbehaviorActionSlideNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let duration: ref<AIArgumentMapping>;
  native let ignoreNavigation: ref<AIArgumentMapping>;
  native let rotateTowardsMovementDirection: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionSlideToLocalPositionNodeDefinition extends AIbehaviorActionSlideNodeDefinition {
  native let localOffset: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionSlideToObjectNodeDefinition extends AIbehaviorActionSlideNodeDefinition {
  native let destination: ref<AIArgumentMapping>;
  native let offset: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionSlideToWorldPositionNodeDefinition extends AIbehaviorActionSlideNodeDefinition {
  native let worldPosition: ref<AIArgumentMapping>;
  native let useMovePlanner: Bool;
}

public native class AIbehaviorActionTeleportTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let destinationPoint: ref<AIArgumentMapping>;
  native let doNavTest: ref<AIArgumentMapping>;
  native let rotation: ref<AIArgumentMapping>;
  native let waitForPositionUpdate: ref<AIArgumentMapping>;
}

public abstract native class AIbehaviorActionTreeNodeDefinition extends AIbehaviorLeafTreeNodeDefinition {
  native let command: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionUnequipItemNodeDefinition extends AIbehaviorActionItemHandlingNodeDefinition {
  native let slotId: ref<AIArgumentMapping>;
  native let duration: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionUnmountNodeDefinition extends AIbehaviorActionMountHandlingNodeDefinition {
  native let mountData: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionUseCommunityWorkspotNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let workspotData: ref<AIArgumentMapping>;
  native let dependentWorkspotData: ref<AIArgumentMapping>;
  native let playExitAutomatically: ref<AIArgumentMapping>;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
}

public native class AIbehaviorActionUseWorkspotNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let eventData: ref<AIArgumentMapping>;
  native let playStartAnimationAfterwards: ref<AIArgumentMapping>;
  native let mountData: ref<AIArgumentMapping>;
  native let dependentWorkspotData: ref<AIArgumentMapping>;
  native let playExitAutomatically: ref<AIArgumentMapping>;
  native let markUninterruptable: ref<AIArgumentMapping>;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
}

enum AIbehaviorActivationStatus {
  NOT_ACTIVATED = 0,
  ACTIVATING = 1,
  ACTIVATED = 2,
  DEACTIVATING = 3,
}

public native class AIbehaviorAdvancedParameterizedBehavior extends AIbehaviorParameterizedBehavior {}

public native class AIbehaviorAgentInfoDebuggerCommand extends AIbehaviorIDebuggerCommand {
  native let entityId: EntityID;
  native let agentName: String;
  native let isSelected: Bool;
  native let entries: array<AIbehaviorAgentInfoDebuggerCommandEntry>;
}

public native struct AIbehaviorAgentInfoDebuggerCommandEntry {
  native let callStack: AIbehaviorBehaviorInstanceCallStack;
  native let behaviorResourcePath: String;
}

public native class AIbehaviorAndConditionDefinition extends AIbehaviorCompositeConditionDefinition {}

public native class AIbehaviorAssignTaskDefinition extends AIbehaviorTaskDefinition {
  native let assignments: array<AIbehaviorAssignTaskItem>;
  native let endAssignments: array<AIbehaviorAssignTaskItem>;
}

public native struct AIbehaviorAssignTaskItem {
  native let leftHandSide: ref<AIArgumentMapping>;
  native let rightHandSide: ref<AIArgumentMapping>;
}

public native struct AIbehaviorAsyncCallbackToken {}

public native class AIbehaviorAttachToElevatorCommandTaskDefinition extends AIbehaviorTaskDefinition {
  native let command: ref<AIArgumentMapping>;
}

public native class AIbehaviorAvoidPlayerTaskDefinition extends AIbehaviorTaskDefinition {
  native let threatRadius: ref<AIArgumentMapping>;
}

public abstract native class AIbehaviorBehaviorComponentDefinition extends ISerializable {}

public native class AIbehaviorBehaviorDebugInfo extends AIbehaviorDebugInfoBase {}

public native class AIbehaviorBehaviorIncludedDebuggerCommand extends AIbehaviorIDebuggerCommand {
  native let entries: array<AIbehaviorBehaviorIncludedDebuggerCommandEntry>;
}

public native struct AIbehaviorBehaviorIncludedDebuggerCommandEntry {
  native let includedBehaviorResourcePath: String;
}

public native struct AIbehaviorBehaviorInstanceCallStack {
  native let resourceHashes: array<Uint32>;
}

public native class AIbehaviorCancelWorkspotCommandNodeDefinition extends AIbehaviorDecoratorNodeDefinition {}

public native class AIbehaviorChangeGuardAreaTaskDefinition extends AIbehaviorTaskDefinition {
  native let guardAreaNodeRef: ref<AIArgumentMapping>;
}

public native class AIbehaviorCheckDistanceToCompanionConditionDefinition extends AIbehaviorCompanionConditionDefinition {
  native let distance: ref<AIArgumentMapping>;
  native let comparisonOperator: EComparisonType;
}

public native class AIbehaviorCheckLineOfFireTaskDefinition extends AIbehaviorTaskDefinition {
  native let slotName: ref<AIArgumentMapping>;
  native let attachmentName: ref<AIArgumentMapping>;
  native let spread: ref<AIArgumentMapping>;
  native let maxRange: ref<AIArgumentMapping>;
}

public native class AIbehaviorClearActiveNodesDebuggerCommand extends AIbehaviorIDebuggerCommand {}

public native class AIbehaviorClearSearchInfluenceTaskDefinition extends AIbehaviorTaskDefinition {
  native let clearedAreaRadius: ref<AIArgumentMapping>;
  native let clearedAreaDistance: ref<AIArgumentMapping>;
  native let clearedAreaAngle: ref<AIArgumentMapping>;
}

public native class AIbehaviorClearUsedAlertedSpotsTaskDefinition extends AIbehaviorTaskDefinition {
  native let usedTokens: ref<AIArgumentMapping>;
}

public native class AIbehaviorCombatModeTaskDefinition extends AIbehaviorTaskDefinition {
  native let mode: AIbehaviorCombatModes;
  native let priority: Int32;
  native let timeToLive: Float;
}

public native class AIbehaviorCommandConditionDefinition extends AIbehaviorConditionDefinition {
  native let commandName: ref<AIArgumentMapping>;
  native let useInheritance: Bool;
  native let isWaiting: Bool;
  native let isExecuting: Bool;
  native let commandOut: ref<AIArgumentMapping>;
}

public native class AIbehaviorCommandConditionExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let commandName: CName;
  native let useInheritance: Bool;
  native let isEnqueued: Bool;
  native let isExecuting: Bool;
}

public native class AIbehaviorCommandHandlerNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let commandName: CName;
  native let useInheritance: Bool;
  native let contexts: array<AICommandContextsType>;
  native let commandOut: ref<AIArgumentMapping>;
  native let runningSignal: CName;
  native let waitForCommand: Bool;
  native let retryIfCommandEnqueued: Bool;
  native let resultIfNoCommand: AIbehaviorCompletionStatus;
  native let resultIfChildFailed: AIbehaviorCompletionStatus;
}

public abstract native class AIbehaviorCompanionConditionDefinition extends AIbehaviorConditionDefinition {
  native let spline: ref<AIArgumentMapping>;
  native let companion: ref<AIArgumentMapping>;
}

public native class AIbehaviorComparisonExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let leftHandSide: ref<AIbehaviorExpressionSocket>;
  native let operator: EComparisonType;
  native let rightHandSide: ref<AIbehaviorExpressionSocket>;
}

public native class AIbehaviorCompleteOnEventNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let eventName: CName;
  native let resultOnEvent: AIbehaviorCompletionStatus;
}

public abstract native class AIbehaviorCompositeConditionDefinition extends AIbehaviorConditionDefinition {
  native let conditions: array<ref<AIbehaviorConditionDefinition>>;
}

public abstract native class AIbehaviorCompositeTreeNodeDefinition extends AIbehaviorTreeNodeDefinition {
  native let children: array<ref<AIbehaviorTreeNodeDefinition>>;
}

public abstract native class AIbehaviorConditionDefinition extends AIbehaviorBehaviorComponentDefinition {
  native let isInverted: Bool;
}

public abstract native class AIbehaviorConditionNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let condition: ref<AIbehaviorConditionDefinition>;
  native let resultIfFailed: AIbehaviorCompletionStatus;
}

public native class AIbehaviorConstantExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let type: AIbehaviorTypeRef;
  native let value: Variant;
}

public native class AIbehaviorConvertCommandToDynamicWorkspotTaskDefinition extends AIbehaviorTaskDefinition {
  native let command: ref<AIArgumentMapping>;
  native let outWorkspotData: ref<AIArgumentMapping>;
}

public native class AIbehaviorConvertToDynamicWorkspotTaskDefinition extends AIbehaviorTaskDefinition {
  native let workspotData: ref<AIArgumentMapping>;
  native let spotInstance: ref<AIArgumentMapping>;
  native let jumpToEntry: ref<AIArgumentMapping>;
  native let entryId: ref<AIArgumentMapping>;
}

public native class AIbehaviorCreateAlertedInfluenceMapTaskDefinition extends AIbehaviorTaskDefinition {}

public native class AIbehaviorCrowdSettingsNameVehicleExpressionDefinition extends AIbehaviorVehicleExpressionDefinition {
  native let settingsName: CName;
}

public native class AIbehaviorCTreeNodeControlledByQuestNodeDefinition extends AIbehaviorActionTreeNodeDefinition {}

public native class AIbehaviorDebugFailsafeConditionDefinition extends AIbehaviorConditionDefinition {
  native let logMessage: ref<AIArgumentMapping>;
}

public native class AIbehaviorDebugger extends AIbehaviorIDebugger {}

public native class AIbehaviorDebugInfoBase extends ISerializable {
  native let caption: String;
}

enum AIbehaviorDebugNodeStatus {
  Undefined = 0,
  NotRunning = 1,
  ForceStopped = 2,
  Running = 3,
  Success = 4,
  Failure = 5,
}

public abstract native class AIbehaviorDecoratorNodeDefinition extends AIbehaviorTreeNodeDefinition {
  native let child: ref<AIbehaviorTreeNodeDefinition>;
}

public native class AIbehaviorDelegateExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let delegateAttribute: AIDelegateAttrRef;
  native let behaviorCallbackNames: array<CName>;
}

public native class AIbehaviorDelegateTaskDefinition extends AIbehaviorTaskDefinition {
  native let onActivate: AIDelegateTaskRef;
  native let onUpdate: AIDelegateTaskRef;
  native let onDeactivate: AIDelegateTaskRef;
}

public native class AIbehaviorDistanceToExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let target: ref<AIbehaviorExpressionSocket>;
  native let tolerance: Float;
  native let updatePeriod: Float;
}

public abstract native class AIbehaviorDistanceToTargetConditionDefinition extends AIbehaviorConditionDefinition {
  native let target: ref<AIArgumentMapping>;
  native let distance: ref<AIArgumentMapping>;
  native let comparisonOperator: EComparisonType;
}

public native class AIbehaviorDistanceToTargetObjectConditionDefinition extends AIbehaviorDistanceToTargetConditionDefinition {}

public native class AIbehaviorDistanceToTargetPositionConditionDefinition extends AIbehaviorDistanceToTargetConditionDefinition {}

public native class AIbehaviorDriveAvSimpleTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let timeToTravel: ref<AIArgumentMapping>;
  native let distanceToTravel: ref<AIArgumentMapping>;
  native let useEaseInFunction: ref<AIArgumentMapping>;
  native let useEaseOutFunction: ref<AIArgumentMapping>;
  native let movementDirection: ref<AIArgumentMapping>;
  native let useForwardDirection: ref<AIArgumentMapping>;
  native let easeBounceMultiplier: ref<AIArgumentMapping>;
  native let despawnAtTheEnd: ref<AIArgumentMapping>;
  native let disableVFXs: ref<AIArgumentMapping>;
  native let facePlayer: ref<AIArgumentMapping>;
  native let doLandingRotation: ref<AIArgumentMapping>;
  native let interruptTaskOnLandingFound: ref<AIArgumentMapping>;
  native let attemptToSendEarlyDismountCommand: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveChaseTargetTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let target: ref<AIArgumentMapping>;
  native let distanceMin: ref<AIArgumentMapping>;
  native let distanceMax: ref<AIArgumentMapping>;
  native let forcedStartSpeed: ref<AIArgumentMapping>;
  native let needDriver: ref<AIArgumentMapping>;
  native let aggressiveRammingEnabled: ref<AIArgumentMapping>;
  native let ignoreChaseVehiclesLimit: ref<AIArgumentMapping>;
  native let boostDrivingStats: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveCreateTrafficSlotTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDriveFollowPositionTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDriveFollowSlotTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDriveFollowSplineTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let useKinematic: ref<AIArgumentMapping>;
  native let needDriver: ref<AIArgumentMapping>;
  native let spline: ref<AIArgumentMapping>;
  native let secureTimeOut: ref<AIArgumentMapping>;
  native let backwards: ref<AIArgumentMapping>;
  native let reverse: ref<AIArgumentMapping>;
  native let closest: ref<AIArgumentMapping>;
  native let forcedStartSpeed: ref<AIArgumentMapping>;
  native let stopAtPathEnd: ref<AIArgumentMapping>;
  native let keepDistanceParamBool: ref<AIArgumentMapping>;
  native let keepDistanceParamCompanion: ref<AIArgumentMapping>;
  native let keepDistanceParamDistance: ref<AIArgumentMapping>;
  native let rubberBandingBool: ref<AIArgumentMapping>;
  native let rubberBandingTargetRef: ref<AIArgumentMapping>;
  native let rubberBandingMinDistance: ref<AIArgumentMapping>;
  native let rubberBandingMaxDistance: ref<AIArgumentMapping>;
  native let rubberBandingStopAndWait: ref<AIArgumentMapping>;
  native let rubberBandingTeleportToCatchUp: ref<AIArgumentMapping>;
  native let audioCurvesParam: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveFollowTargetTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let useKinematic: ref<AIArgumentMapping>;
  native let needDriver: ref<AIArgumentMapping>;
  native let target: ref<AIArgumentMapping>;
  native let secureTimeOut: ref<AIArgumentMapping>;
  native let distanceMin: ref<AIArgumentMapping>;
  native let distanceMax: ref<AIArgumentMapping>;
  native let isPlayer: ref<AIArgumentMapping>;
  native let stopHasReachedTarget: ref<AIArgumentMapping>;
  native let useTraffic: ref<AIArgumentMapping>;
  native let allowStubMovement: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveIdleTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDriveJoinTrafficTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDrivePanicTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let allowSimplifiedMovement: ref<AIArgumentMapping>;
  native let ignoreTickets: ref<AIArgumentMapping>;
  native let disableStuckDetection: ref<AIArgumentMapping>;
  native let useSpeedBasedLookupRange: ref<AIArgumentMapping>;
  native let tryDriveAwayFromPlayer: ref<AIArgumentMapping>;
  native let needDriver: ref<AIArgumentMapping>;
}

public native class AIbehaviorDrivePatrolTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let maxSpeed: ref<AIArgumentMapping>;
  native let minSpeed: ref<AIArgumentMapping>;
  native let clearTrafficOnPath: ref<AIArgumentMapping>;
  native let emergencyPatrol: ref<AIArgumentMapping>;
  native let numPatrolLoops: ref<AIArgumentMapping>;
  native let forcedStartSpeed: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveRacingTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let useKinematic: ref<AIArgumentMapping>;
  native let needDriver: ref<AIArgumentMapping>;
  native let spline: ref<AIArgumentMapping>;
  native let secureTimeOut: ref<AIArgumentMapping>;
  native let backwards: ref<AIArgumentMapping>;
  native let reverse: ref<AIArgumentMapping>;
  native let closest: ref<AIArgumentMapping>;
  native let forcedStartSpeed: ref<AIArgumentMapping>;
  native let stopAtPathEnd: ref<AIArgumentMapping>;
  native let keepDistanceParamBool: ref<AIArgumentMapping>;
  native let keepDistanceParamCompanion: ref<AIArgumentMapping>;
  native let keepDistanceParamDistance: ref<AIArgumentMapping>;
  native let rubberBandingBool: ref<AIArgumentMapping>;
  native let rubberBandingTargetRef: ref<AIArgumentMapping>;
  native let rubberBandingTargetForwardOffset: ref<AIArgumentMapping>;
  native let rubberBandingMinDistance: ref<AIArgumentMapping>;
  native let rubberBandingMaxDistance: ref<AIArgumentMapping>;
  native let rubberBandingStopAndWait: ref<AIArgumentMapping>;
  native let rubberBandingTeleportToCatchUp: ref<AIArgumentMapping>;
  native let rubberBandingStayInFront: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveSplineReverseTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let spline: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveStunnedTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDriveSummoningTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {}

public native class AIbehaviorDriveToNodeTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let useKinematic: ref<AIArgumentMapping>;
  native let needDriver: ref<AIArgumentMapping>;
  native let nodeRef: ref<AIArgumentMapping>;
  native let stopAtPathEnd: ref<AIArgumentMapping>;
  native let secureTimeOut: ref<AIArgumentMapping>;
  native let isPlayer: ref<AIArgumentMapping>;
  native let useTraffic: ref<AIArgumentMapping>;
  native let speedInTraffic: ref<AIArgumentMapping>;
  native let forceGreenLights: ref<AIArgumentMapping>;
  native let portals: ref<AIArgumentMapping>;
  native let trafficTryNeighborsForStart: ref<AIArgumentMapping>;
  native let trafficTryNeighborsForEnd: ref<AIArgumentMapping>;
  native let ignoreNoAIDrivingLanes: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveToPointAutonomousTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let targetPosition: ref<AIArgumentMapping>;
  native let maxSpeed: ref<AIArgumentMapping>;
  native let minSpeed: ref<AIArgumentMapping>;
  native let clearTrafficOnPath: ref<AIArgumentMapping>;
  native let minimumDistanceToTarget: ref<AIArgumentMapping>;
  native let forcedStartSpeed: ref<AIArgumentMapping>;
  native let driveDownTheRoadIndefinitely: ref<AIArgumentMapping>;
}

public native class AIbehaviorDriveToPointTreeNodeDefinition extends AIbehaviorDriveTreeNodeDefinition {
  native let targetPosition: ref<AIArgumentMapping>;
  native let secureTimeOut: ref<AIArgumentMapping>;
  native let useTraffic: ref<AIArgumentMapping>;
  native let speedInTraffic: ref<AIArgumentMapping>;
  native let forceGreenLights: ref<AIArgumentMapping>;
  native let portals: ref<AIArgumentMapping>;
  native let trafficTryNeighborsForStart: ref<AIArgumentMapping>;
  native let trafficTryNeighborsForEnd: ref<AIArgumentMapping>;
}

public abstract native class AIbehaviorDriveTreeNodeDefinition extends AIbehaviorActionTreeNodeDefinition {}

enum AIbehaviorEdgeConditionAction {
  None = 0,
  Toggle = 1,
  TurnOn = 2,
  TurnOff = 3,
}

public native class AIbehaviorEdgeConditionDefinition extends AIbehaviorUnaryConditionDefinition {
  native let risingEdgeAction: AIbehaviorEdgeConditionAction;
  native let fallingEdgeAction: AIbehaviorEdgeConditionAction;
  native let initialValue: Bool;
}

public native class AIbehaviorEntityLODConditionDefinition extends AIbehaviorConditionDefinition {
  native let any: array<AIbehaviorEntityLODConditions>;
  native let all: array<AIbehaviorEntityLODConditions>;
  native let none: array<AIbehaviorEntityLODConditions>;
}

enum AIbehaviorEntityLODConditions {
  Crowd = 0,
  Cinematic = 1,
  WorkspotStatic = 2,
}

public native class AIbehaviorEntityReuseEventResolverDefinition extends AIbehaviorEventResolverDefinition {
  native let destination: ref<AIArgumentMapping>;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
}

public native class AIbehaviorEventConditionDefinition extends ISerializable {
  native let condition: ref<AIbehaviorConditionDefinition>;
  native let eventName: CName;
}

public native struct AIbehaviorEventHandler {}

public native class AIbehaviorEventHandlerNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let eventName: CName;
  native let resolver: ref<AIbehaviorEventResolverDefinition>;
}

public abstract native class AIbehaviorEventResolverDefinition extends ISerializable {}

public native class AIbehaviorEventWithTagConditionDefinition extends AIbehaviorConditionDefinition {
  native let tag: CName;
  native let consumeEvent: Bool;
}

public native class AIbehaviorExitWorkspotNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let skipExitAnimation: ref<AIArgumentMapping>;
  native let useSlowExitAnimation: ref<AIArgumentMapping>;
  native let doSlowIfFastExitFails: ref<AIArgumentMapping>;
  native let stayInWorkspotIfExitFails: ref<AIArgumentMapping>;
  native let tryBlendFastExitToWalk: ref<AIArgumentMapping>;
  native let dontRequestExit: ref<AIArgumentMapping>;
  native let cancelQueuedCommand: ref<AIArgumentMapping>;
  native let target: ref<AIArgumentMapping>;
}

public native class AIbehaviorExpressionSocket extends ISerializable {
  native let typeHint: AIbehaviorTypeRef;
  native let expression: ref<AIbehaviorPassiveExpressionDefinition>;
}

public native class AIbehaviorExtractMountDataTaskDefinition extends AIbehaviorTaskDefinition {
  native let mountEventData: ref<AIArgumentMapping>;
  native let outWorkspotData: ref<AIArgumentMapping>;
  native let outIsInstant: ref<AIArgumentMapping>;
  native let outAllowFailsafeTeleport: ref<AIArgumentMapping>;
}

public native class AIbehaviorExtractMountParentStubPositionTaskDefinition extends AIbehaviorTaskDefinition {
  native let mountData: ref<AIArgumentMapping>;
  native let position: ref<AIArgumentMapping>;
}

public native class AIbehaviorExtractVehicleSlotWorkspotTaskDefinition extends AIbehaviorTaskDefinition {
  native let outWorkspotData: ref<AIArgumentMapping>;
}

public native class AIbehaviorFailerNodeDefinition extends AIbehaviorLeafTreeNodeDefinition {}

public native class AIbehaviorFindAlertedWorkspotTaskDefinition extends AIbehaviorTaskDefinition {
  native let usedTokens: ref<AIArgumentMapping>;
  native let spots: ref<AIArgumentMapping>;
  native let radius: ref<AIArgumentMapping>;
  native let outWorkspotData: ref<AIArgumentMapping>;
}

public native class AIbehaviorFindClosestPointOnPathTaskDefinition extends AIbehaviorTaskDefinition {
  native let path: ref<AIArgumentMapping>;
  native let forceStartFromClosest: ref<AIArgumentMapping>;
  native let patrolProgress: ref<AIArgumentMapping>;
  native let positionOnPath: ref<AIArgumentMapping>;
  native let entryTangent: ref<AIArgumentMapping>;
}

public native class AIbehaviorFindClosestPointOnTrafficPathTaskDefinition extends AIbehaviorTaskDefinition {
  native let enterClosest: ref<AIArgumentMapping>;
  native let avoidedPosition: ref<AIArgumentMapping>;
  native let useThreatPosAsAvoidedPos: ref<AIArgumentMapping>;
  native let avoidedPositionDistance: ref<AIArgumentMapping>;
  native let usePreviousPosition: ref<AIArgumentMapping>;
  native let checkRoadIntersection: ref<AIArgumentMapping>;
  native let workspotData: ref<AIArgumentMapping>;
  native let positionOnPath: ref<AIArgumentMapping>;
  native let pathDirection: ref<AIArgumentMapping>;
  native let joinTrafficSettings: ref<AIArgumentMapping>;
}

public native class AIbehaviorFindLaneTaskDefinition extends AIbehaviorTaskDefinition {
  native let pointOnLane: ref<AIArgumentMapping>;
  native let filter: worldFindLaneFilter;
}

public native class AIbehaviorFindNavigablePointTaskDefinition extends AIbehaviorTaskDefinition {
  native let destination: ref<AIArgumentMapping>;
  native let outAdjustedDestination: ref<AIArgumentMapping>;
  native let outWasAdjusted: ref<AIArgumentMapping>;
}

public native class AIbehaviorFindTeleportPositionTaskDefinition extends AIbehaviorTaskDefinition {
  native let patrolPath: ref<AIArgumentMapping>;
  native let teleportPosition: ref<AIArgumentMapping>;
  native let teleportRotation: ref<AIArgumentMapping>;
}

public native class AIbehaviorForcedBehaviorNodeDefinition extends AIbehaviorTreeNodeDefinition {}

public native class AIbehaviorFreeReservedWorkspotNodeDefinition extends AIbehaviorDecoratorNodeDefinition {}

public native class AIbehaviorFSMStateDefinition extends AIbehaviorTreeNodeDefinition {
  native let behaviorRoot: ref<AIbehaviorTreeNodeDefinition>;
  native let isInitial: Bool;
  native let isExit: Bool;
  native let completionStatus: AIbehaviorStateCompletionStatus;
}

public native struct AIbehaviorFSMStateWrapper {}

public native class AIbehaviorFSMTransitionDefinition extends AIbehaviorBehaviorComponentDefinition {
  native let inState: Uint16;
  native let outState: Uint16;
  native let evaluationOrder: Int32;
  native let instantConditions: array<ref<AIbehaviorInstantConditionDefinition>>;
  native let monitorConditions: array<ref<AIbehaviorMonitorConditionDefinition>>;
  native let eventConditions: array<ref<AIbehaviorEventConditionDefinition>>;
  native let passiveConditions: array<ref<AIbehaviorExpressionSocket>>;
}

public native class AIbehaviorFSMTreeNodeDefinition extends AIbehaviorTreeNodeDefinition {
  native let states: array<ref<AIbehaviorFSMStateDefinition>>;
  native let transitions: array<ref<AIbehaviorFSMTransitionDefinition>>;
  native let initialState: ref<AIbehaviorFSMStateDefinition>;
}

public native class AIbehaviorGenerateSearchInfluenceTaskDefinition extends AIbehaviorTaskDefinition {
  native let position: ref<AIArgumentMapping>;
  native let path: ref<AIArgumentMapping>;
  native let radius: ref<AIArgumentMapping>;
}

public native class AIbehaviorGetEntryPointOnPathTaskDefinition extends AIbehaviorTaskDefinition {
  native let patrolProgress: ref<AIArgumentMapping>;
  native let positionOnPath: ref<AIArgumentMapping>;
  native let entryTangent: ref<AIArgumentMapping>;
}

public native class AIbehaviorGetFollowTrailPointTaskDefinition extends AIbehaviorTaskDefinition {
  native let inTrailDelay: ref<AIArgumentMapping>;
  native let outFollowTrailPoint: ref<AIArgumentMapping>;
}

public native class AIbehaviorGetNextPointOnPathTaskDefinition extends AIbehaviorTaskDefinition {
  native let patrolProgress: ref<AIArgumentMapping>;
  native let positionOnPath: ref<AIArgumentMapping>;
  native let entryTangent: ref<AIArgumentMapping>;
}

public native class AIbehaviorGetPatrolPointTaskDefinition extends AIbehaviorTaskDefinition {
  native let inPatrolDistance: ref<AIArgumentMapping>;
  native let inLastKnownPosition: ref<AIArgumentMapping>;
  native let outFollowTrailPoint: ref<AIArgumentMapping>;
}

public native class AIbehaviorGetSearchPointTaskDefinition extends AIbehaviorTaskDefinition {
  native let inPlayerPositionDelay: ref<AIArgumentMapping>;
  native let inSearchPositionMaxRadius: ref<AIArgumentMapping>;
  native let inNearestNavmeshPolyExtent: ref<AIArgumentMapping>;
  native let inPavementsOnly: ref<AIArgumentMapping>;
  native let inLastKnownPosition: ref<AIArgumentMapping>;
  native let outSearchPosition: ref<AIArgumentMapping>;
}

public native class AIbehaviorGetSelectedAgentDebuggerCommand extends AIbehaviorIDebuggerCommand {}

public native class AIbehaviorHasDriverConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorHasPendingForcedBehaviorConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorHostilesDetectedConditionDefinition extends AIbehaviorConditionDefinition {}

public abstract native class AIbehaviorIDebugger extends ISerializable {}

public abstract native class AIbehaviorIDebuggerCommand extends ISerializable {}

public native class AIbehaviorIdleTreeNodeDefinition extends AIbehaviorLeafTreeNodeDefinition {}

public native class AIbehaviorIfElseNodeDefinition extends AIbehaviorCompositeTreeNodeDefinition {
  native let condition: ref<AIbehaviorExpressionSocket>;
}

public native class AIbehaviorIncludedTreeDefinition extends AIbehaviorNestedTreeDefinition {
  native let treeReference: ref<AIArgumentMapping>;
}

public native class AIbehaviorInfluenceExcludeObstaclePointTaskDefinition extends AIbehaviorTaskDefinition {
  native let workspotData: ref<AIArgumentMapping>;
  native let mountData: ref<AIArgumentMapping>;
}

public native struct AIbehaviorInstance {}

public native class AIbehaviorInstantConditionDefinition extends ISerializable {
  native let condition: ref<AIbehaviorConditionDefinition>;
}

public native class AIbehaviorInstantConditionNodeDefinition extends AIbehaviorConditionNodeDefinition {}

public native class AIbehaviorInstantJoinTrafficConditionDefinition extends AIbehaviorConditionDefinition {
  native let joinTrafficSettings: ref<AIArgumentMapping>;
  native let closestPointOnPath: ref<AIArgumentMapping>;
  native let pathDirection: ref<AIArgumentMapping>;
  native let runOnTraffic: ref<AIArgumentMapping>;
}

public native class AIbehaviorInstantMountConditionDefinition extends AIbehaviorConditionDefinition {
  native let mountData: ref<AIArgumentMapping>;
}

public native class AIbehaviorInstantRunAwayConditionDefinition extends AIbehaviorConditionDefinition {
  native let destination: ref<AIArgumentMapping>;
  native let runOnNavmesh: ref<AIArgumentMapping>;
}

public native class AIbehaviorInstantTaskNodeDefinition extends AIbehaviorTaskNodeDefinition {}

public native class AIbehaviorIsAutopilotActiveVehicleExpressionDefinition extends AIbehaviorVehicleExpressionDefinition {}

public native class AIbehaviorIsBeingSummonedDefinition extends AIbehaviorVehicleExpressionDefinition {}

public native class AIbehaviorIsBlockedByCompanionConditionDefinition extends AIbehaviorCompanionConditionDefinition {
  native let distance: ref<AIArgumentMapping>;
}

public native class AIbehaviorIsInDesiredRangeConditionDefinition extends AIbehaviorCompanionConditionDefinition {
  native let desiredDistance: ref<AIArgumentMapping>;
  native let deadZoneRadius: ref<AIArgumentMapping>;
}

public native class AIbehaviorIsNodeStreamedConditionDefinition extends AIbehaviorConditionDefinition {
  native let nodeRef: ref<AIArgumentMapping>;
}

public native class AIbehaviorIsStunnedVehicleDefinition extends AIbehaviorVehicleExpressionDefinition {}

public native class AIbehaviorIsThreatOnPathConditionDefinition extends AIbehaviorConditionDefinition {
  native let threatObject: ref<AIArgumentMapping>;
  native let threatRadius: ref<AIArgumentMapping>;
}

public native class AIbehaviorIsValueValidConditionDefinition extends AIbehaviorConditionDefinition {
  native let value: ref<AIArgumentMapping>;
}

public native class AIbehaviorJoinFollowerSquadWithTargetDefinition extends AIbehaviorTaskDefinition {
  native let follower: ref<AIArgumentMapping>;
}

public abstract native class AIbehaviorLeafTreeNodeDefinition extends AIbehaviorTreeNodeDefinition {}

public native class AIbehaviorLeaveCoverImmediatelyNodeDefinition extends AIbehaviorDecoratorNodeDefinition {}

public native class AIbehaviorLimiterNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let activationLimitPerFrame: Uint32;
  native let delayChildActivation: Bool;
  native let delayChildActivationIfAttaching: Bool;
}

public native class AIbehaviorLineOfSightClearConditionDefinition extends AIbehaviorConditionDefinition {
  native let collisionFilters: array<CName>;
  native let offset: Vector3;
  native let target: ref<AIArgumentMapping>;
}

public native class AIbehaviorMappingConditionDefinition extends AIbehaviorConditionDefinition {
  native let value: ref<AIArgumentMapping>;
}

public native class AIbehaviorMappingExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let mapping: ref<AIArgumentMapping>;
  native let update: Bool;
  native let updatePeriod: Float;
  native let behaviorCallbackNames: array<CName>;
}

enum AIbehaviorMaybeNodeAction {
  Succeed = 0,
  Fail = 1,
  RepeatChild = 2,
}

public native class AIbehaviorMaybeNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let onChildSuccess: AIbehaviorMaybeNodeAction;
  native let onChildFailure: AIbehaviorMaybeNodeAction;
}

public native class AIbehaviorMonitorConditionDefinition extends ISerializable {
  native let condition: ref<AIbehaviorConditionDefinition>;
  native let timeout: Float;
}

public native class AIbehaviorMonitorConditionNodeDefinition extends AIbehaviorConditionNodeDefinition {
  native let timeout: Float;
}

public native class AIbehaviorMonitorTaskNodeDefinition extends AIbehaviorTaskNodeDefinition {
  native let timeout: Float;
}

public native class AIbehaviorMountEventResolverDefinition extends AIbehaviorEventResolverDefinition {
  native let mountData: ref<AIArgumentMapping>;
  native let workspotData: ref<AIArgumentMapping>;
  native let isInstant: ref<AIArgumentMapping>;
  native let behaviorCallbackName: CName;
}

public native class AIbehaviorMountRequestConditionDefinition extends AIbehaviorConditionDefinition {
  native let testMountRequest: Bool;
  native let testUnmountRequest: Bool;
  native let acceptInstant: Bool;
  native let acceptNotInstant: Bool;
}

public native class AIbehaviorMountToEntTaskDefinition extends AIbehaviorTaskDefinition {
  native let mountData: ref<AIArgumentMapping>;
}

public native class AIbehaviorMoveAlongTrafficPathActionNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let joinTrafficSettings: ref<AIArgumentMapping>;
  native let ignoreTrafficSpots: ref<AIArgumentMapping>;
  native let useCrowdAnimationGraph: ref<AIArgumentMapping>;
  native let workspotData: ref<AIArgumentMapping>;
  native let workspotExitPositionWS: ref<AIArgumentMapping>;
  native let workspotReturnPositionVector: ref<AIArgumentMapping>;
  native let workspotExitTangent: ref<AIArgumentMapping>;
  native let trafficLaneReturnTangent: ref<AIArgumentMapping>;
  native let trafficLaneExitTangent: ref<AIArgumentMapping>;
}

public native class AIbehaviorMovementPolicyTaskDefinition extends AIbehaviorTaskDefinition {
  native let useCurrentPolicy: Bool;
  native let waitForPolicy: Bool;
  native let stopWhenDestinationReached: ref<AIArgumentMapping>;
  native let policies: array<ref<AIbehaviorMovementPolicyTaskItemDefinition>>;
}

enum AIbehaviorMovementPolicyTaskFunctions {
  SetMovementType = 0,
  SetTargetObject = 1,
  UseFollowSlots = 2,
  SetLocalTargetOffset = 3,
  SetIgnoreNavigation = 4,
  SetStrafingTarget = 5,
}

public native class AIbehaviorMovementPolicyTaskItemDefinition extends ISerializable {
  native let function: AIbehaviorMovementPolicyTaskFunctions;
}

enum AIbehaviorNaryExpressionOperators {
  LogicalAnd = 0,
  LogicalOr = 1,
}

public native class AIbehaviorNaryOperatorExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let operator: AIbehaviorNaryExpressionOperators;
  native let operands: array<ref<AIbehaviorExpressionSocket>>;
}

public abstract native class AIbehaviorNestedTreeDefinition extends AIbehaviorTreeNodeDefinition {
  native let lateInitialization: Bool;
  native let initializeOnEvent: array<CName>;
}

public abstract native class AIbehaviorNodeRefConverterTaskDefinition extends AIbehaviorTaskDefinition {
  native let nodeRef: ref<AIArgumentMapping>;
  native let result: ref<AIArgumentMapping>;
}

public native class AIbehaviorNodeRefToInstanceTaskDefinition extends AIbehaviorNodeRefConverterTaskDefinition {}

public native class AIbehaviorNodeRefToObjectTaskDefinition extends AIbehaviorNodeRefConverterTaskDefinition {}

public native class AIbehaviorNodeStatusDebuggerCommand extends AIbehaviorIDebuggerCommand {
  native let behaviorResourceHash: Uint32;
  native let generation: Uint32;
  native let entries: array<AIbehaviorNodeStatusDebuggerCommandEntry>;
}

public native struct AIbehaviorNodeStatusDebuggerCommandEntry {
  native let status: AIbehaviorDebugNodeStatus;
  native let generation: Uint32;
  native let failure: ref<gamedebugFailure>;
}

public native class AIbehaviorOrConditionDefinition extends AIbehaviorCompositeConditionDefinition {}

enum AIbehaviorParallelNodeChildState {
  Inactive = 0,
  Active = 1,
  Completed = 2,
}

public native class AIbehaviorParallelNodeDefinition extends AIbehaviorCompositeTreeNodeDefinition {
  native let waitFor: AIbehaviorParallelNodeWaitFor;
}

enum AIbehaviorParallelNodeWaitFor {
  LeftChild = 0,
  RightChild = 1,
  AllChildren = 2,
  BothChildren = 2,
  AnyChild = 3,
}

public native class AIbehaviorParameterizedBehavior extends ISerializable {
  native let treeDefinition: ResourceRef; // rRef<AIbehaviorResource>
  native let argumentsOverrides: array<AIArgumentOverrideWrapper>;
}

public abstract native class AIbehaviorPassiveConditionDefinition extends ISerializable {
  native let invert: Bool;
}

public native class AIbehaviorPassiveConditionNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let condition: ref<AIbehaviorPassiveConditionDefinition>;
  native let resultIfFailed: AIbehaviorCompletionStatus;
}

public native class AIbehaviorPassiveEventTagConditionDefinition extends AIbehaviorPassiveConditionDefinition {
  native let tag: CName;
  native let deactivateEvents: Bool;
}

public native class AIbehaviorPassiveSignalConditionDefinition extends AIbehaviorPassiveConditionDefinition {
  native let tag: CName;
  native let deactivateSignal: Bool;
}

public native class AIbehaviorPatrolActionNodeDefinition extends AIbehaviorActionTreeNodeDefinition {
  native let path: ref<AIArgumentMapping>;
  native let patrolProgress: ref<AIArgumentMapping>;
  native let startFromClosestPoint: ref<AIArgumentMapping>;
  native let patrolContinuationPolicy: ref<AIArgumentMapping>;
  native let playStartAnimation: ref<AIArgumentMapping>;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
  native let workspotData: ref<AIArgumentMapping>;
  native let dependentWorkspotData: ref<AIArgumentMapping>;
  native let lookAtTarget: ref<AIArgumentMapping>;
  native let usePathContext: ref<AIArgumentMapping>;
  native let useOffMeshLinkReservation: ref<AIArgumentMapping>;
}

public native class AIbehaviorPickSearchDestinationTaskDefinition extends AIbehaviorTaskDefinition {
  native let destinationPosition: ref<AIArgumentMapping>;
  native let desiredDistance: ref<AIArgumentMapping>;
  native let maxDistance: ref<AIArgumentMapping>;
  native let clearedAreaRadius: ref<AIArgumentMapping>;
  native let clearedAreaDistance: ref<AIArgumentMapping>;
  native let clearedAreaAngle: ref<AIArgumentMapping>;
  native let ignoreRestrictMovementArea: ref<AIArgumentMapping>;
}

public native class AIbehaviorPredictTargetMovementDefinition extends AIbehaviorTaskDefinition {
  native let target: ref<AIArgumentMapping>;
  native let timeInterval: ref<AIArgumentMapping>;
  native let result: ref<AIArgumentMapping>;
}

public native class AIbehaviorPrepareReservedCrowdWorkspotNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let workspotData: ref<AIArgumentMapping>;
  native let returnPosition: ref<AIArgumentMapping>;
  native let returnPositionVector: ref<AIArgumentMapping>;
  native let workspotExitTangent: ref<AIArgumentMapping>;
  native let joinTrafficSettings: ref<AIArgumentMapping>;
  native let overrideExit: ref<AIArgumentMapping>;
}

public native class AIbehaviorPuppetRefToGameObjectTaskDefinition extends AIbehaviorTaskDefinition {
  native let puppetRef: ref<AIArgumentMapping>;
  native let result: ref<AIArgumentMapping>;
}

public native class AIbehaviorRandomConditionDefinition extends AIbehaviorConditionDefinition {
  native let chance: Float;
}

public native class AIbehaviorRecalculateVehicleWorkspotPositionTaskDefinition extends AIbehaviorTaskDefinition {
  native let mountData: ref<AIArgumentMapping>;
  native let workspotData: ref<AIArgumentMapping>;
}

public native class AIbehaviorReevaluateOnEventNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let eventName: CName;
}

public native class AIbehaviorRepeatNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let limit: ref<AIArgumentMapping>;
  native let repeatChildOnFailure: Bool;
}

public native class AIbehaviorResource extends CResource {
  native let root: ref<AIbehaviorTreeNodeDefinition>;
  native let arguments: AITreeArgumentsDefinition;
  native let delegate: ref<BehaviorDelegate>;
  native let initializationEvents: array<CName>;
}

public native class AIbehaviorRestoreSavedPatrolProgressTaskDefinition extends AIbehaviorTaskDefinition {
  native let path: ref<AIArgumentMapping>;
  native let savedState: ref<AIArgumentMapping>;
  native let patrolProgress: ref<AIArgumentMapping>;
  native let destinationPosition: ref<AIArgumentMapping>;
  native let destinationTangent: ref<AIArgumentMapping>;
}

public native class AIbehaviorSaveEventResolverDefinition extends AIbehaviorEventResolverDefinition {
  native let eventData: ref<AIArgumentMapping>;
}

public native class AIbehaviorSavePatrolProgressTaskDefinition extends AIbehaviorTaskDefinition {
  native let patrolProgress: ref<AIArgumentMapping>;
  native let saveOnDeactivation: Bool;
  native let savedState: ref<AIArgumentMapping>;
}

public native class AIbehaviorScriptConditionDefinition extends AIbehaviorConditionDefinition {
  native let script: ref<AIbehaviorconditionScript>;
  native let disableLazyInitialization: Bool;
}

public native class AIbehaviorScriptEventResolverDefinition extends AIbehaviorEventResolverDefinition {
  native let script: ref<AIScriptEventResolver>;
}

public native class AIbehaviorScriptPassiveExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let script: ref<AIbehaviorexpressionScript>;
}

public native class AIbehaviorScriptTaskDefinition extends AIbehaviorTaskDefinition {
  native let script: ref<AIbehaviortaskScript>;
  native let disableLazyInitialization: Bool;
}

public native class AIbehaviorSelectCombatTargetTaskDefinition extends AIbehaviorTaskDefinition {
  native let target: ref<AIArgumentMapping>;
  native let targetClosest: Bool;
}

public native class AIbehaviorSelectCoverTaskDefinition extends AIbehaviorTaskDefinition {
  native let cover: ref<AIArgumentMapping>;
  native let coverID: ref<AIArgumentMapping>;
  native let multiCoverID: ref<AIArgumentMapping>;
  native let combatTarget: ref<AIArgumentMapping>;
  native let friendlyTarget: ref<AIArgumentMapping>;
  native let combatZone: ref<AIArgumentMapping>;
  native let sectorSelection: CName;
  native let ignoreRestrictMovementArea: ref<AIArgumentMapping>;
  native let selectionPreset: ref<AIArgumentMapping>;
  native let onActivationSelectionPreset: ref<AIArgumentMapping>;
  native let secondStagePreset: ref<AIArgumentMapping>;
  native let coverChangeThreshold: ref<AIArgumentMapping>;
  native let coverGatheringCenterObject: ref<AIArgumentMapping>;
  native let coverDisablingDuration: ref<AIArgumentMapping>;
}

public native struct AIbehaviorSelectionStagePtrWrapper {}

public native class AIbehaviorSelectorTreeNodeDefinition extends AIbehaviorCompositeTreeNodeDefinition {}

public native class AIbehaviorSelectWorkspotEntryTaskDefinition extends AIbehaviorTaskDefinition {
  native let workspotData: ref<AIArgumentMapping>;
  native let destinationPosition: ref<AIArgumentMapping>;
  native let tangentPoint: ref<AIArgumentMapping>;
  native let entranceFromStand: ref<AIArgumentMapping>;
}

public native class AIbehaviorSelectWorkspotNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let spotInstance: ref<AIArgumentMapping>;
  native let workspotData: ref<AIArgumentMapping>;
  native let dependentWorkspotData: ref<AIArgumentMapping>;
  native let repeatChild: Bool;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
}

public native class AIbehaviorSendActionEventTaskDefinition extends AIbehaviorTaskDefinition {
  native let event: ref<ActionEvent>;
}

public native class AIbehaviorSendSignalTaskDefinition extends AIbehaviorTaskDefinition {
  native let signalName: CName;
  native let startAction: gameBoolSignalAction;
  native let startActionUserData: ref<SignalUserDataDefinition>;
  native let endAction: gameBoolSignalAction;
  native let endActionUserData: ref<SignalUserDataDefinition>;
}

public native class AIbehaviorSequenceTreeNodeDefinition extends AIbehaviorCompositeTreeNodeDefinition {}

public native class AIbehaviorShouldEnterCrowdConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorShouldFollowSlotDefinition extends AIbehaviorVehicleExpressionDefinition {}

public native class AIbehaviorShouldJoinTrafficDefinition extends AIbehaviorVehicleExpressionDefinition {}

public native class AIbehaviorSignalConditionDefinition extends AIbehaviorConditionDefinition {
  native let signalName: CName;
  native let mode: AIbehaviorSignalConditionModes;
  native let tagSignal: Bool;
}

enum AIbehaviorSignalConditionModes {
  CurrentValue = 0,
  StartOfFrameValue = 1,
  RisingEdge = 2,
  FallingEdge = 3,
  AnyEdge = 4,
}

public native class AIbehaviorSimpleParameterizedBehavior extends AIbehaviorParameterizedBehavior {}

public native class AIbehaviorSlotOccupiedConditionDefinition extends AIbehaviorConditionDefinition {
  native let slot: ref<AIArgumentMapping>;
}

public native class AIbehaviorStackScriptTaskDefinition extends AIbehaviorTaskDefinition {
  native let script: ref<AIbehaviortaskStackScript>;
}

enum AIbehaviorStateCompletionStatus {
  ForwardBehaviorStatus = 0,
  Failure = 1,
  Success = 2,
}

public native class AIbehaviorStoryActionConditionDefinition extends AIbehaviorConditionDefinition {
  native let action: AIbehaviorStoryActionType;
}

enum AIbehaviorStoryActionType {
  Setup = 0,
  Stop = 1,
}

public native class AIbehaviorStoryEventResolverDefinition extends AIbehaviorEventResolverDefinition {
  native let storyTier: ref<AIArgumentMapping>;
}

public native class AIbehaviorStoryTierConditionDefinition extends AIbehaviorConditionDefinition {
  native let tier: gameStoryTier;
  native let storyTier: ref<AIArgumentMapping>;
}

public native class AIbehaviorSubtreeDefinition extends AIbehaviorNestedTreeDefinition {
  native let tree: ref<AIbehaviorParameterizedBehavior>;
}

public native class AIbehaviorSucceederNodeDefinition extends AIbehaviorLeafTreeNodeDefinition {}

public native class AIbehaviorSystemVariableExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {
  native let variable: AIbehaviorSystemVariableExpressionTypes;
}

enum AIbehaviorSystemVariableExpressionTypes {
  IsFPSLow = 0,
}

public abstract native class AIbehaviorTaskDefinition extends ISerializable {
  native let ignoreTaskCompletion: Bool;
}

public abstract native class AIbehaviorTaskNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let task: ref<AIbehaviorTaskDefinition>;
}

public native class AIbehaviorTimeoutNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let time: ref<AIArgumentMapping>;
}

public native class AIbehaviorTrackPatrolProgressNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let pathParameters: ref<AIArgumentMapping>;
  native let patrolProgress: ref<AIArgumentMapping>;
  native let startFromClosestPoint: ref<AIArgumentMapping>;
  native let patrolContinuationPolicy: ref<AIArgumentMapping>;
  native let teleportPositionAfterTimeSkipping: ref<AIArgumentMapping>;
  native let teleportRotationAfterTimeSkipping: ref<AIArgumentMapping>;
  native let handleTeleportRequest: ref<AIArgumentMapping>;
  native let fastForwardAfterTeleport: ref<AIArgumentMapping>;
}

public native class AIbehaviorTreeNodeDebugInfo extends AIbehaviorDebugInfoBase {}

public abstract native class AIbehaviorTreeNodeDefinition extends AIbehaviorBehaviorComponentDefinition {}

public native class AIbehaviorTrueConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorTryGetChasePointTaskDefinition extends AIbehaviorTaskDefinition {
  native let inPlayerPositionDelay: ref<AIArgumentMapping>;
  native let inPlayerPositionMaxDistance: ref<AIArgumentMapping>;
  native let inNearestNavmeshPolyExtent: ref<AIArgumentMapping>;
  native let outChasePosition: ref<AIArgumentMapping>;
}

public native struct AIbehaviortweakAmmoCountConditionData {}

public native class AIbehaviortweakAttachmentSlotsListener extends AttachmentSlotsListener {}

public native struct AIbehaviortweakCompiledActionConditionData {}

public native class AIbehaviorTweakConditionDefinition extends AIbehaviorConditionDefinition {
  native let recordId: TweakDBID;
}

public native class AIbehaviortweakConditionStatusEffectListener extends IStatusEffectListener {}

public native struct AIbehaviortweakDetectionListenerWrapper {}

public native struct AIbehaviortweakInstanceRef {}

public native class AIbehaviortweakItemsInInventoryListener extends InventoryListener {}

public native struct AIbehaviortweakNPCCallbacks {}

public native struct AIbehaviortweakPlayerCallbacks {}

public native struct AIbehaviortweakStateCallback {}

public native struct AIbehaviortweakStateConditionData {}

public native struct AIbehaviortweakTargetHelper {}

public native struct AIbehaviortweakTargetLocation {
  native let object: wref<GameObject>;
  native let position: Vector3;
  native let speed: Vector3;
  native let coverId: AIObjectId;
  native let hasPosition: Bool;
  native let hasSpeed: Bool;
}

public native struct AIbehaviortweakTargetStates {}

public native struct AIbehaviorTypeRef {
  native let isSet: Bool;
  native let customType: CName;
  native let enumeratedType: AIArgumentType;
}

public abstract native class AIbehaviorUnaryConditionDefinition extends AIbehaviorConditionDefinition {
  native let child: ref<AIbehaviorConditionDefinition>;
}

public native class AIbehaviorUnmountImmediatelyNodeDefinition extends AIbehaviorDecoratorNodeDefinition {
  native let mountData: ref<AIArgumentMapping>;
}

public native class AIbehaviorVehicleExpressionDefinition extends AIbehaviorPassiveExpressionDefinition {}

public native class AIbehaviorWaitConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitFormationPositionConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitingKeepMountedCommandConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitingMountCommandConditionDefinition extends AIbehaviorConditionDefinition {
  native let requestArgument: ref<AIArgumentMapping>;
  native let callbackName: CName;
}

public native class AIbehaviorWaitingNotMountedCommandConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitJoinTrafficConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitRefPositionConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitSlotConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitSplineBackwardToFollowConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitSplineToFollowConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitStunnedConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitSummonConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitTargetToFollowConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitTargetToReachConditionDefinition extends AIbehaviorConditionDefinition {}

public native class AIbehaviorWaitWorldPositionConditionDefinition extends AIbehaviorConditionDefinition {}

public native struct AIbehaviorWorkspotListenerWrapper {}

public native class AIBehaviourSpot extends AISmartSpot {
  native let behaviour: ref<AIResourceReference>;
}

public native class AIBoolArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: Bool;
}

public native class AICArchetypeManager extends AIIArchetypeManager {}

public native class AICNameArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: CName;
}

public native struct AICombatGuardAreaConnectedCommunity {
  native let communityArea: EntityReference;
  native let conditions: array<ref<ICombatRestrictMovementAreaCondition>>;
}

enum AICommandContextsType {
  Default = 0,
  Immediate = 1,
  Movement = 2,
  Workspot = 3,
  Aiming = 4,
}

public native class AICommandQueuePS extends GameComponentPS {
  native persistent let behaviorArgumentList: array<ref<AIArgumentInstancePS>>;
  native persistent let aiRole: ref<AIRole>;
}

public native struct AICoverScoringData {}

public abstract native struct AICoverSelectionParameters {}

public abstract native struct AICoverSelectionRuntimeData {}

public abstract native class AICTreeExtendableNodeDefinition extends AICTreeNodeDefinition {
  native let optionalChild: ref<LibTreeINodeDefinition>;
}

public native struct AICTreeInstance {}

public native class AICTreeLazyNodeDefinition extends AICTreeNodeDefinition {
  native let tree: ref<LibTreeCTreeResource>;
}

public native class AICTreeNodeActionAnimationCurvePathDefinition extends AICTreeNodeActionDefinition {
  native let nodeReference: LibTreeDefNodeRef;
  native let controllersSetupName: LibTreeDefCName;
  native let useStart: LibTreeDefBool;
  native let useStop: LibTreeDefBool;
  native let blendTime: LibTreeDefFloat;
  native let globalInBlendTime: LibTreeDefFloat;
  native let globalOutBlendTime: LibTreeDefFloat;
  native let turnCharacterToMatchVelocity: LibTreeDefBool;
  native let customStartAnimationName: LibTreeDefCName;
  native let customMainAnimationName: LibTreeDefCName;
  native let customStopAnimationName: LibTreeDefCName;
  native let startSnapToTerrain: LibTreeDefBool;
  native let mainSnapToTerrain: LibTreeDefBool;
  native let stopSnapToTerrain: LibTreeDefBool;
  native let startSnapToTerrainBlendTime: LibTreeDefFloat;
  native let stopSnapToTerrainBlendTime: LibTreeDefFloat;
}

public native class AICTreeNodeActionAnimationCurvePathDynamicDefinition extends AICTreeNodeActionDefinition {
  native let targetSplineVarName: CName;
  native let controlerVarName: CName;
  native let startAnimVarName: CName;
  native let stopAnimVarName: CName;
  native let blendTime: Float;
  native let globalInBlendTime: Float;
  native let globalOutBlendTime: Float;
  native let turnCharacterToMatchVelocity: Bool;
  native let startSnapToTerrain: Bool;
  native let mainSnapToTerrain: Bool;
  native let stopSnapToTerrain: Bool;
  native let startSnapToTerrainBlendTime: Float;
  native let stopSnapToTerrainBlendTime: Float;
}

public abstract native class AICTreeNodeActionDefinition extends AICTreeExtendableNodeDefinition {}

public native class AICTreeNodeActionDieDefinition extends AICTreeNodeActionDefinition {}

public native class AICTreeNodeActionDynamicMoveToDefinition extends AICTreeNodeActionDefinition {
  native let moveType: moveMovementType;
  native let tolerance: Float;
  native let target: CName;
  native let keepDistance: Bool;
}

public native class AICTreeNodeActionReloadWeaponDefinition extends AICTreeNodeActionDefinition {}

public native class AICTreeNodeActionTeleportToNodeDefinition extends AICTreeNodeActionDefinition {
  native let nodeRef: LibTreeDefNodeRef;
  native let offset: LibTreeDefVector;
  native let doNavTest: Bool;
}

public native class AICTreeNodeActionTeleportToPositionDefinition extends AICTreeNodeActionDefinition {
  native let positionName: CName;
  native let doNavTest: Bool;
}

public abstract native class AICTreeNodeAtomicDefinition extends AICTreeNodeDefinition {}

public native class AICTreeNodeBoolSharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeBrainDefinition extends AICTreeNodeCompositeDefinition {
  native let children: array<ref<LibTreeINodeDefinition>>;
  native let useScoring: Bool;
}

public native class AICTreeNodeChildrenListDefinition extends AICTreeNodeCompositeDefinition {
  native let children: array<ref<LibTreeINodeDefinition>>;
}

public native class AICTreeNodeCompleteImmediatelyDefinition extends AICTreeNodeAtomicDefinition {
  native let completeWithSuccess: Bool;
}

public abstract native class AICTreeNodeCompositeDefinition extends AICTreeNodeDefinition {}

public native class AICTreeNodeConditionDefinition extends AICTreeNodeCompositeDefinition {
  native let expressions: array<ref<LibTreeINodeDefinition>>;
  native let trueBranch: ref<LibTreeINodeDefinition>;
  native let falseBranch: ref<LibTreeINodeDefinition>;
  native let reevaluateOnExecution: Bool;
}

public native class AICTreeNodeDebugLogDefinition extends AICTreeExtendableNodeDefinition {
  native let text: String;
  native let timeOnScreen: Float;
  native let useVisualDebug: Bool;
}

public native class AICTreeNodeDecisionDefinition extends AICTreeNodeCompositeDefinition {
  native let child: ref<LibTreeINodeDefinition>;
  native let expressions: array<ref<LibTreeINodeDefinition>>;
  native let interruption: AIInterruptionSignal;
}

public abstract native class AICTreeNodeDecoratorDefinition extends AICTreeNodeDefinition {
  native let child: ref<LibTreeINodeDefinition>;
}

public abstract native class AICTreeNodeDefinition extends LibTreeINodeDefinition {}

public native class AICTreeNodeDoNothingDefinition extends AICTreeNodeAtomicDefinition {}

public native class AICTreeNodeDynamicBindDefinition extends AICTreeNodeDynamicDefinition {}

public abstract native class AICTreeNodeDynamicDefinition extends AICTreeNodeDefinition {}

public native class AICTreeNodeFloatSharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeForcedBehaviourDefinition extends AICTreeNodeDynamicDefinition {}

public native class AICTreeNodeFSMDefinition extends AICTreeNodeCompositeDefinition {
  native let defaultState: Uint16;
  native let transitions: array<AIFSMTransitionDefinition>;
  native let onEventTransitions: array<AIFSMEventTransitionsListDefinition>;
  native let states: array<AIFSMStateDefinition>;
  native let sharedVars: AISharedVarTableDefinition;
}

public native class AICTreeNodeIncludedTreeDefinition extends AICTreeNodeDefinition {
  native let tree: LibTreeDefTree;
}

public native class AICTreeNodeInt32SharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeNameSharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeParallelDefinition extends AICTreeNodeChildrenListDefinition {
  native let forwardChildrenCompleteness: Bool;
}

public native class AICTreeNodePlayerControlledDefinition extends AICTreeNodeAtomicDefinition {}

public native class AICTreeNodePositionSharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeReadWorkspotParamsDefinition extends AICTreeNodeDecoratorDefinition {
  native let workspotNodeVarName: CName;
  native let prevWorkspotNodeVarName: CName;
  native let splineNodeVarName: CName;
  native let workspotEntryAnimVar: CName;
  native let animControllerVarName: CName;
  native let splineStartAnimVarName: CName;
  native let splineStopAnimVarName: CName;
  native let moveTargetVarName: CName;
}

public native class AICTreeNodeScriptDecoratorDefinition extends AICTreeExtendableNodeDefinition {
  native let script: ref<ActionScript>;
  native let scriptName: CName;
}

public native class AICTreeNodeSequenceDefinition extends AICTreeNodeChildrenListDefinition {}

public native class AICTreeNodeSetSplineMovementTargetDefinition extends AICTreeNodeDecoratorDefinition {
  native let splineNode: LibTreeSharedVarReferenceName;
  native let movementTarget: LibTreeSharedVarRegistrationName;
}

public abstract native class AICTreeNodeSharedVarsBaseDecoratorDefinition extends AICTreeNodeDecoratorDefinition {}

public native class AICTreeNodeSharedVarsDecoratorDefinition extends AICTreeNodeSharedVarsBaseDecoratorDefinition {
  native let sharedVars: AISharedVarTableDefinition;
}

public native class AICTreeNodeSimpleSelectorDefinition extends AICTreeNodeChildrenListDefinition {}

public abstract native class AICTreeNodeSingleSharedVarDecoratorDefinition extends AICTreeNodeSharedVarsBaseDecoratorDefinition {
  native let sharedVarName: LibTreeSharedVarRegistrationName;
}

public native class AICTreeNodeTargetNodeSharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeTargetSharedVarDecoratorDefinition extends AICTreeNodeSingleSharedVarDecoratorDefinition {}

public native class AICTreeNodeTimeoutDefinition extends AICTreeExtendableNodeDefinition {
  native let timeout: Float;
}

public native struct AIDebugLogScope {
  native let index: Uint32;
  native let id: Uint32;
}

public native class AIDefAI extends AIResourceReference {}

public native class AIDefTreeVariableComparison extends LibTreeDefTreeVariableBoolBase {
  native let exportAsProperty: Bool;
  native let referenceVariableId: Uint16;
  native let referenceVariableName: CName;
  native let referenceVariableShortName: CName;
  native let referenceType: CName;
  native let operator: EComparisonType;
  native let referenceValue: Variant;
}

public native class AIDirectorSystemSquadAudioMember extends AISquadAudioMemberBase {}

enum AIEExecutionStatus {
  STATUS_INVALID = 0,
  STATUS_SUCCESS = 1,
  STATUS_FAILURE = 2,
  STATUS_RUNNING = 3,
  STATUS_ABORTED = 4,
}

enum AIEInterruptionImportance {
  Undefined = 0,
  Casual = 1,
  Rush = 2,
  Immediate = 3,
  ForcedImmediate = 4,
}

public native class AIEnemy extends ISerializable {}

public importonly native class AIEntityReuseEvent extends AIEvent {
  native let destination: GlobalNodeID;
}

enum AIESharedVarDefinitionType {
  SVInt = 0,
  SVFloat = 1,
  SVBool = 2,
  SVName = 3,
  SVTarget = 4,
  SVPosition = 5,
  SVNodeInstance = 6,
  SVGlobalNodeRef = 7,
}

enum AIFiniteRoleType {
  Patrol = 0,
}

public native class AIFloatArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: Float;
}

enum AIForcedBehaviourPriority {
  AboveIdle = 0,
  AboveCombat = 1,
  AboveCriticalState = 2,
  AboveDeath = 3,
}

public native struct AIFSMEventTransitionsListDefinition {
  native let eventName: CName;
  native let transitions: AIFSMTransitionListDefinition;
}

public native struct AIFSMStateDefinition {
  native let onUpdateTransition: AIFSMTransitionListDefinition;
  native let onCompleteTransition: AIFSMTransitionListDefinition;
  native let onSuccessTransition: AIFSMTransitionListDefinition;
  native let onFailureTransition: AIFSMTransitionListDefinition;
  native let onInterruptionTransition: AIFSMTransitionListDefinition;
  native let onEventTransitions: AIFSMTransitionListDefinition;
  native let childNode: ref<AICTreeNodeDefinition>;
}

public native struct AIFSMTransitionDefinition {
  native let destination: Uint16;
  native let condition: Uint16;
}

public native struct AIFSMTransitionListDefinition {
  native let firstTransitionIndex: Uint16;
  native let transitionsCount: Uint16;
}

public native class AIGameToneDetectorSquadAudioMember extends AISquadAudioMemberBase {}

public native struct AIGuardArea {}

public native struct AIGuardAreaConnectedCommunity {
  native let communityArea: EntityReference;
  native let isPrimary: Bool;
}

public native struct AIGuardAreaSavedData {
  native let puppetId: EntityID;
  native let nodeRef: NodeRef;
}

public native class AIGuardAreasSavedState extends ISerializable {
  native let data: array<AIGuardAreaSavedData>;
  native let cleared: array<EntityID>;
}

public native class AIHumanComponentPS extends AICommandQueuePS {
  native persistent let spotUsageToken: AISpotUsageToken;
}

public abstract native class AIIArchetypeManager extends IGameSystem {}

public abstract native class AIICoverSelectionSystem extends IGameSystem {}

public abstract native class AIIEntityStubHandlerProviderSystem extends IGameSystem {}

public abstract native class AIIInformationSpreadSystem extends IGameSystem {}

public native class AIInt32ArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: Int32;
}

public native class AIInt64ArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: Int64;
}

public native class AIInterruptionHandlerAllowDefinition extends AIInterruptionHandlerDefinition {}

public native class AIInterruptionHandlerBehaviorDefinition extends AIInterruptionHandlerDefinition {
  native let ai: ref<LibTreeINodeDefinition>;
  native let parallelActivation: Bool;
  native let parallelExecution: Bool;
  native let blockInterruption: Bool;
}

public abstract native class AIInterruptionHandlerDefinition extends LibTreeINodeDefinition {
  native let signal: AIInterruptionSignal;
  native let supportLessImportantSignals: Bool;
}

public native class AIInterruptionHandlerDenyDefinition extends AIInterruptionHandlerDefinition {}

public native struct AIInterruptionSignal {
  native let importance: AIEInterruptionImportance;
  native let signal: CName;
}

public abstract native struct AIIObjectSelectionDebugProxy {}

public native class AIISerializableArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: ref<ISerializable>;
}

public abstract native class AIISquadManager extends IGameSystem {}

public abstract native class AIISystem extends IGameSystem {}

public abstract native struct AIITarget {}

public abstract native class AIITrafficMovementSystem extends IGameSystem {}

public abstract native class AIIVehicleCoversSystem extends IGameSystem {}

enum AIIWorkspotManagerSpotUsageState {
  Reserved = 0,
  Occupied = 1,
  None = 2,
}

public native class AIMixingOutputSystemSquadAudioMember extends AISquadAudioMemberBase {}

public native class AIMusicSystemSquadAudioMember extends AISquadAudioMemberBase {}

public native struct AIObjectId {
  native let value: Uint64;
}

public abstract native class AIObjectSelectionManagerInterface extends IGameSystem {}

public native class AIParametrizedResourceReference extends AIResourceReference {
  native let overrides: LibTreeParametersForwarder;
}

public native class AIPlayMountedSlotWorkspotCommand extends AICommand {
  native persistent let mountData: gameMountDescriptor;
}

public native struct AIPosition {
  native let position: Vector3;
}

public native class AIPuppetBlackboardListener extends ISerializable {}

public native class AIResource extends LibTreeCTreeResource {
  native let root: ref<AICTreeNodeDefinition>;
}

public native class AIResourceReference extends LibTreeCTreeReference {}

public native class AIRunAwayFromPlayerCommand extends AICommand {}

public native class AIScriptEventResolver extends IScriptable {}

public native class AIScriptsTargetTrackingListenerWrapper extends AIITargetTrackingListener {}

public native struct AISharedVarDefinition {
  native let type: AIESharedVarDefinitionType;
  native let name: LibTreeSharedVarRegistrationName;
}

public native struct AISharedVarTableDefinition {
  native let table: array<AISharedVarDefinition>;
}

public abstract native class AISmartSpot extends AISpot {}

enum AISocketsForRig {
  Undefined = 0,
  ManAverage = 1,
  ManBig = 2,
  ManFat = 3,
  WomanAverage = 4,
  WomanBig = 5,
  ChildMale = 6,
}

public abstract native class AISpot extends ISerializable {}

public abstract native struct AISpotInstance {}

public native struct AISpotPersistentData {
  native let worldPosition: WorldPosition;
  native let globalNodeId: GlobalNodeID;
  native let yaw: Float;
  native let isEnabled: Bool;
}

public native struct AISpotUsageToken {
  native persistent let usedSpotId: GlobalNodeID;
  native persistent let spotUserId: EntityID;
}

public native class AISquadAudioMemberBase extends AISquadMemberBase {}

public abstract native class AISquadMemberBase extends ISerializable {}

public native class AISquadNPCMember extends AISquadMemberBase {}

public native class AISystemImpl extends AIISystem {}

public native class AITargetTrackerComponentPS extends GameComponentPS {
  native persistent let threatsSaveData: array<AIThreatSaveData>;
}

public abstract native class AITargetTrackerManagerInterface extends IGameSystem {}

public native class AIThreatBeliefPositionProvider extends ThreatPositionProvider {}

public native class AIThreatLastKnownPositionProvider extends ThreatPositionProvider {}

public native struct AIThreatSaveData {
  native persistent let entityId: EntityID;
  native persistent let persistenceSourceBitMask: Uint32;
}

public native class AIThreatSharedBeliefPositionProvider extends ThreatPositionProvider {}

public native class AIThreatSharedLastKnownPositionProvider extends ThreatPositionProvider {}

public native class AITrafficExternalWorkspotDefinition extends worldTrafficSpotDefinition {
  native let nearestPointEntry: Bool;
  native let globalWorkspotNodeRef: NodeRef;
}

public native class AITrafficMovementSystem extends AIITrafficMovementSystem {}

public native class AITrafficWorkspotCompiled extends worldTrafficSpotCompiled {}

public native class AITrafficWorkspotDefinition extends worldTrafficSpotDefinition {
  native let workspotResource: ResourceRef; // rRef<workWorkspotResource>
}

public native struct AITreeArgumentsDefinition {
  native let args: array<ref<AIArgumentDefinition>>;
}

public native class AITreeNodeDeathDefinition extends AICTreeNodeActionDefinition {}

public native class AITreeNodeInterruptionDecoratorDefinition extends AICTreeNodeDecoratorDefinition {
  native let interruptions: array<ref<AIInterruptionHandlerDefinition>>;
}

public native class AITreeNodeRepeatDefinition extends AICTreeNodeDecoratorDefinition {
  native let limit: LibTreeDefInt32;
}

public native class AIUint64ArgumentInstancePS extends AIArgumentInstancePS {
  native persistent let value: Uint64;
}

public native class AIVehicleCoversComponent extends IComponent {}

public native class AIVehicleCoversSystem extends AIIVehicleCoversSystem {}

public native class AmbientOverrideAreaSettings extends IAreaSettings {
  native let color: [CurveDataHDRColor; 6];
}

public native struct animActionAnimDatabase_AnimationData {
  native let animationName: CName;
  native let fallbackAnimationName: CName;
  native let inTransitionDuration: Float;
  native let inCanRequestInertialization: Bool;
  native let outTransitionDuration: Float;
  native let outCanRequestInertialization: Bool;
  native let streamingContext: CName;
}

public native struct animActionAnimDatabase_DatabaseRow {
  native let animFeatureName: CName;
  native let state: Int32;
  native let animVariation: Int32;
  native let animationData: animActionAnimDatabase_AnimationData;
}

public native class animActionAnimDatabase extends CResource {
  native let rows: array<animActionAnimDatabase_DatabaseRow>;
}

public native struct animAdditionalFloatTrackContainer {
  native let entries: array<animAdditionalFloatTrackEntry>;
  native let overwriteExistingValues: Bool;
}

public native class animAdditionalFloatTrackEntry extends ISerializable {
  native let name: CName;
  native let trackInfo: animFloatTrackInfo;
  native let values: CurveDataFloat;
}

public native struct animAdditionalTransformContainer {
  native let entries: array<ref<animAdditionalTransformEntry>>;
}

public native class animAdditionalTransformEntry extends ISerializable {
  native let transformInfo: animTransformInfo;
  native let value: QsTransform;
}

public native class animAnimation extends ISerializable {
  native let tags: redTagList;
  native let name: CName;
  native let duration: Float;
  native let animationType: animAnimationType;
  native let animBuffer: ref<animIAnimationBuffer>;
  native let additionalTransforms: animAdditionalTransformContainer;
  native let additionalTracks: animAdditionalFloatTrackContainer;
  native let motionExtraction: ref<animIMotionExtraction>;
  native let frameClamping: Bool;
  native let frameClampingStartFrame: Int8;
  native let frameClampingEndFrame: Int8;
}

public native class animAnimationBufferCompressed extends animIAnimationBuffer {
  native let duration: Float;
  native let numFrames: Uint32;
  native let numExtraJoints: Uint8;
  native let numExtraTracks: Uint8;
  native let numJoints: Uint16;
  native let numTracks: Uint16;
  native let numAnimKeys: Uint32;
  native let numAnimKeysRaw: Uint32;
  native let numConstAnimKeys: Uint32;
  native let numTrackKeys: Uint32;
  native let numConstTrackKeys: Uint32;
  native let isScaleConstant: Bool;
  native let hasRawRotations: Bool;
  native let fallbackFrameIndices: array<Uint16>;
  native let dataAddress: animAnimDataAddress;
  native let extraDataNames: array<CName>;
}

public native class animAnimationBufferSimd extends animIAnimationBuffer {
  native let duration: Float;
  native let numFrames: Uint32;
  native let numExtraJoints: Uint8;
  native let numExtraTracks: Uint8;
  native let numJoints: Uint16;
  native let numTracks: Uint16;
  native let numTranslationsToCopy: Uint16;
  native let numTranslationsToEvalAlignedToSimd: Uint16;
  native let quantizationBits: Uint16;
  native let isScaleConstant: Bool;
  native let isTrackConstant: Bool;
  native let dataAddress: animAnimDataAddress;
  native let fallbackFrameIndices: array<Uint16>;
  native let extraDataNames: array<CName>;
}

public native struct animAnimationImportInfo {
  native let AnimationType: animAnimationType;
  native let BufferType: animcompressionBufferTypePreset;
  native let CompressionPreset: animcompressionQualityPreset;
  native let FrameratePreset: animcompressionFrameratePreset;
  native let MotionExtractionCompression: animEMotionExtractionCompressionType;
}

public native struct animAnimationSetup {
  native let cinematics: animAnimSetCollection;
  native let gameplay: animAnimSetCollection;
  native let finalAnimSetCollection: animAnimSetCollection;
}

enum animAnimationType {
  Normal = 0,
  AdditiveFromRefPose = 1,
  AdditiveFromFirstFrame = 2,
  Additive = 3,
  AdditiveWithoutFirstFrame = 4,
}

public native struct animAnimDataAddress {
  native let unkIndex: Uint32;
  native let fsetInBytes: Uint32;
  native let zeInBytes: Uint32;
}

public native struct animAnimDatabaseCollection {
  native let animDatabases: array<animAnimDatabaseCollectionEntry>;
}

public native struct animAnimDatabaseCollectionEntry {
  native let name: CName;
  native let animDatabase: ResourceRef; // rRef<C2dArray>
  native let overrideAnimDatabase: ResourceRef; // rRef<animGenericAnimDatabase>
}

public native struct animAnimDataChunk {}

public native class animAnimEvent_Effect extends animAnimEvent {
  native let effectName: CName;
}

public native class animAnimEvent_EffectDuration extends animAnimEvent {
  native let effectName: CName;
  native let sequenceShift: Uint32;
  native let breakAllLoopsOnStop: Bool;
}

public native class animAnimEvent_FoleyAction extends animAnimEvent {
  native let actionName: CName;
}

public native class animAnimEvent_FootIK extends animAnimEvent {
  native let leg: animLeg;
}

public native class animAnimEvent_FootPhase extends animAnimEvent {
  native let phase: animEFootPhase;
}

public native class animAnimEvent_FootPlant extends animAnimEvent {
  native let side: animEventSide;
  native let customEvent: CName;
}

public native class animAnimEvent_ForceRagdoll extends animAnimEvent {}

public native class animAnimEvent_GameplayVo extends animAnimEvent {
  native let voContext: CName;
  native let isQuest: Bool;
}

public native class animAnimEvent_ItemEffect extends animAnimEvent {
  native let effectName: CName;
}

public native class animAnimEvent_ItemEffectDuration extends animAnimEvent {
  native let effectName: CName;
  native let sequenceShift: Uint32;
  native let breakAllLoopsOnStop: Bool;
}

public native class animAnimEvent_KeyPose extends animAnimEvent {}

public native class animAnimEvent_Phase extends animAnimEvent {}

public native class animAnimEvent_SafeCut extends animAnimEvent {}

public native class animAnimEvent_SceneItem extends animAnimEvent {
  native let boneName: CName;
}

public native class animAnimEvent_Simple extends animAnimEvent {}

public native class animAnimEvent_SimpleDuration extends animAnimEvent {}

public native class animAnimEvent_Slide extends animAnimEvent {}

public native class animAnimEvent_Sound extends animAnimEvent {
  native let switches: array<audioAudSwitch>;
  native let params: array<audioAudParameter>;
  native let dynamicParams: array<CName>;
  native let metadataContext: CName;
  native let onlyPlayOn: CName;
  native let dontPlayOn: CName;
  native let playerGenderAlt: animAnimEventGenderAlt;
}

public native class animAnimEvent_SoundFromEmitter extends animAnimEvent {
  native let emitterName: CName;
}

public native class animAnimEvent_TrajectoryAdjustment extends animAnimEvent {}

public native class animAnimEvent_Valued extends animAnimEvent {
  native let value: Float;
}

public native class animAnimEvent_WorkspotFastExitCutoff extends animAnimEvent {}

public native class animAnimEvent_WorkspotItem extends animAnimEvent {
  native let actions: array<ref<workIWorkspotItemAction>>;
}

public native class animAnimEvent_WorkspotPlayFacialAnim extends animAnimEvent {
  native let facialAnimName: CName;
}

public abstract native class animAnimEvent extends ISerializable {
  native let startFrame: Uint32;
  native let durationInFrames: Uint32;
  native let eventName: CName;
}

enum animAnimEventGenderAlt {
  None = 0,
  Female = 1,
  Male = 2,
}

public native struct animAnimFallbackFrameDesc {
  native let mPositions: Uint16;
  native let mRotations: Uint16;
  native let mFloatTracks: Uint16;
}

public native class animAnimFeature_AIActionAnimation extends AnimFeature_AIAction {
  native let animFeatureName: CName;
}

public native class animAnimFeature_Crowd extends AnimFeature {
  native let stopType: Int32;
  native let speedType: Int32;
  native let speedOverrideType: Int32;
  native let bumpDirection: Int32;
  native let threatSource: Int32;
  native let locomotionState: Int32;
  native let bumpSourceLocation: Int32;
  native let lookAtAngle: Float;
  native let fearStage: Int32;
  native let startType: Int32;
  native let startDirectionAngle: Float;
  native let animTime: Float;
  native let isBlocked: Bool;
  native let bumpType: Int32;
  native let fleeType: Int32;
  native let randomVariation: Float;
  native let animScale: Float;
  native let slopeRatio: Float;
  native let distanceToPlayer2D: Float;
  native let angleToPlayer: Float;
}

public native class animAnimFeature_CrowdLocomotion extends AnimFeature {
  native let speed: Float;
  native let slopeAngle: Float;
  native let isCrowd: Bool;
}

public native class animAnimFeature_DangleExternalInput extends AnimFeature {
  native let fictitiousAccelerationWs: Vector4;
}

public native class animAnimFeature_EditorOnlyPredictiveLookAt extends AnimFeature {
  native let isEnabled: Bool;
  native let target: Vector4;
  native let suppress: Float;
  native let mode: Int32;
}

public native class animAnimFeature_Interaction extends AnimFeature {
  native let interactionDuration: Float;
  native let interactionStage: Int32;
}

public native class animAnimFeature_NPCExploration extends AnimFeature {
  native let explorationType: Int32;
  native let state: Int32;
  native let movementType: Int32;
  native let isEvenLoop: Bool;
  native let playbackTime: Float;
}

public native class animAnimFeature_SmartObject extends AnimFeature {
  native let state: Int32;
  native let privateAnimationName: CName;
}

public native class animAnimFeature_VehiclePassengerAnimSetup extends AnimFeature {
  native let enableAdditiveAnim: Bool;
  native let additiveScale: Float;
}

public native class animAnimFeature_WeaponUser extends AnimFeature {
  native let ikLeftHandLocalPosition: Vector4;
  native let ikRightHandLocalPosition: Vector4;
}

public native struct animAnimFeatureEvent {}

public native class animAnimFeatureUpdateWorkspot extends AnimFeature {
  native let animName: CName;
  native let recordID: Int32;
  native let updateCounter: Int32;
  native let boolsAsFlags: Int32;
  native let animBlendTime: Float;
  native let forcedBlendIn: Float;
  native let forceAnimTime: Float;
  native let timeScale: Float;
  native let animationStartTime: Double;
  native let isPaused: Bool;
  native let isLooped: Bool;
  native let isExitAnim: Bool;
  native let enableMotion: Bool;
  native let isActive: Bool;
  native let isAnimValid: Bool;
  native let slotNameHash: Int32;
  native let facialKeyWeight: Float;
  native let facialIdleAnimation: CName;
  native let facialIdleKeyAnimation: CName;
  native let globalBlendDuration: Float;
  native let globalBlendIn: Bool;
}

public native class animAnimGraph extends CResource {
  native let rootNode: ref<animAnimNode_Root>;
  native let variables: ref<animAnimVariableContainer>;
  native let animFeatures: array<animAnimFeatureEntry>;
  native let timeDeltaMultiplier: Float;
  native let isPaused: Bool;
  native let oneFrameToggle: Bool;
  native let hasMixerSlot: Bool;
  native let additionalAnimDatabases: array<animAnimDatabaseCollectionEntry>;
  native let nodesToInit: array<ref<animAnimNode_Base>>;
  native let useLunaticMode: Bool;
  native let useAnimCommands: Bool;
  native let useAnimCommandsForCrowd: Bool;
  native let useAnimStaticCommands: Bool;
  native let staticCommandsRig: ResourceRef; // rRef<animRig>
  native let hackAlwaysSample: Bool;
}

public native class animAnimGraphDebugState extends ISerializable {
  native let nodes: array<animAnimNodeDebugState>;
}

public native class animAnimGraphExternalEvent extends ISerializable {
  native let eventName: CName;
}

public native struct animAnimMathExpressionFloatSocket {
  native let link: animFloatLink;
  native let expressionVarId: Uint16;
  native let inputFloatTrack: animNamedTrackIndex;
}

public native struct animAnimMathExpressionQuaternionSocket {
  native let link: animQuaternionLink;
  native let expressionVarId: Uint16;
}

public native struct animAnimMathExpressionVectorSocket {
  native let link: animVectorLink;
  native let expressionVarId: Uint16;
}

public native struct animAnimMultiBoolToFloatEntry {
  native let group: CName;
  native let name: CName;
}

public native class animAnimNode_AddIkRequest extends animAnimNode_OnePoseInput {
  native let ikChain: CName;
  native let targetBone: animTransformIndex;
  native let positionOffset: Vector3;
  native let rotationOffset: Quaternion;
  native let poleVector: animPoleVectorDetails;
  native let weightPosition: Float;
  native let weightRotation: Float;
  native let blendTimeIn: Float;
  native let blendTimeOut: Float;
  native let priority: Int32;
}

public native class animAnimNode_AdditionalFloatTrack extends animAnimNode_Base {
  native let poseInputNode: animPoseLink;
  native let additionalTracks: animAdditionalFloatTrackContainer;
}

public native class animAnimNode_AdditionalTransform extends animAnimNode_OnePoseInput {
  native let additionalTransforms: animAdditionalTransformContainer;
}

public native class animAnimNode_AddSnapToTerrainIkRequest extends animAnimNode_OnePoseInput {
  native let animDeltaZ: animFloatLink;
  native let leftFootRequest: animSnapToTerrainIkRequest;
  native let rightFootRequest: animSnapToTerrainIkRequest;
  native let hipsRequest: animHipsIkRequest;
}

public native class animAnimNode_AimConstraint_ObjectRotationUp extends animAnimNode_OnePoseInput {
  native let targetTransform: animTransformIndex;
  native let upTransform: animTransformIndex;
  native let upTransformVector: Vector3;
  native let transformIndex: animTransformIndex;
  native let forwardAxisLS: Vector3;
  native let upAxisLS: Vector3;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_AimConstraint_ObjectUp extends animAnimNode_OnePoseInput {
  native let targetTransform: animTransformIndex;
  native let upTransform: animTransformIndex;
  native let transformIndex: animTransformIndex;
  native let forwardAxisLS: Vector3;
  native let upAxisLS: Vector3;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_AimConstraint extends animAnimNode_OnePoseInput {
  native let areSourceChannelsResaved: Bool;
  native let targetTransforms: array<ref<animAnimNodeSourceChannel_WeightedVector>>;
  native let targetTransform: animTransformIndex;
  native let upTransform: ref<animIAnimNodeSourceChannel_Vector>;
  native let transformIndex: animTransformIndex;
  native let forwardAxisLS: Vector3;
  native let upAxisLS: Vector3;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_AnimDatabase extends animAnimNode_SkPhaseWithDurationAnim {
  native let animDataBase: animAnimDatabaseCollectionEntry;
  native let inputLinks: array<animIntLink>;
}

public native class animAnimNode_AnimSetTagValue extends animAnimNode_FloatValue {
  native let tags: redTagList;
}

public native class animAnimNode_AnimSlot extends animAnimNode_Base {
  native let inputLink: animPoseLink;
}

public native class animAnimNode_ApplyCorrectivePoseRBF extends animAnimNode_OnePoseInput {
  native let rbfCoefficient: Float;
  native let rbfPowValue: Float;
  native let correctiveFrame: Float;
  native let correctives: array<animCorrectivePoseEntry>;
}

public abstract native class animAnimNode_Base extends ISerializable {
  native let id: Uint32;
}

public native class animAnimNode_BaseSwitch extends animAnimNode_Base {
  native let blendTime: Float;
  native let timeWarpingEnabled: Bool;
  native let syncMethod: ref<animISyncMethod>;
  native let inputNodes: array<animPoseLink>;
  native let canRequestInertialization: Bool;
}

public native class animAnimNode_Blend2 extends animAnimNode_Base {
  native let minInputValue: Float;
  native let maxInputValue: Float;
  native let timeWarpingEnabled: Bool;
  native let syncMethod: ref<animISyncMethod>;
  native let firstInputNode: animPoseLink;
  native let secondInputNode: animPoseLink;
  native let weightNode: animFloatLink;
}

public native class animAnimNode_BlendAdditive extends animAnimNode_Base {
  native let biasValue: Float;
  native let scaleValue: Float;
  native let additiveType: animEAnimGraphAdditiveType;
  native let timeWarpingEnabled: Bool;
  native let blendTracks: animEBlendTracksMode;
  native let syncMethod: ref<animISyncMethod>;
  native let inputNode: animPoseLink;
  native let addedInputNode: animPoseLink;
  native let weightNode: animFloatLink;
  native let postProcess: ref<animIAnimNode_PostProcess>;
  native let weightPreviousFrameFloatTrack: animNamedTrackIndex;
  native let weightPreviousFrameFloatTrackDefaultValue: Float;
  native let maskName: CName;
}

public native class animAnimNode_BlendByMaskDynamic extends animAnimNode_Base {
  native let base: animPoseLink;
  native let blend: animPoseLink;
  native let mask: animIntLink;
  native let weight: animFloatLink;
  native let masks: array<CName>;
  native let syncMethod: ref<animISyncMethod>;
}

public native class animAnimNode_BlendFromPose extends animAnimNode_OnePoseInput {
  native let blendTime: Float;
  native let blendType: animEBlendTypeLBC;
  native let customBlendCurve: CurveDataFloat;
  native let mode: animEBlendFromPoseMode;
  native let requestedByTag: CName;
}

public native class animAnimNode_BlendMultiple extends animAnimNode_Base {
  native let inputValues: array<Float>;
  native let sortedInputValues: array<Float>;
  native let minWeight: Float;
  native let maxWeight: Float;
  native let radialBlending: Bool;
  native let timeWarpingEnabled: Bool;
  native let syncMethod: ref<animISyncMethod>;
  native let motionProvider: ref<animIMotionTableProvider>;
  native let weightNode: animFloatLink;
  native let inputNodes: array<animPoseLink>;
}

public native class animAnimNode_BlendOverride extends animAnimNode_Base {
  native let inputNode: animPoseLink;
  native let overrideInputNode: animPoseLink;
  native let weightNode: animFloatLink;
  native let bones: array<animOverrideBlendBoneInfo>;
  native let blendAllTracks: Bool;
  native let blendTrackMode: animEBlendTracksMode;
  native let tracks: array<animOverrideBlendTrackInfo>;
  native let getDeltaMotionFromOverride: Bool;
  native let timeWarpingEnabled: Bool;
  native let syncMethod: ref<animISyncMethod>;
  native let blendMethod: ref<animIPoseBlendMethod>;
  native let postProcess: ref<animIAnimNode_PostProcess>;
}

public native struct animAnimNode_BlendSpace_InternalsBlendSpace {
  native let spaceDimension: Uint32;
  native let coordinatesDescriptions: array<animAnimNode_BlendSpace_InternalsBlendSpaceCoordinateDescription>;
  native let spacePoints: array<animAnimNode_BlendSpace_InternalsBlendSpacePoint>;
  native let boundaryPointsCount: Uint32;
  native let fireAnimEndEvent: Bool;
  native let animEndEventName: CName;
  native let isLooped: Bool;
  native let needsRuntimeTriangulation: Bool;
  native let wasRuntimeTriangulationResaveDone: Bool;
  native let cachedSpacePoints_coordinates: array<Float>;
  native let cachedSpaceSimplexes_pointsIndices: array<Uint32>;
  native let cachedSamplesForGridPoints_simplexIndex: array<Int32>;
  native let cachedSamplesForGridPoints_weightsForPoints: array<Float>;
}

public native struct animAnimNode_BlendSpace_InternalsBlendSpaceCoordinateDescription {
  native let name: CName;
  native let minValue: Float;
  native let maxValue: Float;
  native let gridDivisionsCount: Uint32;
}

public native struct animAnimNode_BlendSpace_InternalsBlendSpacePoint {
  native let animationName: CName;
  native let useFixedCoordinates: Bool;
  native let fixedCoordinates: array<Float>;
  native let useStaticPose: Bool;
  native let staticPoseTime: Float;
  native let staticPoseProgress: Float;
}

public native class animAnimNode_BlendSpace extends animAnimNode_Base {
  native let inputLinks: array<animFloatLink>;
  native let blendSpace: animAnimNode_BlendSpace_InternalsBlendSpace;
  native let progressLink: animFloatLink;
  native let fireAnimEndEvent: Bool;
  native let animEndEventName: CName;
  native let isLooped: Bool;
}

public native class animAnimNode_BoolConstant extends animAnimNode_BoolValue {
  native let value: Bool;
}

public native class animAnimNode_BoolInput extends animAnimNode_BoolValue {
  native let group: CName;
  native let name: CName;
}

public native class animAnimNode_BoolJoin extends animAnimNode_BoolValue {
  native let input: animBoolLink;
}

public native class animAnimNode_BoolLatch extends animAnimNode_BoolValue {
  native let input: animBoolLink;
}

public native class animAnimNode_BoolToFloatConverter extends animAnimNode_FloatValue {
  native let inputNode: animBoolLink;
}

public abstract native class animAnimNode_BoolValue extends animAnimNode_Base {}

public native class animAnimNode_BoolVariable extends animAnimNode_BoolValue {
  native let variableName: CName;
}

public native class animAnimNode_ConditionalSegmentBegin extends animAnimNode_OnePoseInput {
  native let condition: animConditionalSegmentCondition;
}

public native class animAnimNode_ConditionalSegmentEnd extends animAnimNode_OnePoseInput {}

public native class animAnimNode_ConeLimit extends animAnimNode_OnePoseInput {
  native let coneTransform: animTransformIndex;
  native let constrainedTransform: animTransformIndex;
  native let coneAxisLs: Vector3;
  native let coneAxisNormalizedLs: Vector3;
  native let coneOffsetMs: Vector3;
  native let coneOffsetMsLink: animVectorLink;
  native let marginEaseOutCurve: CurveDataFloat;
  native let limit1: Float;
  native let limit1Link: animFloatLink;
  native let limit1FloatTrack: animNamedTrackIndex;
  native let paraboloidRadius1: Float;
  native let limit2: Float;
  native let limit2Link: animFloatLink;
  native let limit2FloatTrack: animNamedTrackIndex;
  native let paraboloidRadius2: Float;
  native let limit3: Float;
  native let limit3Link: animFloatLink;
  native let limit3FloatTrack: animNamedTrackIndex;
  native let paraboloidRadius3: Float;
  native let limit4: Float;
  native let limit4Link: animFloatLink;
  native let limit4FloatTrack: animNamedTrackIndex;
  native let paraboloidRadius4: Float;
  native let coneLimitReached: animNamedTrackIndex;
  native let debug: Bool;
  native let colorfulCone: Bool;
  native let applyDebugConeScalling: Bool;
}

public abstract native class animAnimNode_Container extends animAnimNode_Base {
  native let nodes: array<ref<animAnimNode_Base>>;
}

public native class animAnimNode_CoordinateFromVector extends animAnimNode_FloatValue {
  native let vectorCoodrinateType: animVectorCoordinateType;
  native let input: animVectorLink;
}

public native class animAnimNode_CriticalSpringDamp extends animAnimNode_FloatValue {
  native let smoothTime: Float;
  native let useRange: Bool;
  native let rangeMin: Float;
  native let rangeMax: Float;
  native let useRawTime: Bool;
  native let inputNode: animFloatLink;
}

public native class animAnimNode_CurveFloatValue extends animAnimNode_FloatValue {
  native let curveData: CurveDataFloat;
  native let argument: animFloatLink;
}

public native class animAnimNode_CurvePathSlot extends animAnimNode_Base {
  native let input: animPoseLink;
}

public native class animAnimNode_CurveVectorValue extends animAnimNode_VectorValue {
  native let curveData: CurveDataVector4;
  native let argument: animFloatLink;
}

public native class animAnimNode_DampFloat extends animAnimNode_FloatValue {
  native let defaultIncreaseSpeed: Float;
  native let defaultDecreaseSpeed: Float;
  native let startFromDefaultValue: Bool;
  native let defaultInitialValue: Float;
  native let wrapAroundRange: Bool;
  native let rangeMin: Float;
  native let rangeMax: Float;
  native let inputNode: animFloatLink;
  native let increaseSpeedNode: animFloatLink;
  native let decreaseSpeedNode: animFloatLink;
}

public native class animAnimNode_DampQuaternion extends animAnimNode_QuaternionValue {
  native let defaultRotationSpeed: Float;
  native let defaultInitialValue: EulerAngles;
  native let inputNode: animQuaternionLink;
  native let initialValueNode: animQuaternionLink;
  native let rotationSpeedNode: animFloatLink;
}

public native class animAnimNode_DampVector extends animAnimNode_VectorValue {
  native let defaultIncreaseSpeed: Vector4;
  native let defaultDecreaseSpeed: Vector4;
  native let startFromDefaultValue: Bool;
  native let defaultInitialValue: Vector4;
  native let inputNode: animVectorLink;
  native let increaseSpeedNode: animVectorLink;
  native let decreaseSpeedNode: animVectorLink;
}

public native class animAnimNode_Dangle extends animAnimNode_OnePoseInput {
  native let dangleConstraint: ref<animDangleConstraint_Simulation>;
}

public native class animAnimNode_DirectConnConstraint extends animAnimNode_OnePoseInput {
  native let sourceTransform: ref<animIAnimNodeSourceChannel_QsTransform>;
  native let isSourceTransformResaved: Bool;
  native let sourceTransformIndex: animTransformIndex;
  native let transformIndex: animTransformIndex;
  native let posX: Bool;
  native let posY: Bool;
  native let posZ: Bool;
  native let rotX: Bool;
  native let rotY: Bool;
  native let rotZ: Bool;
  native let scaleX: Bool;
  native let scaleY: Bool;
  native let scaleZ: Bool;
  native let weight: Float;
  native let weightNode: animFloatLink;
}

public native class animAnimNode_DirectionToEuler extends animAnimNode_FloatValue {
  native let inputNode: animVectorLink;
  native let initialForwardVector: Vector4;
  native let conversionType: animEDirectionToEuler;
}

public native class animAnimNode_DisableLunaticMode extends animAnimNode_OnePoseInput {}

public native class animAnimNode_DisableSleepMode extends animAnimNode_OnePoseInput {
  native let forceUpdate: Bool;
}

public native class animAnimNode_Drag extends animAnimNode_OnePoseInput {
  native let sourceBone: animTransformIndex;
  native let outTargetBone: animTransformIndex;
  native let simulationFps: Float;
  native let sourceSpeedMultiplier: Float;
  native let hasOvershoot: Bool;
  native let overshootDuration: Float;
  native let overshootDetectionMinSpeed: Float;
  native let overshootDetectionMaxSpeed: Float;
  native let useSteps: Bool;
  native let stepsTargetSpeedMultiplier: Float;
  native let timeBetweenSteps: Float;
  native let timeInStep: Float;
}

public native class animAnimNode_EnumSwitch extends animAnimNode_InputSwitch {
  native let enumName: CName;
}

public native class animAnimNode_Event extends animAnimNode_FloatValue {
  native let eventName: CName;
  native let defaultValue: Float;
  native let eventValue: Float;
}

public native class animAnimNode_EventValue extends animAnimNode_FloatValue {
  native let eventName: CName;
  native let defaultValue: Float;
}

public native class animAnimNode_ExplorationAdjuster extends animAnimNode_MotionAdjuster {
  native let targetPosition2: animVectorLink;
  native let targetDirection2: animVectorLink;
  native let totalTimeToAdjust2: animFloatLink;
  native let targetPosition3: animVectorLink;
  native let targetDirection3: animVectorLink;
  native let totalTimeToAdjust3: animFloatLink;
}

public native class animAnimNode_EyesLookAt extends animAnimNode_OnePoseInput {
  native let targetALink: animVectorLink;
  native let weightALink: animFloatLink;
  native let targetBLink: animVectorLink;
  native let weightBLink: animFloatLink;
  native let transitionWeightLink: animFloatLink;
  native let leftEye: animTransformIndex;
  native let rightEye: animTransformIndex;
  native let head: animTransformIndex;
  native let forwardDirection: animAxis;
}

public native class animAnimNode_EyesReset extends animAnimNode_OnePoseInput {}

public native class animAnimNode_EyesTracksLookAt extends animAnimNode_OnePoseInput {
  native let eyeTransform: animTransformIndex;
  native let leftTrack: animNamedTrackIndex;
  native let rightTrack: animNamedTrackIndex;
  native let upTrack: animNamedTrackIndex;
  native let downTrack: animNamedTrackIndex;
  native let debug: Bool;
}

public native class animAnimNode_FacialMixerSlot extends animAnimNode_OnePoseInput {
  native let lookAtDefinitions: array<animLookAtAnimationDefinition>;
}

public native class animAnimNode_FacialSharedMetaPose extends animAnimNode_OnePoseInput {}

public native class animAnimNode_FloatClamp extends animAnimNode_FloatValue {
  native let min: Float;
  native let max: Float;
  native let inputNode: animFloatLink;
}

public native class animAnimNode_FloatComparator extends animAnimNode_FloatValue {
  native let firstValue: Float;
  native let secondValue: Float;
  native let trueValue: Float;
  native let falseValue: Float;
  native let operation: animEAnimGraphCompareFunc;
  native let firstInputLink: animFloatLink;
  native let secondInputLink: animFloatLink;
  native let trueInputLink: animFloatLink;
  native let falseInputLink: animFloatLink;
}

public native class animAnimNode_FloatConstant extends animAnimNode_FloatValue {
  native let value: Float;
}

public native class animAnimNode_FloatCumulative extends animAnimNode_FloatValue {
  native let clamp: Bool;
  native let resetOnActivation: Bool;
  native let normalize180: Bool;
  native let defaultValue: Float;
  native let resetExternalEventName: CName;
  native let inputNode: animFloatLink;
  native let minValue: animFloatLink;
  native let maxValue: animFloatLink;
  native let resetSpeed: animFloatLink;
  native let override: animBoolLink;
  native let curValue: animFloatLink;
  native let normalize180Input: animBoolLink;
}

public native class animAnimNode_FloatInput extends animAnimNode_FloatValue {
  native let group: CName;
  native let name: CName;
}

public native class animAnimNode_FloatInterpolation extends animAnimNode_FloatValue {
  native let x1: Float;
  native let x2: Float;
  native let y1: Float;
  native let y2: Float;
  native let interpolationType: animEAnimGraphMathInterpolation;
  native let inputNode: animFloatLink;
}

public native class animAnimNode_FloatJoin extends animAnimNode_FloatValue {
  native let input: animFloatLink;
}

public native class animAnimNode_FloatLatch extends animAnimNode_FloatValue {
  native let input: animFloatLink;
}

public native class animAnimNode_FloatMathOp extends animAnimNode_FloatValue {
  native let operationType: animEAnimGraphMathOp;
  native let firstInputNode: animFloatLink;
  native let secondInputNode: animFloatLink;
}

public native class animAnimNode_FloatRandom extends animAnimNode_FloatValue {
  native let rand: Bool;
  native let cooldown: Float;
  native let min: Float;
  native let max: Float;
}

public native class animAnimNode_FloatTimeDependentSinus extends animAnimNode_FloatValue {
  native let min: Float;
  native let max: Float;
  native let frequencyFactor: Float;
  native let phaseFactor: Float;
}

public native class animAnimNode_FloatToBoolConverter extends animAnimNode_BoolValue {
  native let inputNode: animFloatLink;
}

public native class animAnimNode_FloatToIntConverter extends animAnimNode_IntValue {
  native let inputNode: animFloatLink;
}

public native class animAnimNode_FloatTrackDirectConnConstraint extends animAnimNode_OnePoseInput {
  native let floatTrackIndex: animNamedTrackIndex;
  native let transformIndex: animTransformIndex;
  native let channel: animTransformChannel;
  native let mulFactor: Float;
  native let weight: Float;
  native let weightNode: animFloatLink;
  native let mulFactorNode: animFloatLink;
}

public native class animAnimNode_FloatTrackModifier extends animAnimNode_Base {
  native let floatTrack: animNamedTrackIndex;
  native let operationType: animFloatTrackOperationType;
  native let inputFloatTrack: animNamedTrackIndex;
  native let poseInputNode: animPoseLink;
  native let floatInputNode: animFloatLink;
}

public native class animAnimNode_FloatTrackModifierMarkUnstable extends animAnimNode_FloatTrackModifier {
  native let requiredQualityDistanceCategory: Uint32;
}

public abstract native class animAnimNode_FloatValue extends animAnimNode_Base {}

public native struct animAnimNode_FloatValueDebugProvider {
  native let isEnabled: Bool;
  native let min: Float;
  native let max: Float;
  native let progress: Float;
  native let auto: Bool;
  native let speed: Float;
  native let wrap: Bool;
}

public native class animAnimNode_FloatVariable extends animAnimNode_FloatValue {
  native let variableName: CName;
}

public native class animAnimNode_FloorIk extends animAnimNode_FloorIkBase {
  native let pelvis: animSBehaviorConstraintNodeFloorIKVerticalBoneData;
  native let legs: animSBehaviorConstraintNodeFloorIKLegsData;
  native let leftLegIK: animSTwoBonesIKSolverData;
  native let rightLegIK: animSTwoBonesIKSolverData;
}

public native class animAnimNode_FloorIkBase extends animAnimNode_OnePoseInput {
  native let requiredAnimEvent: CName;
  native let blockAnimEvent: CName;
  native let canBeDisabledDueToFrameRate: Bool;
  native let useFixedVersion: Bool;
  native let slopeAngleDamp: Float;
  native let common: animSBehaviorConstraintNodeFloorIKCommonData;
}

public native class animAnimNode_FootStepAdjuster extends animAnimNode_OnePoseInput {
  native let leftToeName: animTransformIndex;
  native let rightToeName: animTransformIndex;
  native let leftFootName: animTransformIndex;
  native let rightFootName: animTransformIndex;
  native let leftCalfName: animTransformIndex;
  native let rightCalfName: animTransformIndex;
  native let leftThighName: animTransformIndex;
  native let rightThighName: animTransformIndex;
  native let pelvisBoneName: animTransformIndex;
  native let calfHingeAxis: Vector4;
  native let IKBlendTime: Float;
  native let pelvisAdjustmentBlendSpeed: Float;
  native let adjustPelvisVertically: Bool;
  native let stepAdjustmentInterval: Float;
  native let controlValueNode: animFloatLink;
  native let controlVectorNode: animVectorLink;
}

public native class animAnimNode_FootStepScaling extends animAnimNode_OnePoseInput {
  native let hipsIndex: animTransformIndex;
  native let leftFootIKIndex: animTransformIndex;
  native let rightFootIKIndex: animTransformIndex;
  native let inputSpeed: animFloatLink;
  native let weight: animFloatLink;
  native let Params: animfssBodyOfflineParams;
}

public native class animAnimNode_ForegroundSegmentBegin extends animAnimNode_OnePoseInput {}

public native class animAnimNode_ForegroundSegmentEnd extends animAnimNode_OnePoseInput {
  native let isAlwaysEnabledForHighEndHardware: Bool;
}

public native class animAnimNode_FPPCamera extends animAnimNode_OnePoseInput {}

public native class animAnimNode_FPPCameraSharedVar extends animAnimNode_FloatValue {}

public native class animAnimNode_FrozenFrame extends animAnimNode_OnePoseInput {
  native let maxFramesFrozen: Int32;
  native let triggerEventName: CName;
  native let clearEventName: CName;
}

public native class animAnimNode_GenerateIkAnimFeatureData extends animAnimNode_OnePoseInput {
  native let ikChainSettings: array<IKChainSettings>;
}

public native class animAnimNode_GraphSlot_Test extends animAnimNode_GraphSlot {
  native let graph_TEST: ResourceRef; // rRef<animAnimGraph>
  native let copyAnimInputsAtAttachTime: Bool;
}

public native class animAnimNode_GraphSlot extends animAnimNode_Base {
  native let name: CName;
  native let dontDeactivateInput: Bool;
  native let inputLink: animPoseLink;
}

public native class animAnimNode_GraphSlotConditions extends animAnimNode_GraphSlot {
  native let conditions: array<animGraphSlotCondition>;
}

public native class animAnimNode_GraphSlotInput extends animAnimNode_Base {}

public native class animAnimNode_HumanIk extends animAnimNode_OnePoseInput {
  native let ikTargetsControllers: array<animTEMP_IKTargetsControllerBodyType>;
}

public native class animAnimNode_IdentityPoseTerminator extends animAnimNode_Base {}

public native class animAnimNode_Ik2 extends animAnimNode_Base {
  native let firstBone: animTransformIndex;
  native let secondBone: animTransformIndex;
  native let endBone: animTransformIndex;
  native let hingeAxis: animAxis;
  native let minHingeAngleDegrees: Float;
  native let maxHingeAngleDegrees: Float;
  native let firstBoneIkGain: Float;
  native let secondBoneIkGain: Float;
  native let endBoneIkGain: Float;
  native let enforceEndPosition: Bool;
  native let enforceEndOrientation: Bool;
  native let endBoneOffsetPositionLS: Vector4;
  native let bone: animTransformIndex;
  native let floatTrack: animNamedTrackIndex;
  native let inputPoseNode: animPoseLink;
  native let weightNode: animFloatLink;
  native let endTargetPositionNode: animVectorLink;
  native let endTargetOrientationNode: animQuaternionLink;
}

public native class animAnimNode_Ik2Constraint extends animAnimNode_OnePoseInput {
  native let inputTarget: ref<animIAnimNodeSourceChannel_Vector>;
  native let inputPoleVector: ref<animIAnimNodeSourceChannel_Vector>;
  native let inputTargetOrientation: ref<animAnimNodeSourceChannel_WeightedQuat>;
  native let firstBoneIndex: animTransformIndex;
  native let secondBoneIndex: animTransformIndex;
  native let endBoneIndex: animTransformIndex;
  native let hingeAxis: animAxis;
  native let twistValue: Float;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
  native let weightNode: animFloatLink;
  native let twistNode: animFloatLink;
  native let maxHingeAngle: Float;
}

public native class animAnimNode_Inertialization extends animAnimNode_OnePoseInput {
  native let safeMode: Bool;
  native let transformsCountUpperBound: Uint32;
  native let tracksCountUpperBound: Uint32;
  native let rotationLimits: array<animInertializationRotationLimit>;
}

public native class animAnimNode_InputSwitch extends animAnimNode_BaseSwitch {
  native let selectIntNode: animIntLink;
  native let selectFloatNode: animFloatLink;
}

public native class animAnimNode_IntConstant extends animAnimNode_IntValue {
  native let value: Int32;
}

public native class animAnimNode_IntInput extends animAnimNode_IntValue {
  native let group: CName;
  native let name: CName;
}

public native class animAnimNode_IntJoin extends animAnimNode_IntValue {
  native let input: animIntLink;
}

public native class animAnimNode_IntLatch extends animAnimNode_IntValue {
  native let input: animIntLink;
}

public native class animAnimNode_IntToFloatConverter extends animAnimNode_FloatValue {
  native let inputNode: animIntLink;
}

public abstract native class animAnimNode_IntValue extends animAnimNode_Base {}

public native class animAnimNode_IntVariable extends animAnimNode_IntValue {
  native let variableName: CName;
}

public native class animAnimNode_Join extends animAnimNode_Base {
  native let input: animPoseLink;
}

public native class animAnimNode_LocomotionAdjuster extends animAnimNode_OnePoseInput {
  native let targetPosition: animVectorLink;
  native let targetDirection: animVectorLink;
  native let initialForwardVector: Vector4;
  native let blendSpeedPos: Float;
  native let blendSpeedPosMin: Float;
  native let blendSpeedRot: Float;
  native let maxDistance: Float;
}

public native class animAnimNode_LocomotionAdjusterOnEvent extends animAnimNode_LocomotionAdjuster {
  native let locomotionFeatureName: CName;
  native let targetAnimationName: CName;
  native let startAdjustmentAfterAnimEvent: CName;
}

public native class animAnimNode_LocomotionMachine extends animAnimNode_StateMachine {
  native let usePlanner: Bool;
  native let group: CName;
  native let logic: CName;
  native let requestId: CName;
  native let distance: CName;
  native let duration: CName;
  native let motion: CName;
  native let state: CName;
  native let transitionTime: Float;
  native let numVariants: Uint32;
}

public native class animAnimNode_LocomotionSwitch extends animAnimNode_Switch {
  native let audioTagsPerInput: array<CName>;
}

public native class animAnimNode_LocoState extends animAnimNode_State {
  native let type: animLocoStateType;
  native let locoTag: CName;
}

public native class animAnimNode_LODBegin extends animAnimNode_OnePoseInput {
  native let levelOfDetail: Uint32;
}

public native class animAnimNode_LODEnd extends animAnimNode_Base {
  native let inputLink: animPoseLink;
}

public native class animAnimNode_LookAt extends animAnimNode_OnePoseInput {
  native let transform: animTransformIndex;
  native let forwardAxis: animAxis;
  native let useLimits: Bool;
  native let limitAxis: animAxis;
  native let limitAngle: Float;
  native let targetNode: animVectorLink;
  native let weightNode: animFloatLink;
}

public native class animAnimNode_LookAtApplyVehicleRestrictions extends animAnimNode_OnePoseInput {
  native let group: CName;
  native let name: CName;
  native let referenceBone: animTransformIndex;
}

public native class animAnimNode_LookAtController extends animAnimNode_OnePoseInput {
  native let E3_HACK_offset: animVectorLink;
  native let orderedBodyParts: array<LookAtPartInfo>;
  native let stateMachinesSettings: array<LookAtStateMachineSettings>;
  native let bodyPartsDependencies: array<LookAtPartsDependency>;
  native let substepTime: Float;
  native let isFacial: Bool;
}

public native class animAnimNode_LookAtPose360 extends animAnimNode_Base {
  native let speedInDegreesPerSecond: Float;
  native let angleOffsetNode: animFloatLink;
  native let targetAngleOffsetNode: animFloatLink;
  native let weightNode: animFloatLink;
  native let animEndEventName: CName;
  native let animation: CName;
  native let durationCut: Float;
}

public native class animAnimNode_LookAtPose360Direction extends animAnimNode_FloatValue {
  native let angleOffset: Float;
  native let defaultValue: Float;
  native let negateOutput: Bool;
}

public native class animAnimNode_MaskReset extends animAnimNode_OnePoseInput {
  native let weightNode: animFloatLink;
  native let transforms: array<animTransformIndex>;
}

public native class animAnimNode_MathExpressionFloat extends animAnimNode_FloatValue {
  native let expressionData: animMathExpressionNodeData;
}

public native class animAnimNode_MathExpressionPose extends animAnimNode_OnePoseInput {
  native let expressionData: animMathExpressionNodeData;
  native let outputFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_MathExpressionQuaternion extends animAnimNode_QuaternionValue {
  native let expressionData: animMathExpressionNodeData;
}

public native class animAnimNode_MathExpressionVector extends animAnimNode_VectorValue {
  native let expressionData: animMathExpressionNodeData;
}

public native class animAnimNode_MixerSlot extends animAnimNode_OnePoseInput {
  native let maxNormalAnimEntriesCount: Uint16;
  native let maxAdditiveAnimEntriesCount: Uint16;
  native let maxOverrideAnimEntriesCount: Uint16;
}

public native class animAnimNode_MotionAdjuster extends animAnimNode_Base {
  native let inputNode: animPoseLink;
  native let targetPosition: animVectorLink;
  native let targetDirection: animVectorLink;
  native let totalTimeToAdjust: animFloatLink;
  native let forwardVector: Vector4;
}

public abstract native class animAnimNode_MotionTableSwitch extends animAnimNode_Base {}

public native class animAnimNode_MultiBoolToFloatValue extends animAnimNode_FloatValue {
  native let allMustBeTrue: Bool;
  native let onTrue: Float;
  native let onFalse: Float;
  native let inputsData: array<animAnimMultiBoolToFloatEntry>;
}

public native struct animAnimNode_MultipleParentConstraint_ParentInfo {
  native let parentTransform: animTransformIndex;
  native let parentWeightMode: animConstraintWeightMode;
  native let parentStaticWeight: Float;
  native let parentTrackWeight: animNamedTrackIndex;
  native let useComplementWeight: Bool;
  native let useOffset: Bool;
  native let offset: QsTransform;
}

public native class animAnimNode_MultipleParentConstraint extends animAnimNode_OnePoseInput {
  native let parentsTransform: array<ref<animIAnimNodeSourceChannel_QsTransform>>;
  native let parentsWeight: array<ref<animIAnimNodeSourceChannel_Float>>;
  native let areSourceChannelsResaved: Bool;
  native let parentsTransforms: array<animAnimNode_MultipleParentConstraint_ParentInfo>;
  native let transformIndex: animTransformIndex;
  native let interpolationType: animEInterpolationType;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_NameHashConstant extends animAnimNode_IntValue {
  native let value: CName;
}

public native class animAnimNode_NPCExploration extends animAnimNode_Base {}

public abstract native class animAnimNode_OnePoseInput extends animAnimNode_Base {
  native let inputLink: animPoseLink;
}

public native struct animAnimNode_OrientConstraint_WeightedTransform {
  native let transform: animTransformIndex;
  native let weight: Float;
}

public native class animAnimNode_OrientConstraint extends animAnimNode_OnePoseInput {
  native let areSourceChannelsResaved: Bool;
  native let inputTransforms: array<ref<animAnimNodeSourceChannel_WeightedQuat>>;
  native let preprocessedWeights: array<Float>;
  native let inputWeightedTransforms: array<animAnimNode_OrientConstraint_WeightedTransform>;
  native let transformIndex: animTransformIndex;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_Output extends animAnimNode_Base {
  native let node: animPoseLink;
}

public native class animAnimNode_ParentConstraint extends animAnimNode_OnePoseInput {
  native let parentTransform: ref<animIAnimNodeSourceChannel_QsTransform>;
  native let isParentTransformResaved: Bool;
  native let parentTransformIndex: animTransformIndex;
  native let transformIndex: animTransformIndex;
  native let interpolationType: animEInterpolationType;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
  native let useBoneReferencePoseAsDefaultOffset: Bool;
  native let weightNode: animFloatLink;
  native let offsetTranslationLS: animVectorLink;
  native let offsetEulerRotationLS: animVectorLink;
}

public native class animAnimNode_ParentTransform extends animAnimNode_OnePoseInput {
  native let mapping: array<animAnimTransformMappingEntry>;
}

public native struct animAnimNode_PointConstraint_WeightedTransform {
  native let transform: animTransformIndex;
  native let weight: Float;
}

public native class animAnimNode_PointConstraint extends animAnimNode_OnePoseInput {
  native let areSourceChannelsResaved: Bool;
  native let inputTransforms: array<ref<animAnimNodeSourceChannel_WeightedVector>>;
  native let preprocessedWeights: array<Float>;
  native let inputWeightedTransforms: array<animAnimNode_PointConstraint_WeightedTransform>;
  native let transformIndex: animTransformIndex;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNode_Pose360 extends animAnimNode_Base {
  native let angle: animFloatLink;
  native let animation: CName;
}

public native class animAnimNode_PoseCorrection extends animAnimNode_OnePoseInput {}

public native class animAnimNode_PoseLsToMs extends animAnimNode_OnePoseInput {}

public native class animAnimNode_PoseMsToLs extends animAnimNode_OnePoseInput {}

public native class animAnimNode_PostProcess_Footlock extends animIAnimNode_PostProcess {}

public native class animAnimNode_QuaternionConstant extends animAnimNode_QuaternionValue {
  native let value: Quaternion;
}

public native class animAnimNode_QuaternionInput extends animAnimNode_QuaternionValue {
  native let group: CName;
  native let name: CName;
}

public native class animAnimNode_QuaternionInterpolation extends animAnimNode_QuaternionValue {
  native let interpolationType: animQuaternionInterpolationType;
  native let firstInput: animQuaternionLink;
  native let secondInput: animQuaternionLink;
  native let weight: animFloatLink;
}

public native class animAnimNode_QuaternionJoin extends animAnimNode_QuaternionValue {
  native let input: animQuaternionLink;
}

public native class animAnimNode_QuaternionLatch extends animAnimNode_QuaternionValue {
  native let input: animQuaternionLink;
}

public abstract native class animAnimNode_QuaternionValue extends animAnimNode_Base {}

public native class animAnimNode_QuaternionVariable extends animAnimNode_QuaternionValue {
  native let variableName: CName;
}

public native class animAnimNode_QuaternionWsToMs extends animAnimNode_QuaternionValue {
  native let quaternionWs: animQuaternionLink;
}

public native class animAnimNode_RagdollControl extends animAnimNode_Base {
  native let blendInDuration: Float;
  native let blendOutDuration: Float;
  native let inputPoseNode: animPoseLink;
}

public native class animAnimNode_RagdollPose extends animAnimNode_Base {}

public native class animAnimNode_ReadIkRequest extends animAnimNode_OnePoseInput {
  native let ikChain: CName;
  native let outTransform: animTransformIndex;
}

public native class animAnimNode_ReferencePoseTerminator extends animAnimNode_Base {}

public native class animAnimNode_Retarget extends animAnimNode_OnePoseInput {
  native let refRig: ResourceRef; // rRef<animRig>
  native let postProcess: ref<animIAnimNode_PostProcess>;
}

public native class animAnimNode_Root extends animAnimNode_Container {
  native let outputNode: animPoseLink;
}

public native class animAnimNode_RotateBone extends animAnimNode_Base {
  native let inputNode: animPoseLink;
  native let angleNode: animFloatLink;
  native let minValueNode: animFloatLink;
  native let maxValueNode: animFloatLink;
  native let bone: animTransformIndex;
  native let axis: animETransformAxis;
  native let scale: Float;
  native let biasAngle: Float;
  native let minAngle: Float;
  native let maxAngle: Float;
  native let clampRotation: Bool;
  native let useIncrementalMode: Bool;
  native let resetOnActivation: Bool;
  native let inModelSpace: Bool;
}

public native class animAnimNode_RotateBoneByQuaternion extends animAnimNode_Base {
  native let inputNode: animPoseLink;
  native let quaternionNode: animQuaternionLink;
  native let bone: animTransformIndex;
  native let useIncrementalMode: Bool;
  native let resetOnActivation: Bool;
}

public native class animAnimNode_RotationLimit extends animAnimNode_OnePoseInput {
  native let constrainedTransform: animTransformIndex;
  native let limitOnX: animSmoothFloatClamp;
  native let limitOnY: animSmoothFloatClamp;
  native let limitOnZ: animSmoothFloatClamp;
  native let useEyesLookAtBlendWeight: Bool;
  native let weightLink: animFloatLink;
}

public native class animAnimNode_RuntimeSwitch extends animAnimNode_Base {
  native let condition: ref<animIRuntimeCondition>;
  native let True: animPoseLink;
  native let False: animPoseLink;
}

public native class animAnimNode_SelectiveJoin extends animAnimNode_OnePoseInput {}

public native class animAnimNode_Sermo extends animAnimNode_OnePoseInput {}

public native class animAnimNode_SetBoneOrientation extends animAnimNode_OnePoseInput {
  native let bone: animTransformIndex;
  native let orientationMs: animQuaternionLink;
}

public native class animAnimNode_SetBonePosition extends animAnimNode_OnePoseInput {
  native let bone: animTransformIndex;
  native let positionMs: animVectorLink;
}

public native class animAnimNode_SetBoneTransform extends animAnimNode_OnePoseInput {
  native let entries: array<animSetBoneTransformEntry>;
}

enum animAnimNode_SetDrivenKey_InternalsEChannelType {
  FloatTrack = 0,
  TransX = 1,
  TransY = 2,
  TransZ = 3,
  RotEulZ_Pitch = 4,
  RotEulX_Roll = 5,
  RotEulY_Yaw = 6,
  ScaleX = 7,
  ScaleY = 8,
  ScaleZ = 9,
  RotQuatX = 10,
  RotQuatY = 11,
  RotQuatZ = 12,
  RotQuatW = 13,
}

public native struct animAnimNode_SetDrivenKey_InternalsEntry {
  native let curve: CurveDataFloat;
  native let inChannelName: CName;
  native let outChannelName: CName;
  native let inChanelType: animAnimNode_SetDrivenKey_InternalsEChannelType;
  native let outChanelType: animAnimNode_SetDrivenKey_InternalsEChannelType;
}

public abstract native class animAnimNode_SetDrivenKey_InternalsISetDrivenKeyEntryProvider extends ISerializable {}

public native class animAnimNode_SetDrivenKey_InternalsSetDrivenKeyEntryProviderInline extends animAnimNode_SetDrivenKey_InternalsISetDrivenKeyEntryProvider {
  native let entries: array<animAnimNode_SetDrivenKey_InternalsEntry>;
}

public native class animAnimNode_SetDrivenKey extends animAnimNode_Base {
  native let inputLink: animPoseLink;
  native let provider: ref<animAnimNode_SetDrivenKey_InternalsISetDrivenKeyEntryProvider>;
}

public native class animAnimNode_SetRequiredDistanceCategory extends animAnimNode_OnePoseInput {
  native let requiredQualityDistanceCategory: Uint32;
}

public native class animAnimNode_SetRequiredDistanceCategoryByBone extends animAnimNode_OnePoseInput {
  native let bone: animTransformIndex;
}

public native class animAnimNode_SetTrackRange extends animAnimNode_OnePoseInput {
  native let min: Float;
  native let max: Float;
  native let oldMin: Float;
  native let oldMax: Float;
  native let minLink: animFloatLink;
  native let maxLink: animFloatLink;
  native let oldMinLink: animFloatLink;
  native let oldMaxLink: animFloatLink;
  native let track: animNamedTrackIndex;
  native let debug: Bool;
}

public native class animAnimNode_SharedMetaPose extends animAnimNode_OnePoseInput {
  native let weightLink: animFloatLink;
}

public native class animAnimNode_SharedMetaPoseAdditive extends animAnimNode_OnePoseInput {
  native let weightLink: animFloatLink;
  native let additiveType: animEAnimGraphAdditiveType;
  native let blendTracks: animEBlendTracksMode;
  native let convertParentPoseToAdditive: Bool;
}

public native class animAnimNode_Signal extends animAnimNode_FloatValue {
  native let blendIn: Float;
  native let blendOut: Float;
  native let startEvent: CName;
  native let endEvent: CName;
  native let defaultState: Bool;
  native let cooldown: Float;
}

public native class animAnimNode_SimpleBounce extends animAnimNode_OnePoseInput {
  native let areChannelsResaved: Bool;
  native let outputDriverTrack: animNamedTrackIndex;
  native let debug: Bool;
  native let startTransform: animTransformIndex;
  native let endTransform: animTransformIndex;
  native let multiplier: Float;
  native let negativeMultiplier: Float;
  native let smoothStep: Float;
  native let offset: Float;
  native let delay: Float;
  native let transformOutputs: array<animSimpleBounceTransformOutput>;
  native let trackOutputs: array<animSimpleBounceTrackOutput>;
}

public native class animAnimNode_SimpleSpline extends animAnimNode_OnePoseInput {
  native let areSourceChannelsResaved: Bool;
  native let startTransform: animTransformIndex;
  native let middleTransform: animTransformIndex;
  native let endTransform: animTransformIndex;
  native let constrainedTransform: animTransformIndex;
  native let progressMode: animConstraintWeightMode;
  native let defaultProgress: Float;
  native let progressTrack: animNamedTrackIndex;
}

public native class animAnimNode_SkAnim extends animAnimNode_Base {
  native let animation: CName;
  native let applyMotion: Bool;
  native let isLooped: Bool;
  native let resume: Bool;
  native let collectEvents: Bool;
  native let fireAnimLoopEvent: Bool;
  native let animLoopEventName: CName;
  native let clipFront: Float;
  native let clipEnd: Float;
  native let clipFrontByEvent: CName;
  native let clipEndByEvent: CName;
  native let pushDataByTag: CName;
  native let popDataByTag: CName;
  native let pushSafeCutTag: CName;
  native let convertToAdditive: Bool;
  native let motionProvider: ref<animIMotionTableProvider>;
  native let applyInertializationOnAnimSetSwap: Bool;
}

public native class animAnimNode_SkAnimAdjuster extends animAnimNode_SkAnim {
  native let targetPositionWs: animVectorLink;
  native let targetDirectionWs: animVectorLink;
  native let initialForwardVector: Vector4;
  native let startAdjustmentEventName: CName;
  native let endAdjustmentEventName: CName;
}

public native class animAnimNode_SkAnimContinue extends animAnimNode_SkAnim {
  native let Input: animPoseLink;
  native let popSafeCutTag: CName;
}

public native class animAnimNode_SkAnimDecorator extends animAnimNode_SkAnim {
  native let Fallback: animPoseLink;
}

public native class animAnimNode_SkAnimSlot extends animAnimNode_SkAnim {
  native let forFacialIdle: Bool;
}

public native class animAnimNode_SkDurationAnim extends animAnimNode_SkAnim {
  native let Duration: animFloatLink;
}

public native class animAnimNode_SkFrameAnim extends animAnimNode_SkAnim {
  native let progressLink: animFloatLink;
  native let timeLink: animFloatLink;
  native let frameLink: animFloatLink;
  native let fireAnimEndOnceOnAnimEnd: Bool;
}

public native class animAnimNode_SkFrameAnimByTrack extends animAnimNode_SkFrameAnim {
  native let progressFloatTrack: animNamedTrackIndex;
  native let timeFloatTrack: animNamedTrackIndex;
  native let frameFloatTrack: animNamedTrackIndex;
  native let inputWithTracks: animPoseLink;
}

public native class animAnimNode_SkipConsoleBegin extends animAnimNode_OnePoseInput {}

public native class animAnimNode_SkipConsoleEnd extends animAnimNode_Base {
  native let inputLink: animPoseLink;
}

public native class animAnimNode_SkipPerformanceModeBegin extends animAnimNode_OnePoseInput {}

public native class animAnimNode_SkipPerformanceModeEnd extends animAnimNode_Base {
  native let inputLink: animPoseLink;
}

public native class animAnimNode_SkOneShotAnim extends animAnimNode_SkAnim {
  native let Input: animPoseLink;
  native let blendIn: Float;
  native let blendOut: Float;
}

public native class animAnimNode_SkPhaseAnim extends animAnimNode_SkAnim {
  native let phase: CName;
}

public native class animAnimNode_SkPhaseSlotWithDurationAnim extends animAnimNode_SkPhaseWithDurationAnim {
  native let animFeatureName: CName;
  native let actionAnimDatabaseRef: ResourceRef; // rRef<animActionAnimDatabase>
}

public native class animAnimNode_SkPhaseWithDurationAnim extends animAnimNode_SkPhaseAnim {
  native let durationLink: animFloatLink;
}

public native class animAnimNode_SkPhaseWithSpeedAnim extends animAnimNode_SkPhaseAnim {
  native let speedLink: animFloatLink;
}

public native class animAnimNode_SkSpeedAnim extends animAnimNode_SkAnim {
  native let Speed: animFloatLink;
}

public native class animAnimNode_SkSyncedMasterAnim extends animAnimNode_SkSpeedAnim {
  native let syncTag: CName;
}

public native class animAnimNode_SkSyncedMasterAnimByTime extends animAnimNode_SkFrameAnim {
  native let syncTag: CName;
}

public native class animAnimNode_SkSyncedSlaveAnim extends animAnimNode_SkAnim {
  native let syncTag: CName;
}

public native class animAnimNode_SpringDamp extends animAnimNode_FloatValue {
  native let massFactor: Float;
  native let springFactor: Float;
  native let dampFactor: Float;
  native let startFromDefaultValue: Bool;
  native let defaultInitialValue: Float;
  native let wrapAroundRange: Bool;
  native let rangeMin: Float;
  native let rangeMax: Float;
  native let timeStep: Float;
  native let inputNode: animFloatLink;
}

public native class animAnimNode_StackTracksExtender extends animAnimNode_OnePoseInput {
  native let tag: CName;
  native let newTracks: array<animFloatTrackInfo>;
}

public native class animAnimNode_StackTracksShrinker extends animAnimNode_OnePoseInput {
  native let tag: CName;
}

public native class animAnimNode_StackTransformsExtender extends animAnimNode_OnePoseInput {
  native let tag: CName;
  native let transformInfos: array<animTransformInfo>;
  native let snapMethods: array<animStackTransformsExtender_SnapToBoneMethod>;
  native let snapToReferenceValues: array<Bool>;
  native let snapTargetBones: array<animTransformIndex>;
  native let offsetToReferenceValues: array<Bool>;
  native let offsetSpaceBones: array<animTransformIndex>;
  native let offsets: array<QsTransform>;
}

public native class animAnimNode_StackTransformsShrinker extends animAnimNode_OnePoseInput {
  native let tag: CName;
}

public native class animAnimNode_Stage extends animAnimNode_Container {
  native let inputPoses: array<animPoseLink>;
}

public native class animAnimNode_StageFloatEntry extends animAnimNode_FloatValue {}

public native class animAnimNode_StagePoseEntry extends animAnimNode_Base {
  native let inputName: CName;
  native let parentInput: animPoseLink;
}

public native class animAnimNode_State extends animAnimNode_Container {
  native let name: CName;
  native let outTransitionIndices: array<Int16>;
  native let preventTransitionsInActivationFrame: Bool;
  native let tags: array<CName>;
  native let requiredQualityDistanceCategory: Uint32;
}

public native class animAnimNode_StateFrozen extends animAnimNode_State {}

public native class animAnimNode_StateMachine extends animAnimNode_Base {
  native let states: array<ref<animAnimNode_State>>;
  native let frozenState: ref<animAnimNode_StateFrozen>;
  native let transitions: array<ref<animAnimStateTransitionDescription>>;
  native let conditionalEntries: array<ref<animAnimStateMachineConditionalEntry>>;
  native let globalTransitions: array<ref<animAnimStateTransitionDescription>>;
  native let anyStateInterpolator: ref<animIAnimStateTransitionInterpolator>;
  native let defaultStateIndex: Uint32;
  native let notifyOnEnterState: Bool;
}

public native class animAnimNode_StaticSwitch extends animAnimNode_MotionTableSwitch {
  native let condition: ref<animIStaticCondition>;
  native let motionProvider: ref<animIMotionTableProvider>;
  native let True: animPoseLink;
  native let False: animPoseLink;
}

public native class animAnimNode_SuspensionLimit extends animAnimNode_OnePoseInput {
  native let constrainedTransform: animTransformIndex;
  native let radiusTrack: animNamedTrackIndex;
  native let deviationTrack: animNamedTrackIndex;
  native let axis: animAxis;
}

public native class animAnimNode_Switch extends animAnimNode_MotionTableSwitch {
  native let numInputs: Uint32;
  native let blendTime: Float;
  native let timeWarpingEnabled: Bool;
  native let syncMethod: ref<animISyncMethod>;
  native let motionProvider: ref<animIMotionTableProvider>;
  native let weightNode: animFloatLink;
  native let inputNodes: array<animPoseLink>;
  native let pushDataByTag: CName;
  native let canRequestInertialization: Bool;
}

public native class animAnimNode_TagSwitch extends animAnimNode_BaseSwitch {
  native let tags: array<CName>;
}

public native class animAnimNode_TagValue extends animAnimNode_FloatValue {
  native let tag: CName;
  native let defaultValue: Float;
  native let oneMinus: Bool;
}

public native class animAnimNode_Timer extends animAnimNode_FloatValue {}

public native class animAnimNode_TrackSetter extends animAnimNode_OnePoseInput {
  native let track: animNamedTrackIndex;
  native let value: animFloatLink;
}

public native class animAnimNode_TrajectoryFromMetaPose extends animAnimNode_OnePoseInput {
  native let metaPoseTrajectoryLs: animTransformIndex;
}

public native class animAnimNode_TransformConstant extends animAnimNode_TransformValue {
  native let pos: Vector4;
  native let rotation: Quaternion;
  native let scale: Vector4;
}

public native class animAnimNode_TransformInterpolation extends animAnimNode_TransformValue {
  native let interpolationType: animQuaternionInterpolationType;
  native let firstInput: animTransformLink;
  native let secondInput: animTransformLink;
  native let weight: animFloatLink;
}

public native class animAnimNode_TransformJoin extends animAnimNode_TransformValue {
  native let input: animTransformLink;
}

public native class animAnimNode_TransformLatch extends animAnimNode_TransformValue {
  native let input: animTransformLink;
}

public native class animAnimNode_TransformRotator extends animAnimNode_OnePoseInput {
  native let transform: animTransformIndex;
  native let axis: Vector3;
  native let valueScale: Float;
  native let clamp: Bool;
  native let angleMin: Float;
  native let angleMax: Float;
  native let angleValueNode: animFloatLink;
  native let angleSpeedNode: animFloatLink;
}

public native class animAnimNode_TransformToTrack extends animAnimNode_OnePoseInput {
  native let floatTrack: Int32;
  native let floatTrackIndex: animNamedTrackIndex;
  native let outputTransform: Int16;
  native let transformIndex: animTransformIndex;
  native let channel: animTransformChannel;
  native let mulFactor: Float;
  native let weight: Float;
  native let weightNode: animFloatLink;
  native let mulFactorNode: animFloatLink;
}

public abstract native class animAnimNode_TransformValue extends animAnimNode_Base {}

public native class animAnimNode_TransformVariable extends animAnimNode_TransformValue {
  native let variableName: CName;
}

public native class animAnimNode_TranslateBone extends animAnimNode_Base {
  native let inputNode: animPoseLink;
  native let inputTranslation: animVectorLink;
  native let scale: Vector4;
  native let biasValue: Vector4;
  native let bone: animTransformIndex;
  native let useIncrementalMode: Bool;
  native let resetOnActivation: Bool;
}

public native class animAnimNode_TranslationLimit extends animAnimNode_OnePoseInput {
  native let constrainedTransform: animTransformIndex;
  native let parentTransform: animTransformIndex;
  native let limitOnXAxis: animFloatClamp;
  native let limitOnYAxis: animFloatClamp;
  native let limitOnZAxis: animFloatClamp;
}

public native class animAnimNode_TriggerBranch extends animAnimNode_Base {
  native let base: animPoseLink;
  native let overlay: animPoseLink;
  native let blendIn: Float;
  native let blendOut: Float;
  native let startEvent: CName;
  native let endEvent: CName;
  native let cooldown: Float;
}

public native class animAnimNode_TwistConstraint extends animAnimNode_OnePoseInput {
  native let frontAxis: animAxis;
  native let transformA: animTransformIndex;
  native let transformB: animTransformIndex;
  native let outputs: array<animTwistOutput>;
  native let debug: Bool;
}

public native class animAnimNode_ValueBySpeed extends animAnimNode_FloatValue {
  native let defaultValue: Float;
  native let clampType: animClampType;
  native let rangeMin: Float;
  native let rangeMax: Float;
  native let resetOnActivation: Bool;
  native let speed: animFloatLink;
}

public native class animAnimNode_VectorConstant extends animAnimNode_VectorValue {
  native let value: Vector4;
}

public native class animAnimNode_VectorInput extends animAnimNode_VectorValue {
  native let group: CName;
  native let name: CName;
}

public native class animAnimNode_VectorInterpolation extends animAnimNode_VectorValue {
  native let firstInput: animVectorLink;
  native let secondInput: animVectorLink;
  native let weight: animFloatLink;
}

public native class animAnimNode_VectorJoin extends animAnimNode_VectorValue {
  native let input: animVectorLink;
}

public native class animAnimNode_VectorLatch extends animAnimNode_VectorValue {
  native let input: animVectorLink;
}

public abstract native class animAnimNode_VectorValue extends animAnimNode_Base {}

public native class animAnimNode_VectorVariable extends animAnimNode_VectorValue {
  native let variableName: CName;
}

public native class animAnimNode_VectorWsToMs extends animAnimNode_VectorValue {
  native let type: animEVectorWsToMsType;
  native let vectorWs: animVectorLink;
}

public native class animAnimNode_WorkspotAnim extends animAnimNode_Base {
  native let collectEvents: Bool;
  native let inputLink: animPoseLink;
}

public native class animAnimNode_WorkspotHub extends animAnimNode_Base {
  native let additionalLinkIds: array<WorkEntryId>;
  native let additionalLinks: array<animPoseLink>;
  native let animLoopEventName: CName;
  native let isCoverHubHack: Bool;
  native let eventFilterType: animEventFilterType;
  native let mainEmotionalState: CName;
  native let emotionalExpression: CName;
  native let facialKeyWeight: Float;
  native let facialIdleMaleAnimation: CName;
  native let facialIdleKey_MaleAnimation: CName;
  native let facialIdleFemaleAnimation: CName;
  native let facialIdleKey_FemaleAnimation: CName;
}

public native class animAnimNode_WrapperValue extends animAnimNode_FloatValue {
  native let wrapperNames: array<CName>;
  native let logicOp: animEAnimGraphLogicOp;
  native let oneMinus: Bool;
}

public native class animAnimNodeDebugState extends ISerializable {
  native let nodeId: Uint32;
  native let active: Bool;
}

public native class animAnimNodeSourceChannel_AnimFeatureQsTransform extends animIAnimNodeSourceChannel_QsTransform {}

public native class animAnimNodeSourceChannel_AnimFeatureQuat extends animIAnimNodeSourceChannel_Quat {}

public native class animAnimNodeSourceChannel_AnimFeatureVector extends animIAnimNodeSourceChannel_Vector {}

public native class animAnimNodeSourceChannel_FloatTrack extends animIAnimNodeSourceChannel_Float {
  native let floatTrack: animNamedTrackIndex;
  native let useComplementValue: Bool;
}

public native class animAnimNodeSourceChannel_OrientationVector extends animIAnimNodeSourceChannel_Vector {
  native let transformIndex: animTransformIndex;
  native let inputTransformIndex: animTransformIndex;
  native let up: Vector3;
}

public native class animAnimNodeSourceChannel_ReferenceTransformVector extends animIAnimNodeSourceChannel_Vector {
  native let transformIndex: animTransformIndex;
}

public native class animAnimNodeSourceChannel_SocketQsTransform extends animIAnimNodeSourceChannel_QsTransform {}

public native class animAnimNodeSourceChannel_SocketQuat extends animIAnimNodeSourceChannel_Quat {}

public native class animAnimNodeSourceChannel_SocketVector extends animIAnimNodeSourceChannel_Vector {}

public native class animAnimNodeSourceChannel_StaticQsTransform extends animIAnimNodeSourceChannel_QsTransform {
  native let data: QsTransform;
}

public native class animAnimNodeSourceChannel_StaticQuat extends animIAnimNodeSourceChannel_Quat {
  native let data: Quaternion;
}

public native class animAnimNodeSourceChannel_StaticVector extends animIAnimNodeSourceChannel_Vector {
  native let data: Vector4;
}

public native class animAnimNodeSourceChannel_TransformQsTransform extends animIAnimNodeSourceChannel_QsTransform {
  native let transformIndex: animTransformIndex;
}

public native class animAnimNodeSourceChannel_TransformQuat extends animIAnimNodeSourceChannel_Quat {
  native let transformIndex: animTransformIndex;
}

public native class animAnimNodeSourceChannel_TransformVector extends animIAnimNodeSourceChannel_Vector {
  native let transformIndex: animTransformIndex;
}

public native class animAnimNodeSourceChannel_WeightedQsTransform extends ISerializable {
  native let channel: ref<animIAnimNodeSourceChannel_QsTransform>;
  native let weight: Float;
}

public native class animAnimNodeSourceChannel_WeightedQuat extends ISerializable {
  native let channel: ref<animIAnimNodeSourceChannel_Quat>;
  native let weight: Float;
  native let weightLink: animFloatLink;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimNodeSourceChannel_WeightedVector extends ISerializable {
  native let channel: ref<animIAnimNodeSourceChannel_Vector>;
  native let weight: Float;
  native let weightLink: animFloatLink;
  native let weightFloatTrack: animNamedTrackIndex;
}

public native class animAnimProfileData_RootItem extends ISerializable {
  native let timeMS: Float;
  native let children: array<ref<animAnimProfilerData_TreeItem>>;
}

public native struct animAnimProfilerData_SectionTimings {
  native let sectionName: CName;
  native let updateTimeMS: Float;
  native let sampleTimeMS: Float;
}

public native struct animAnimProfilerData_Timings {
  native let className: CName;
  native let avarageExclusiveTimeMS: Float;
  native let avarageInclusiveTimeMS: Float;
}

public native struct animAnimProfilerData_TimingsDetailed {
  native let className: CName;
  native let avarageExclusiveUpdateTimeMS: Float;
  native let avarageInclusiveUpdateTimeMS: Float;
  native let avarageExclusiveSampleTimeMS: Float;
  native let avarageInclusiveSampleTimeMS: Float;
  native let totalExclusiveUpdateTimeMS: Float;
  native let totalInclusiveUpdateTimeMS: Float;
  native let totalExclusiveSampleTimeMS: Float;
  native let totalInclusiveSampleTimeMS: Float;
  native let updatesCount: Uint32;
  native let samplesCount: Uint32;
}

public native class animAnimProfilerData_TimingsDetailedRoot extends ISerializable {
  native let sections: array<animAnimProfilerData_SectionTimings>;
  native let timings: array<animAnimProfilerData_TimingsDetailed>;
}

public native class animAnimProfilerData_TimingsRoot extends ISerializable {
  native let timings: array<animAnimProfilerData_Timings>;
}

public native class animAnimProfilerData_TreeItem extends ISerializable {
  native let className: CName;
  native let exclusiveTimeMS: Float;
  native let inclusiveTimeMS: Float;
  native let children: array<ref<animAnimProfilerData_TreeItem>>;
}

public native class animAnimSet extends CResource {
  native let animations: array<ref<animAnimSetEntry>>;
  native let animationDataChunks: array<animAnimDataChunk>;
  native let fallbackDataAddresses: array<Uint16>;
  native let fallbackDataAddressIndexes: array<Uint8>;
  native let fallbackAnimFrameDescs: array<animAnimFallbackFrameDesc>;
  native let fallbackAnimDescIndexes: array<Uint8>;
  native let fallbackNumPositionData: Uint16;
  native let fallbackNumRotationData: Uint16;
  native let fallbackNumFloatTrackData: Uint16;
  native let rig: ResourceRef; // rRef<animRig>
  native let tags: redTagList;
  native let version: Uint32;
}

public native struct animAnimSetCollection {
  native let animSets: array<ResourceAsyncRef>;
  native let overrideAnimSets: array<animOverrideAnimSetRef>;
  native let animWrapperVariables: array<animAnimWrapperVariableDescription>;
}

public native class animAnimSetEntry extends ISerializable {
  native let animation: ref<animAnimation>;
  native let events: ref<animEventsContainer>;
}

public native class animAnimSetEntryAudioData extends ISerializable {
  native let events: array<ref<animAnimEvent>>;
}

public native struct animAnimSetup {
  native let cinematics: array<animAnimSetupEntry>;
  native let gameplay: array<animAnimSetupEntry>;
  native let hash: Uint64;
}

public native struct animAnimSetupEntry {
  native let priority: Uint8;
  native let animSet: ResourceAsyncRef; // raRef<animAnimSet>
  native let variableNames: array<CName>;
}

public native class animAnimSetupResource extends CResource {
  native let dependencies: array<ResourceRef>;
}

public native class animAnimsetVariableCondition extends animIRuntimeCondition {
  native let variableToCompare: CName;
}

public native class animAnimsetWithOverridesTagCondition extends animIRuntimeCondition {
  native let animsetTags: redTagList;
}

enum animAnimStateInterpolationType {
  Linear = 0,
  EaseIn = 1,
  EaseOut = 2,
  EaseInOut = 3,
}

public native class animAnimStateMachineConditionalEntry extends ISerializable {
  native let targetStateIndex: Uint32;
  native let condition: ref<animIAnimStateTransitionCondition>;
  native let isEnabled: Bool;
  native let priority: Int32;
  native let isForcedToTrue: Bool;
}

public native class animAnimStateTransitionCondition_AnimEnd extends animIAnimStateTransitionCondition {
  native let eventName: CName;
}

public native class animAnimStateTransitionCondition_AnimEvent extends animIAnimStateTransitionCondition {
  native let eventName: CName;
}

public native class animAnimStateTransitionCondition_AnyAnimEnd extends animIAnimStateTransitionCondition {}

public native class animAnimStateTransitionCondition_BoolEdgeFeature extends animIAnimStateTransitionCondition {
  native let featureName: CName;
  native let featurePropertyName: CName;
}

public native class animAnimStateTransitionCondition_BoolFeature extends animIAnimStateTransitionCondition {
  native let compareValue: Bool;
  native let featureName: CName;
  native let featurePropertyName: CName;
}

public native class animAnimStateTransitionCondition_BoolVariable extends animIAnimStateTransitionCondition {
  native let variableName: CName;
  native let compareValue: Bool;
}

public native class animAnimStateTransitionCondition_CompositeSimultaneous extends animIAnimStateTransitionCondition {
  native let conditions: array<ref<animIAnimStateTransitionCondition>>;
}

public native class animAnimStateTransitionCondition_ExternalEvent extends animIAnimStateTransitionCondition {
  native let eventName: CName;
}

public native class animAnimStateTransitionCondition_FloatFeature extends animIAnimStateTransitionCondition {
  native let compareValue: Float;
  native let featureName: CName;
  native let featurePropertyName: CName;
  native let compareFunc: animCompareFunc;
}

public native class animAnimStateTransitionCondition_FloatVariable extends animIAnimStateTransitionCondition {
  native let variableName: CName;
  native let compareValue: Float;
  native let compareFunc: animCompareFunc;
}

public native class animAnimStateTransitionCondition_FootPhaseEvent extends animIAnimStateTransitionCondition {
  native let footPhase: animEFootPhase;
}

public native class animAnimStateTransitionCondition_HasAnimation extends animIAnimStateTransitionCondition {
  native let animationName: CName;
}

public native class animAnimStateTransitionCondition_IntEdgeFeature extends animIAnimStateTransitionCondition {
  native let featureName: CName;
  native let featurePropertyName: CName;
}

public native class animAnimStateTransitionCondition_IntEdgeFromToFeature extends animAnimStateTransitionCondition_IntEdgeFeature {
  native let fromValue: Int32;
  native let toValue: Int32;
}

public native class animAnimStateTransitionCondition_IntEdgeGreaterFromZeroFeature extends animAnimStateTransitionCondition_IntEdgeFeature {
  native let greaterThenValue: Int32;
}

public native class animAnimStateTransitionCondition_IntEdgeToFeature extends animAnimStateTransitionCondition_IntEdgeFeature {
  native let toValue: Int32;
}

public native class animAnimStateTransitionCondition_IntFeature extends animIAnimStateTransitionCondition {
  native let compareValue: Int32;
  native let featureName: CName;
  native let featurePropertyName: CName;
  native let compareFunc: animCompareFunc;
}

public native class animAnimStateTransitionCondition_IntVariable extends animIAnimStateTransitionCondition {
  native let variableName: CName;
  native let compareValue: Int32;
  native let compareFunc: animCompareFunc;
}

public native class animAnimStateTransitionCondition_ModifiedFloatVariable extends animIAnimStateTransitionCondition {
  native let variableName: CName;
  native let compareValue: Float;
  native let compareFunc: animCompareFunc;
}

public native class animAnimStateTransitionCondition_Timed extends animIAnimStateTransitionCondition {
  native let timeToFireTransition: Float;
}

public native class animAnimStateTransitionCondition_WrapperValue extends animIAnimStateTransitionCondition {
  native let wrapperName: CName;
  native let checkIfWrapperIsSet: Bool;
}

public native class animAnimStateTransitionDescription extends ISerializable {
  native let targetStateIndex: Uint32;
  native let condition: ref<animIAnimStateTransitionCondition>;
  native let isEnabled: Bool;
  native let interpolator: ref<animIAnimStateTransitionInterpolator>;
  native let duration: Float;
  native let priority: Int32;
  native let syncMethod: ref<animISyncMethod>;
  native let isForcedToTrue: Bool;
  native let supportBlendFromPose: Bool;
  native let canRequestInertialization: Bool;
  native let animFeatureName: CName;
  native let actionAnimDatabaseRef: ResourceRef; // rRef<animActionAnimDatabase>
  native let isOutTransitionFromAction: Bool;
}

public native class animAnimStateTransitionInterpolator_Blend extends animIAnimStateTransitionInterpolator {
  native let interpolationType: animAnimStateInterpolationType;
}

public native struct animAnimTransformMappingEntry {
  native let from: CName;
  native let to: CName;
}

public abstract native class animAnimVariable extends ISerializable {
  native let name: CName;
}

public native class animAnimVariableBool extends animAnimVariable {
  native let value: Bool;
  native let default: Bool;
}

public native class animAnimVariableContainer extends ISerializable {
  native let boolVariables: array<ref<animAnimVariableBool>>;
  native let intVariables: array<ref<animAnimVariableInt>>;
  native let floatVariables: array<ref<animAnimVariableFloat>>;
  native let vectorVariables: array<ref<animAnimVariableVector>>;
  native let quaternionVariables: array<ref<animAnimVariableQuaternion>>;
  native let transformVariables: array<ref<animAnimVariableTransform>>;
}

public native class animAnimVariableFloat extends animAnimVariable {
  native let value: Float;
  native let default: Float;
  native let min: Float;
  native let max: Float;
}

public native class animAnimVariableInt extends animAnimVariable {
  native let value: Int32;
  native let default: Int32;
  native let min: Int32;
  native let max: Int32;
}

public native class animAnimVariableQuaternion extends animAnimVariable {
  native let roll: Float;
  native let pitch: Float;
  native let yaw: Float;
  native let default: Quaternion;
}

public native class animAnimVariableTransform extends animAnimVariable {
  native let value: QsTransform;
  native let default: QsTransform;
}

public native class animAnimVariableVector extends animAnimVariable {
  native let x: Float;
  native let y: Float;
  native let z: Float;
  native let w: Float;
  native let default: Vector4;
  native let min: Vector4;
  native let max: Vector4;
}

public native struct animAnimWrapperVariableDescription {
  native let variableName: CName;
  native let defaultValue: Float;
}

enum animAxis {
  X = 0,
  Y = 1,
  Z = 2,
  NegativeX = 3,
  NegativeY = 4,
  NegativeZ = 5,
}

public native struct animBoneCorrection {
  native let boneName: CName;
  native let additiveCorrection: Quaternion;
}

public native class animBoneTraceCondition extends ISerializable {
  native let boneIndex: Int16;
  native let traceByRotation: Bool;
  native let rotationAngleTolerance: Float;
  native let traceByTranslation: Bool;
  native let translationTolerance: Float;
}

public native struct animBoolLink {
  native let node: wref<animAnimNode_BoolValue>;
}

public native class animCAnimationBufferBitwiseCompressed extends animIAnimationBuffer {
  native let version: Uint32;
  native let bones: array<animSAnimationBufferBitwiseCompressedBoneTrack>;
  native let tracks: array<animSAnimationBufferBitwiseCompressedData>;
  native let data: array<Int8>;
  native let fallbackData: array<Int8>;
  native let orientationCompressionMethod: SAnimationBufferOrientationCompressionMethod;
  native let duration: Float;
  native let numFrames: Uint32;
  native let dt: Float;
  native let streamingOption: SAnimationBufferStreamingOption;
  native let nonStreamableBones: Uint32;
  native let extraDataNames: array<CName>;
  native let numExtraBones: Uint32;
}

public native class animCAnimationBufferUncompressed extends animIAnimationBuffer {
  native let transforms: array<array<QsTransform>>;
  native let tracks: array<array<Float>>;
  native let duration: Float;
}

enum animClampType {
  None = 0,
  Clamp = 1,
  WrappedClamp = 2,
}

public native struct animCollisionRoundedShape {
  native let bone: animTransformIndex;
  native let transformLS: QsTransform;
  native let roundedCornerRadius: Float;
  native let xBoxExtent: Float;
  native let yBoxExtent: Float;
  native let zBoxExtent: Float;
}

public native class animCollisionShapesCollection extends ISerializable {
  native let collisionRoundedShapes: array<animCollisionRoundedShape>;
}

public native struct animCompareBone {
  native let boneName: CName;
  native let boneRotationLs: Quaternion;
}

enum animCompareFunc {
  Equal = 0,
  NotEqual = 1,
  Less = 2,
  LessEqual = 3,
  Greater = 4,
  GreaterEqual = 5,
}

public native class animComponentTagCondition extends animIStaticCondition {
  native let animTag: CName;
}

enum animcompressionBufferTypePreset {
  Spline = 0,
  SIMD = 1,
  TestRaw = 2,
}

enum animcompressionFrameratePreset {
  USE_30_HZ = 0,
  USE_15_HZ = 1,
  USE_10_HZ = 2,
}

enum animcompressionQualityPreset {
  CINEMATIC_HIGH = 3,
  HIGH = 0,
  MID = 1,
  LOW = 2,
}

public native struct animConditionalSegmentCondition {
  native let lod: Int32;
  native let group: CName;
  native let name: CName;
  native let animFeatureValue: Bool;
}

enum animConstraintWeightMode {
  Static = 0,
  FloatTrack = 1,
}

public native struct animCorrectivePoseEntry {
  native let comparePose: CName;
  native let correctivePose: CName;
  native let jointsToCompare: array<CName>;
  native let enabled: Bool;
}

enum animCoverBehavior {
  Idle = 0,
  PreAction = 1,
  DoAction = 2,
  PostAction = 3,
}

enum animCoverStance {
  None = 0,
  LowLeft = 1,
  HighLeft = 2,
  LowRight = 3,
  HighRight = 4,
}

public native struct animCurvePathAnimControllerPreset {
  native let name: CName;
  native let leftAnimationName: CName;
  native let forwardAnimationName: CName;
  native let rightAnimationName: CName;
}

public native struct animCurvePathBakerAdvancedUserInput {}

public native struct animCurvePathBakerUserInput {
  native let controllersSetupName: CName;
  native let useStart: Bool;
  native let useStop: Bool;
  native let blendTime: Float;
}

public native struct animCurvePathControllersSetup {
  native let name: CName;
  native let startControllerName: CName;
  native let mainControllerName: CName;
  native let stopControllerName: CName;
}

public native struct animCurvePathPartInput {
  native let curveLengthStart: Float;
  native let curveLengthEnd: Float;
  native let controllerName: CName;
  native let eventNameStart: CName;
  native let eventNameEnd: CName;
  native let startBlendTime: Float;
}

public abstract native class animDangleConstraint_Simulation extends ISerializable {
  native let collisionRoundedShapes: array<animCollisionRoundedShape>;
  native let jsonCollisionShapes: ResourceRef; // rRef<JsonResource>
  native let jsonCollisionShapesLoadedSuccessfully: Bool;
  native let alpha: Float;
  native let rotateParentToLookAtDangle: Bool;
  native let parentRotationAltersTransformsOfDangleAndItsChildren: Bool;
  native let parentRotationAltersTransformsOfNonDanglesAndItsChildren: Bool;
  native let dangleAltersTransformsOfItsChildren: Bool;
}

public native class animDangleConstraint_SimulationDyng extends animDangleConstraint_Simulation {
  native let HACK_checkDangleTeleport: Bool;
  native let substepTime: Float;
  native let solverIterations: Uint32;
  native let particlesContainer: animDyngParticlesContainer;
  native let dyngConstraint: ref<animIDyngConstraint>;
}

public native class animDangleConstraint_SimulationPendulum extends animDangleConstraint_SimulationSingleBone {
  native let constraintType: animPendulumConstraintType;
  native let halfOfMaxApertureAngle: Float;
  native let mass: Float;
  native let damping: Float;
  native let pullForceFactor: Float;
  native let pullForceDirectionLS: Vector3;
  native let externalForceWS: Vector3;
  native let externalForceWsLink: animVectorLink;
  native let collisionCapsuleRadius: Float;
  native let collisionCapsuleHeightExtent: Float;
  native let cosOfHalfMaxApertureAngle: Float;
  native let cosOfHalfOfHalfMaxApertureAngle: Float;
  native let sinOfHalfOfHalfMaxApertureAngle: Float;
  native let invertedMass: Float;
  native let simulationFps: Float;
  native let gravityWS: Float;
  native let projectionType: animPendulumProjectionType;
  native let constraintOrientation: Vector3;
  native let cosOfHalfXAngle: Float;
  native let cosOfHalfYAngle: Float;
  native let cosOfHalfZAngle: Float;
  native let sinOfHalfXAngle: Float;
  native let sinOfHalfYAngle: Float;
  native let sinOfHalfZAngle: Float;
}

public native class animDangleConstraint_SimulationPositionProjection extends animDangleConstraint_SimulationSingleBone {
  native let collisionCapsuleRadius: Float;
  native let collisionCapsuleHeightExtent: Float;
  native let collisionCapsuleAxisLS: Vector3;
  native let directionReferenceBone: animTransformIndex;
  native let projectionType: animPositionProjectionType;
}

public abstract native class animDangleConstraint_SimulationSingleBone extends animDangleConstraint_Simulation {
  native let dangleBone: animTransformIndex;
}

public native class animDangleConstraint_SimulationSpring extends animDangleConstraint_SimulationSingleBone {
  native let constraintSphereRadius: Float;
  native let constraintScale1: Float;
  native let constraintScale2: Float;
  native let mass: Float;
  native let damping: Float;
  native let pullForceFactor: Float;
  native let externalForceWS: Vector3;
  native let externalForceWsLink: animVectorLink;
  native let collisionSphereRadius: Float;
  native let invertedMass: Float;
  native let simulationFps: Float;
  native let gravityWS: Float;
  native let pullForceOriginLS: Vector3;
  native let projectionType: animSpringProjectionType;
  native let constraintOrientation: Vector2;
  native let cosOfHalfXAngle: Float;
  native let cosOfHalfYAngle: Float;
  native let sinOfHalfXAngle: Float;
  native let sinOfHalfYAngle: Float;
}

public native class AnimDataChanged extends Event {}

public native class AnimDurationFeature extends AnimFeature {
  native let duration: Float;
}

public native class animDyngConstraintCone extends animIDyngConstraint {
  native let constrainedBone: animTransformIndex;
  native let coneAttachmentBone: animTransformIndex;
  native let coneTransformLS: QsTransform;
  native let constraintType: animPendulumConstraintType;
  native let halfOfMaxApertureAngle: Float;
  native let projectionType: animPendulumProjectionType;
  native let collisionCapsuleRadius: Float;
  native let collisionCapsuleHeightExtent: Float;
}

public native class animDyngConstraintEllipsoid extends animIDyngConstraint {
  native let bone: animTransformIndex;
  native let ellipsoidTransformLS: QsTransform;
  native let constraintRadius: Float;
  native let constraintScale1: Float;
  native let constraintScale2: Float;
}

public native class animDyngConstraintLink extends animIDyngConstraint {
  native let bone1: animTransformIndex;
  native let bone2: animTransformIndex;
  native let linkType: animDyngConstraintLinkType;
  native let lengthLowerBoundRatioPercentage: Float;
  native let lengthUpperBoundRatioPercentage: Float;
  native let lookAtAxis: Vector3;
}

enum animDyngConstraintLinkType {
  KeepFixedDistance = 0,
  KeepVariableDistance = 1,
  Greater = 2,
  Closer = 3,
}

public native class animDyngConstraintMulti extends animIDyngConstraint {
  native let innerConstraints: array<ref<animIDyngConstraint>>;
}

public native struct animDyngParticle {
  native let mass: Float;
  native let damping: Float;
  native let pullForceFactor: Float;
  native let isFree: Bool;
  native let bone: animTransformIndex;
  native let collisionCapsuleRadius: Float;
  native let collisionCapsuleHeightExtent: Float;
  native let collisionCapsuleAxisLS: Vector3;
  native let projectionType: animDyngParticleProjectionType;
}

enum animDyngParticleProjectionType {
  Disabled = 0,
  ShortestPath = 1,
  Directed = 2,
}

public native struct animDyngParticlesContainer {
  native let externalForceWS: Vector3;
  native let externalForceWsLink: animVectorLink;
  native let particles: array<animDyngParticle>;
  native let gravityWS: Float;
}

enum animEAnimGraphAdditiveType {
  AGAT_Local = 0,
  AGAT_Ref = 1,
}

enum animEAnimGraphCompareFunc {
  AGCF_Equal = 0,
  AGCF_NotEqual = 1,
  AGCF_Less = 2,
  AGCF_LessEqual = 3,
  AGCF_Greater = 4,
  AGCF_GreaterEqual = 5,
}

enum animEAnimGraphLogicOp {
  AGLO_Or = 0,
  AGLO_And = 1,
}

enum animEAnimGraphMathInterpolation {
  AGMI_LINEAR = 0,
  AGMI_SIN = 1,
  AGMI_BEZIER = 2,
}

enum animEAnimGraphMathOp {
  AGMO_Add = 0,
  AGMO_Subtract = 1,
  AGMO_Multiply = 2,
  AGMO_Divide = 3,
  AGMO_SafeDivide = 4,
  AGMO_ATan = 5,
  AGMO_AngleDiff = 6,
  AGMO_Length = 7,
  AGMO_Abs = 8,
}

enum animEBlendFromPoseMode {
  BFPM_AlwaysOnActivation = 0,
  BFPM_RequestedByTag = 1,
}

enum animEBlendTracksMode {
  AGBT_BasePose = 0,
  AGBT_Interpolate = 1,
  AGBT_Add = 2,
}

enum animEBlendTypeLBC {
  Linear = 0,
  Smoothstep = 1,
  CustomCurve = 2,
}

enum animEDirectionToEuler {
  Pitch = 0,
  Yaw = 1,
  Roll = 2,
}

enum animEFootPhase {
  RightUp = 0,
  RightForward = 1,
  LeftUp = 2,
  LeftForward = 3,
  NotConsidered = 4,
}

enum animEInterpolationType {
  Lerp = 0,
  Slerp = 1,
}

enum animEMotionExtractionCompressionType {
  EMECT_LINEAR = 6,
  EMECT_SPLINE_LOW = 4,
  EMECT_SPLINE_MID = 2,
  EMECT_SPLINE_HIGH = 5,
  EMECT_UNCOMPRESSED = 0,
  EMECT_UNCOMPRESSED_ALL_ANGLES = 3,
  EMECT_UNCOMPRESSED_2D = 7,
  EMECT_UNCOMPRESSED_3D_FALLBACKING = 8,
  EMECT_UNCOMPRESSED_ALL_ANGLES_FALLBACKING = 9,
}

enum animEResetTypeNode {
  RT_Reference = 0,
  RT_Indentity = 1,
}

enum animESpace {
  Local = 0,
  Model = 1,
  World = 2,
}

enum animESpaceMW {
  Model = 0,
  World = 1,
}

enum animETransformAxis {
  X_Axis = 1,
  Y_Axis = 2,
  Z_Axis = 4,
}

enum animEVectorWsToMsType {
  Position = 0,
  Direction = 1,
}

enum animEventFilterType {
  Default = 0,
  AlwaysCollect = 1,
  Solo = 2,
  Mute = 3,
}

public native class animEventsContainer extends ISerializable {
  native let events: array<ref<animAnimEvent>>;
}

enum animEventSide {
  Left = 0,
  Right = 1,
}

public native class animFacialCustomizationSet extends CResource {
  native let baseSetup: ResourceRef; // rRef<animFacialSetup>
  native let targetSetups: array<ResourceAsyncRef>;
  native let targetSetupsTemp: array<animFacialCustomizationTargetEntryTemp>;
  native let numTargets: Uint32;
  native let posesInfo: animFacialSetup_PosesBufferInfo;
  native let jointRegions: array<Uint8>;
  native let usedTransformIndices: array<Uint16>;
  native let numJoints: Uint32;
  native let isCooked: Bool;
}

public native struct animFacialCustomizationTargetEntryTemp {
  native let setup: ResourceAsyncRef; // raRef<animFacialSetup>
  native let targetNames: array<CName>;
}

public native struct animFacialEmotionTransitionBaked {
  native let toIdleMale: CName;
  native let facialKey_Male: CName;
  native let toIdleFemale: CName;
  native let facialKey_Female: CName;
  native let transitionType: animFacialEmotionTransitionType;
  native let transitionDuration: Float;
  native let timeScale: Float;
  native let toIdleWeight: Float;
  native let toIdleNeckWeight: Float;
  native let facialKeyWeight: Float;
  native let customTransitionAnim: CName;
}

public native struct animFacialEmotionTransitionEditData {
  native let toIdleMale: CName;
  native let facialKeyMale: CName;
  native let toIdleFemale: CName;
  native let facialKeyFemale: CName;
  native let transitionType: animFacialEmotionTransitionType;
  native let toIdleWeight: Float;
  native let toIdleNeckWeight: Float;
  native let facialKeyWeight: Float;
  native let customTransitionAnim: CName;
}

enum animFacialEmotionTransitionType {
  Natural = 0,
  Fast = 1,
  Blend = 2,
  Instant = 3,
  Custom = 4,
}

public native struct animFacialSetup_BufferInfo {
  native let tracksMapping: animFacialSetup_TracksMapping;
  native let numLipsyncOverridesIndexMapping: Uint16;
  native let numJointRegions: Uint16;
  native let face: animFacialSetup_OneSermoBufferInfo;
  native let eyes: animFacialSetup_OneSermoBufferInfo;
  native let tongue: animFacialSetup_OneSermoBufferInfo;
}

public native struct animFacialSetup_OneSermoBufferInfo {
  native let numGlobalLimits: Uint16;
  native let numInfluencedPoses: Uint16;
  native let numInfluenceIndices: Uint16;
  native let numUpperLowerFace: Uint16;
  native let numLipsyncPosesSides: Uint16;
  native let numAllCorrectives: Uint16;
  native let numGlobalCorrectiveEntries: Uint16;
  native let numInbetweenCorrectiveEntries: Uint16;
  native let numCorrectiveInfluencedPoses: Uint16;
  native let numCorrectiveInfluenceIndices: Uint16;
  native let numAllMainPoses: Uint16;
  native let numAllMainPosesInbetweens: Uint16;
  native let numAllMainPosesInbetweenScopeMultipliers: Uint16;
  native let numEnvelopesPerTrackMapping: Uint16;
  native let wrinkleStartingIndex: Uint16;
  native let numWrinkles: Uint16;
}

public native struct animFacialSetup_OneSermoPoseBufferInfo {
  native let numMainPoses: Uint16;
  native let numCorrectivePoses: Uint16;
  native let numMainTransforms: Uint32;
  native let numMainScales: Uint32;
  native let numCorrectiveTransforms: Uint32;
  native let numCorrectiveScales: Uint32;
}

public native struct animFacialSetup_PosesBufferInfo {
  native let face: animFacialSetup_OneSermoPoseBufferInfo;
  native let tongue: animFacialSetup_OneSermoPoseBufferInfo;
  native let eyes: animFacialSetup_OneSermoPoseBufferInfo;
}

public native struct animFacialSetup_TracksMapping {
  native let numEnvelopes: Uint16;
  native let numMainPoses: Uint16;
  native let numLipsyncOverrides: Uint16;
  native let numWrinkles: Uint16;
}

public native class animFacialSetup extends CResource {
  native let rig: ResourceRef; // rRef<animRig>
  native let inputRig: ResourceRef; // rRef<animRig>
  native let info: animFacialSetup_BufferInfo;
  native let posesInfo: animFacialSetup_PosesBufferInfo;
  native let usedTransformIndices: array<Uint16>;
  native let useFemaleAnimSet: Bool;
  native let version: Uint32;
}

public native class AnimFeature_Bump extends AnimFeature {
  native let direction: Float;
  native let source: Float;
  native let intensity: Float;
  native let isBumping: Bool;
  native let bumpType: Int32;
}

public native class AnimFeature_Climb extends AnimFeature {
  native let verticalPosition: Vector4;
  native let horizontalPosition: Vector4;
  native let toVerticalTime: Float;
  native let verticalToHorizontalTime: Float;
  native let frontEdgePosition: Vector4;
  native let frontEdgeNormal: Vector4;
  native let yawAngle: Float;
  native let stateLength: Float;
  native let climbType: Int32;
  native let state: Int32;
  public final native func SetFrontEdgeNormal()
  public final native func SetFrontEdgePosition()
  public final native func SetHorizontalPosition()
  public final native func SetVerticalPosition()
  public final native func SetVerticalToHorizontalTime()
}

public native class AnimFeature_DeviceCameraControlled extends AnimFeature {
  native let currentRotation: Vector4;
}

public native class AnimFeature_DroneLocomotion extends AnimFeature {
  native let speed: Float;
  native let angularSpeed: Float;
  native let lookAtAngle: Float;
  native let desiredSpeed: Float;
  native let pathCurvative: Float;
}

public native class AnimFeature_HitReactions extends AnimFeature {
  native let hitDirection: Vector4;
  native let hitIntensity: Float;
  native let hitType: Int32;
  native let hitBodyPart: Int32;
  public final native func Hit()
}

public native class AnimFeature_Ladder extends AnimFeature {
  native let state: Int32;
  native let transitionType: Int32;
  native let distanceFromTop: Float;
  native let entryFromRight: Bool;
}

public native class AnimFeature_Locomotion extends AnimFeature {
  native let action: Int32;
  native let style: Int32;
  native let pathCurvature: Float;
  native let inclineAngle: Float;
  native let groundAngle: Float;
  native let animDeltaZ: Float;
  native let animationPlaybackTime: Float;
  native let footScaleFactor: Float;
  native let directionalStartAngle: Float;
  native let speedProgress: Float;
  native let isOnStairs: Bool;
  native let areAnimWrappersUnlocked: Bool;
}

public native class AnimFeature_Loot extends AnimFeature {
  native let opened: Bool;
  native let transitionDuration: Float;
  public final native func SetOpened()
  public final native func SetTransitionDuration()
}

public native class AnimFeature_PhotomodePoseCategory extends AnimFeature {
  native let poseCategoryIndex: Int32;
}

public native class AnimFeature_PlayerCover extends AnimFeature {
  native let cameraPositionMS: Vector4;
  native let coverState: Int32;
  native let leanAmount: Float;
  native let cameraOffsetAmount: Float;
  native let autoCoverActivationFrame: Bool;
}

public native class AnimFeature_PlayerSpatialAwareness extends AnimFeature {
  native let leftClosestVector: Vector4;
  native let rightClosestVector: Vector4;
  native let upHitPosition: Vector4;
  native let forwardDistance: Float;
  public final native func SetForwardDistance()
  public final native func SetLeftClosestVector()
  public final native func SetRightClosestVector()
  public final native func SetSetUpHitPosition()
}

public native class AnimFeature_Vault extends AnimFeature_Climb {
  native let landPosition: Vector4;
  native let travellingTime: Float;
  native let obstacleDepth: Float;
  public final native func SetObstacleDepth()
  public final native func SetTravellingTime()
  public final native func SetlandPosition()
}

public native class AnimFeature_WallRun extends AnimFeature {
  native let wallOnRightSide: Bool;
  native let wallPosition: Vector4;
  native let wallNormal: Vector4;
  public final native func SetWallOnRightSide()
}

public native class AnimFeaturePlaySlotAnim extends AnimFeature {
  native let slotName: CName;
  native let animationName: CName;
  native let blendInTime: Float;
  native let blendOutTime: Float;
  native let speedMultiplier: Float;
  native let startOffsetRelative: Float;
  native let playAsAdditive: Bool;
  native let enableMotion: Bool;
  native let numberOfLoops: Int32;
  public final native func SetSlotName()
}

public native class AnimFeatureWorkspotExitAnim extends AnimFeature {}

public native class AnimFeatureWorkspotInertializationAnim extends AnimFeature {
  native let duration: Float;
}

public native struct animFloatClamp {
  native let useMin: Bool;
  native let min: Float;
  native let useMax: Bool;
  native let max: Float;
}

public native struct animFloatLink {
  native let node: wref<animAnimNode_FloatValue>;
}

public native struct animFloatTrackInfo {
  native let name: CName;
  native let referenceValue: Float;
}

enum animFloatTrackOperationType {
  Override = 0,
  Multiply = 1,
  Add = 2,
  Subtract = 3,
  SubtractSwapped = 4,
  WeightComplement = 5,
}

public native struct animfssBodyOfflineParams {
  native let HipsTilt: Float;
  native let HipsShift: Float;
  native let LegsPullFactorMin: Float;
  native let LegsPullFactorMax: Float;
  native let LegLengthAdjustment: Float;
  native let LegMaxStretchOffset: Float;
  native let LegMaxStretchAdjustment: Float;
}

public native struct animGenericAnimDatabase_AnimationData {
  native let animationName: CName;
  native let fallbackAnimationName: CName;
  native let streamingContext: CName;
}

public native struct animGenericAnimDatabase_DatabaseRow {
  native let inputValues: array<Int32>;
  native let animationData: animGenericAnimDatabase_AnimationData;
}

public native class animGenericAnimDatabase extends CResource {
  native let rows: array<animGenericAnimDatabase_DatabaseRow>;
}

public native struct AnimGraphResourceContainerEntry {
  native let graphName: CName;
  native let animGraphResource: ResourceRef; // rRef<animAnimGraph>
}

public native struct animGraphSlotCondition {
  native let condition: ref<animIStaticCondition>;
  native let graph: ResourceRef; // rRef<animAnimGraph>
}

public native class animHasAnimationCondition extends animIStaticCondition {
  native let animationName: CName;
}

public native struct animHipsIkRequest {
  native let leftLegIkChain: CName;
  native let rightLegIkChain: CName;
  native let hipsTransformIndex: animTransformIndex;
  native let leftFootTransformIndex: animTransformIndex;
  native let rightFootTransformIndex: animTransformIndex;
}

public abstract native class animIAnimationBuffer extends ISerializable {}

public abstract native struct animIAnimBreakpoint {
  native let enabled: Bool;
}

public abstract native struct animIAnimDebuggerCommand {}

public abstract native class animIAnimNode_PostProcess extends ISerializable {
  native let isEnabled: Bool;
}

public abstract native class animIAnimNodeSourceChannel_Float extends ISerializable {}

public abstract native class animIAnimNodeSourceChannel_QsTransform extends ISerializable {}

public abstract native class animIAnimNodeSourceChannel_Quat extends ISerializable {}

public abstract native class animIAnimNodeSourceChannel_Vector extends ISerializable {}

public abstract native class animIAnimStateTransitionCondition extends ISerializable {}

public abstract native class animIAnimStateTransitionInterpolator extends ISerializable {}

public abstract native class animIDyngConstraint extends ISerializable {}

public native class animIKTargetParams_Add extends ISerializable {}

public native class animIKTargetParams_Remove extends ISerializable {}

public native class animIKTargetParams_Update extends ISerializable {}

public abstract native class animIMotionExtraction extends ISerializable {}

public abstract native class animIMotionTableProvider extends ISerializable {
  native let id: Int32;
  native let parentId: Int32;
  native let type: animMotionTableType;
  native let action: animMotionTableAction;
  native let parentStaticSwitchBranch: animParentStaticSwitchBranch;
}

public native struct animImportFacialCorrectivePoseDataDesc {
  native let transforms: array<animImportFacialTransform>;
  native let transformsNoScale: array<animImportFacialTransformNoScale>;
  native let transformIds: array<Uint16>;
  native let transformNames: array<CName>;
  native let parentsWeights: array<Float>;
}

public native struct animImportFacialCorrectivePoseDesc {
  native let influencedBy: array<CName>;
  native let influenceMainWeightIndices: array<Uint16>;
  native let poses: array<animImportFacialCorrectivePoseDataDesc>;
  native let parentsInBetweenIndices: array<Int16>;
  native let parentIndices: array<Uint16>;
  native let name: CName;
  native let index: Uint16;
  native let influencedBySpeed: Uint8;
  native let poseType: Uint8;
  native let poseLOD: Uint8;
  native let weights: array<Float>;
  native let inBetweenScopeMultipliers: array<Float>;
  native let linearCorrection: Bool;
  native let useGlobalWeight: Bool;
}

public native struct animImportFacialInitialControlsDesc {
  native let transformIds: array<Uint16>;
  native let transformNames: array<CName>;
  native let transformRegions: array<Uint8>;
}

public native struct animImportFacialInitialPoseEntryDesc {
  native let poseName: CName;
  native let id: Int16;
  native let weight: Float;
  native let type: Uint8;
  native let side: Uint8;
  native let isCachable: Bool;
  native let initAnimationPoseMid: Float;
  native let initAnimationPoseMin: Float;
  native let initAnimationPoseMax: Float;
}

public native struct animImportFacialInitialPoseWeightDesc {
  native let poseNames: array<CName>;
  native let weights: array<Float>;
}

public native struct animImportFacialMainPoseDesc {
  native let influencedBy: array<CName>;
  native let influenceMainWeightIndices: array<Uint16>;
  native let poses: array<animImportFacialPoseDesc>;
  native let poseIndices: array<Uint16>;
  native let weights: array<Float>;
  native let inBetweenScopeMultipliers: array<Float>;
  native let name: CName;
  native let index: Uint16;
  native let influenceType: Uint8;
  native let side: Uint8;
  native let facePart: Uint8;
}

public native struct animImportFacialPoseDesc {
  native let transforms: array<animImportFacialTransform>;
  native let transformsNoScale: array<animImportFacialTransformNoScale>;
  native let transformIds: array<Uint16>;
  native let transformNames: array<CName>;
}

public native struct animImportFacialSetupCombinedDesc {
  native let face: animImportFacialSetupDesc;
  native let eyes: animImportFacialSetupDesc;
  native let tongue: animImportFacialSetupDesc;
  native let usedTransformIndices: array<Uint16>;
  native let lipsyncOverrideToMainPosesTracksMapping: array<Int16>;
  native let firstLipsyncOverrideTrackIndex: Int16;
}

public native struct animImportFacialSetupDesc {
  native let initialPose: array<animImportFacialInitialPoseEntryDesc>;
  native let initialControls: animImportFacialInitialControlsDesc;
  native let mainPoses: array<animImportFacialMainPoseDesc>;
  native let mainPosesInfo: array<animSermoPoseInfo>;
  native let jawAreaTrackIndices: array<Int16>;
  native let lipsAreaTrackIndices: array<Int16>;
  native let eyesAreaTrackIndices: array<Int16>;
  native let numCachedPoseTracks: Uint16;
  native let correctivePoses: array<animImportFacialCorrectivePoseDesc>;
  native let globalPoseLimits: array<animPoseLimitWeights>;
  native let wrinkleStartingIndex: Uint16;
  native let wrinkleMapping: array<Uint16>;
}

public native struct animImportFacialTransform {
  native let rotation: Quaternion;
  native let translation: Vector3;
  native let scale: Vector3;
}

public native struct animImportFacialTransformNoScale {
  native let rotation: Quaternion;
  native let translation: Vector3;
}

public native struct animInertializationFloatClamp {
  native let isActive: Bool;
  native let min: Float;
  native let max: Float;
}

public native struct animInertializationRotationLimit {
  native let constrainedTransform: animTransformIndex;
  native let limitOnX: animInertializationFloatClamp;
  native let limitOnY: animInertializationFloatClamp;
  native let limitOnZ: animInertializationFloatClamp;
}

public native class AnimInputSetterQuaternion extends AnimInputSetter {
  native let value: Quaternion;
}

public native struct animIntLink {
  native let node: wref<animAnimNode_IntValue>;
}

public abstract native class animIPoseBlendMethod extends ISerializable {}

public abstract native class animIRigIkSetup extends ISerializable {
  native let name: CName;
}

public abstract native class animIRuntimeCondition extends ISerializable {}

public abstract native class animIStaticCondition extends ISerializable {}

public abstract native class animISyncMethod extends ISerializable {}

enum animLeg {
  Left = 0,
  Right = 1,
}

public native class animLinearCompressedMotionExtraction extends animIMotionExtraction {
  native let duration: Float;
  native let rotFrames: array<Quaternion>;
  native let posFrames: array<Vector3>;
  native let rotTime: array<Float>;
  native let posTime: array<Float>;
}

public native class animLipsyncMapping extends CResource {
  native let languageCodeName: CName;
  native let scenePaths: array<Uint64>;
  native let sceneEntries: array<animLipsyncMappingSceneEntry>;
}

public native struct animLipsyncMappingSceneEntry {
  native let actorVoiceTags: array<CRUID>;
  native let animSets: array<ResourceAsyncRef>;
}

enum animLocomotion_AnimType {
  None = 0,
  idle_stand = 1,
  idle_to_idle_0 = 2,
  idle_to_idle_090 = 3,
  idle_to_idle_270 = 4,
  idle_to_idle_180_l = 5,
  idle_to_idle_180_r = 6,
  walk_0 = 7,
  walk_left = 8,
  walk_right = 9,
  jog_0 = 10,
  jog_left = 11,
  jog_right = 12,
  sprint_0 = 13,
  sprint_left = 14,
  sprint_right = 15,
  idle_to_walk_0 = 16,
  idle_to_jog_0 = 17,
  idle_to_sprint_0 = 18,
  walk_to_idle_0 = 19,
  jog_to_idle_0 = 20,
  sprint_to_idle_0 = 21,
  walk_to_idle_0_l_hard = 22,
  walk_to_idle_0_r_hard = 23,
  jog_to_idle_0_l_hard = 24,
  jog_to_idle_0_r_hard = 25,
  sprint_to_idle_0_l_hard = 26,
  sprint_to_idle_0_r_hard = 27,
  walk_to_jog_0 = 28,
  walk_to_sprint_0 = 29,
  jog_to_walk_0 = 30,
  jog_to_sprint_0 = 31,
  sprint_to_walk_0 = 32,
  sprint_to_jog_0 = 33,
  idle_turn_to_walk_090 = 34,
  idle_turn_to_walk_180_l = 35,
  idle_turn_to_walk_180_r = 36,
  idle_turn_to_walk_270 = 37,
  idle_turn_to_jog_090 = 38,
  idle_turn_to_jog_180_l = 39,
  idle_turn_to_jog_180_r = 40,
  idle_turn_to_jog_270 = 41,
  idle_turn_to_sprint_090 = 42,
  idle_turn_to_sprint_180_l = 43,
  idle_turn_to_sprint_180_r = 44,
  idle_turn_to_sprint_270 = 45,
  walk_180 = 46,
  jog_180 = 47,
  walk_0_to_walk_180_l = 48,
  walk_0_to_walk_180_r = 49,
  walk_180_to_walk_0_l = 50,
  walk_180_to_walk_0_r = 51,
  idle_to_walk_180 = 52,
  idle_to_jog_180 = 53,
  walk_to_idle_180 = 54,
  jog_to_idle_180 = 55,
  jog_0_to_jog_180_l = 56,
  jog_0_to_jog_180_r = 57,
  jog_180_to_jog_0_l = 58,
  jog_180_to_jog_0_r = 59,
  jog_to_sprint_180 = 60,
  walk_to_jog_180 = 61,
  jog_to_walk_180 = 62,
  idle_to_walk_090 = 63,
  idle_to_walk_270 = 64,
  walk_090 = 65,
  walk_270 = 66,
  walk_to_idle_090 = 67,
  walk_to_idle_270 = 68,
  walk_0_to_walk_090 = 69,
  walk_0_to_walk_270 = 70,
  walk_180_to_walk_090 = 71,
  walk_180_to_walk_270 = 72,
  walk_090_to_walk_0 = 73,
  walk_270_to_walk_0 = 74,
  walk_090_to_walk_180 = 75,
  walk_270_to_walk_180 = 76,
  walk_090_to_walk_270_l = 77,
  walk_090_to_walk_270_r = 78,
  walk_270_to_walk_090_l = 79,
  walk_270_to_walk_090_r = 80,
  walk_0_down_stairs = 81,
  walk_0_up_stairs = 82,
  walk_0_down_slope = 83,
  walk_0_up_slope = 84,
  jog_0_down_stairs = 85,
  jog_0_up_stairs = 86,
  jog_0_down_slope = 87,
  jog_0_up_slope = 88,
  sprint_0_down_stairs = 89,
  sprint_0_up_stairs = 90,
  sprint_0_down_slope = 91,
  sprint_0_up_slope = 92,
  walk_090_up_stairs = 93,
  walk_090_down_stairs = 94,
  walk_270_up_stairs = 95,
  walk_270_down_stairs = 96,
  walk_180_up_stairs = 97,
  walk_180_down_stairs = 98,
  idle_step_single_0 = 99,
  idle_step_single_090 = 100,
  idle_step_single_180 = 101,
  idle_step_single_270 = 102,
}

enum animLocomotion_Style {
  LS_Idle = 0,
  LS_Rotation = 1,
  LS_Walk = 2,
  LS_Jog = 3,
  LS_Sprint = 4,
  LS_Any = 5,
}

enum animLocomotionDecision {
  LD_None = 0,
  LD_Stop = 1,
  LD_MoveTo = 2,
  LD_Move = 3,
}

enum animLocoStateType {
  LS_Pre = 0,
  LS_Loop = 1,
}

public native class animLookAtAdditionalPreset_BothArms extends animLookAtAdditionalPreset {
  native let rightHanded: Bool;
  native let softLimitAngle: Float;
}

public native class animLookAtAdditionalPreset_Eyes extends animLookAtAdditionalPreset {
  native let softLimitAngle: Float;
}

public native class animLookAtAdditionalPreset_FullControl extends animLookAtAdditionalPreset {
  native let useRightHand: Bool;
  native let attachHandToOtherOne: Bool;
  native let limits: LookAtLimits;
  native let suppress: Float;
  native let mode: Int32;
}

public native class animLookAtAdditionalPreset_LeftArm extends animLookAtAdditionalPreset {
  native let isAiming: Bool;
  native let softLimitAngle: Float;
}

public native class animLookAtAdditionalPreset_RightArm extends animLookAtAdditionalPreset {
  native let isAiming: Bool;
  native let softLimitAngle: Float;
}

public abstract native class animLookAtAdditionalPreset extends IScriptable {}

public native struct animLookAtAnimationDefinition {
  native let minTransitionDuration: Float;
  native let playAnimProbability: Float;
  native let animDelay: Float;
  native let animations: array<CName>;
}

public native class animLookAtParams_Add extends ISerializable {}

public native class animLookAtParams_Remove extends ISerializable {}

public native class animLookAtParams_UpdatePositions extends ISerializable {}

public native class animLookAtPreset_DroneHorizontal extends animLookAtPreset {
  native let softLimitDegrees: Float;
  native let hardLimitDegrees: Float;
  native let hardLimitDistance: Float;
  native let backLimitDegrees: Float;
  native let suppress: Float;
  native let mode: Int32;
}

public native class animLookAtPreset_DroneVertical extends animLookAtPreset {
  native let softLimitDegrees: Float;
  native let hardLimitDegrees: Float;
  native let hardLimitDistance: Float;
  native let backLimitDegrees: Float;
  native let suppress: Float;
  native let mode: Int32;
}

public native class animLookAtPreset_Eyes extends animLookAtPreset {
  native let softLimitAngle: Float;
}

public native class animLookAtPreset_EyesHead extends animLookAtPreset {
  native let suppressHeadAnimation: Float;
  native let headMobility: Float;
  native let softLimitAngle: Float;
}

public native class animLookAtPreset_EyesHeadWithBodyAttached extends animLookAtPreset {
  native let suppressHeadAnimation: Float;
  native let headMobility: Float;
  native let suppressChestAnimation: Float;
  native let chestMobility: Float;
  native let softLimitAngle: Float;
}

public native class animLookAtPreset_EyesHeadWithBodyFree extends animLookAtPreset {
  native let suppressHeadAnimation: Float;
  native let headMobility: Float;
  native let suppressChestAnimation: Float;
  native let chestMobility: Float;
  native let softLimitAngle: Float;
}

public native class animLookAtPreset_EyesHeadWithBodyFreeForFollower extends animLookAtPreset {
  native let suppressHeadAnimation: Float;
  native let headMobility: Float;
  native let suppressChestAnimation: Float;
  native let chestMobility: Float;
  native let softLimitAngle: Float;
}

public native class animLookAtPreset_EyesHeadWithoutSuppress extends animLookAtPreset {
  native let headMobility: Float;
  native let softLimitAngle: Float;
}

public native class animLookAtPreset_FullControl extends animLookAtPreset {
  native let limits: LookAtLimits;
  native let eyesSuppress: Float;
  native let eyesMode: Int32;
  native let headSuppress: Float;
  native let headMode: Int32;
  native let headSquareScale: Float;
  native let chestSuppress: Float;
  native let chestMode: Int32;
  native let chestSquareScale: Float;
}

public abstract native class animLookAtPreset extends IScriptable {}

public native struct animLookAtRequestForPart {
  native let bodyPart: CName;
  native let request: LookAtRequest;
  native let attachLeftHandToRightHand: Int32;
  native let attachRightHandToLeftHand: Int32;
}

public native class animLookAtVehicleRestrictionParams extends ISerializable {}

public native struct animMathExpressionNodeData {
  native let expression: ref<mathExprExpression>;
  native let floatSockets: array<animAnimMathExpressionFloatSocket>;
  native let vectorSockets: array<animAnimMathExpressionVectorSocket>;
  native let quaternionSockets: array<animAnimMathExpressionQuaternionSocket>;
}

public native class animMixerSlotAddIdleParams extends ISerializable {}

public native class animMixerSlotIdleParams extends ISerializable {}

public native class animMixerSlotParams extends ISerializable {}

public native class animMixerSlotTrajectoryBlendParams extends ISerializable {}

enum animMotionTableAction {
  MTA_None = 0,
  MTA_Start = 1,
  MTA_Stop = 2,
  MTA_Move = 3,
  MTA_TurnInPlace = 4,
  MTA_TransitionToBackward = 5,
  MTA_BackwardMove = 6,
  MTA_TransitionFromBackward = 7,
  MTA_StrafeLeft = 8,
  MTA_StrafeRight = 9,
  MTA_ForwardToStrafeLeft = 10,
  MTA_ForwardToStrafeRight = 11,
  MTA_StrafeLeftToForward = 12,
  MTA_StrafeRightToForward = 13,
  MTA_BackwardToStrafeLeft = 14,
  MTA_BackwardToStrafeRight = 15,
  MTA_StrafeLeftToBackward = 16,
  MTA_StrafeRightToBackward = 17,
  MTA_BackwardStart = 18,
  MTA_BackwardStop = 19,
  MTA_StrafeLeftStart = 20,
  MTA_StrafeLeftStop = 21,
  MTA_StrafeRightStart = 22,
  MTA_StrafeRightStop = 23,
  MTA_ForwardToWalk = 24,
  MTA_ForwardToJog = 25,
  MTA_ForwardToSprint = 26,
  MTA_HardStopLeftLeg = 27,
  MTA_HardStopRightLeg = 28,
  MTA_RepositionForward = 29,
  MTA_RepositionLeft = 30,
  MTA_RepositionRight = 31,
  MTA_RepositionBackward = 32,
  MTA_Custom = 33,
  MTA_CrowdMove = 34,
  MTA_CrowdMoveSlopes = 35,
  MTA_CrowdMoveStairs = 36,
  MTA_StrafeLeftToStrafeRight = 37,
  MTA_StrafeRightToStrafeLeft = 38,
  MTA_CrowdRelaxedStop = 39,
  MTA_CrowdHardStop = 40,
  MTA_CrowdSprintStop = 41,
  MTA_CrowdFleeStopFront = 42,
  MTA_CrowdFleeStopBack = 43,
  MTA_CrowdRelaxedStart = 44,
  MTA_CrowdFleeStartIdle = 45,
  MTA_CrowdFleeStartMotion = 46,
  MTA_CrowdDirectionalStartFast = 47,
}

public native class animMotionTableProvider_Animation extends animIMotionTableProvider {}

public native class animMotionTableProvider_Default extends animIMotionTableProvider {}

public native class animMotionTableProvider_MasterSlaveBlend extends animIMotionTableProvider {
  native let masterInputIdx: Uint8;
}

public native class animMotionTableProvider_MultiBlend extends animIMotionTableProvider {}

public native class animMotionTableProvider_StaticSwitch extends animIMotionTableProvider {}

enum animMotionTableType {
  MTT_None = 0,
  MTT_Walk = 1,
  MTT_Jog = 2,
  MTT_Sprint = 3,
  MTT_Custom = 4,
}

enum animMotionTag {
  MT_Invalid = 0,
  Walk = 1,
  Jog = 2,
  Sprint = 3,
}

public native struct animMotionWrapper {}

public native struct animMultipleParentConstraint_JsonEntry {
  native let parentTransform: CName;
  native let parentWeightMode: animConstraintWeightMode;
  native let parentStaticWeight: Float;
  native let parentTrackWeight: CName;
  native let useComplementWeight: Bool;
  native let useOffset: Bool;
  native let offset: QsTransform;
}

public native class animMultipleParentConstraint_JsonProperties extends ISerializable {
  native let parentsTransforms: array<animMultipleParentConstraint_JsonEntry>;
  native let transformIndex: CName;
  native let weightMode: animConstraintWeightMode;
  native let weight: Float;
  native let weightFloatTrack: CName;
}

public native struct animNamedTrackIndex {
  native let name: CName;
}

public native struct animNodeProfileTimerInfo {
  native let name: CName;
  native let mode: animNodeProfileTimerMode;
}

enum animNodeProfileTimerMode {
  Begin = 0,
  End = 1,
}

public native class AnimObstacleDetected extends Event {}

public native struct animOverrideAnimSetRef {
  native let animSet: ResourceAsyncRef; // raRef<animAnimSet>
  native let variableName: CName;
}

public native struct animOverrideBlendBoneInfo {
  native let transformIndex: animTransformIndex;
  native let weight: Float;
}

public native struct animOverrideBlendTrackInfo {
  native let track: animNamedTrackIndex;
  native let weight: Float;
}

enum animParentStaticSwitchBranch {
  None = 0,
  TrueBranch = 1,
  FalseBranch = 2,
}

enum animPendulumConstraintType {
  Cone = 0,
  HingePlane = 1,
  HalfCone = 2,
}

enum animPendulumProjectionType {
  Disabled = 0,
  ShortestPathRotational = 1,
  DirectedRotational = 2,
}

public native class animPlaneUncompressedMotionExtraction extends animIMotionExtraction {
  native let frames: array<Vector3>;
  native let duration: Float;
}

public native struct animPoleVectorDetails {
  native let targetBone: animTransformIndex;
  native let positionOffset: Vector3;
}

public native class animPoseBlendMethod_BoneBranch extends animIPoseBlendMethod {
  native let bones: array<animOverrideBlendBoneInfo>;
}

public native class animPoseBlendMethod_Mask extends animIPoseBlendMethod {
  native let maskName: CName;
}

public native struct animPoseCorrection {
  native let rbfCoefficient: Float;
  native let rbfPowValue: Float;
}

public native struct animPoseCorrectionGroup {}

public native struct animPoseCorrectionParams {
  native let poseCorrectionGroup: animPoseCorrectionGroup;
  native let blendDuration: Float;
}

public native struct animPoseInfoLogger {
  native let enabled: Bool;
  native let showStackTransformsCount: Bool;
  native let showStackTracksCount: Bool;
  native let entries: array<ref<animPoseInfoLoggerEntry>>;
}

public native class animPoseInfoLoggerEntry_FloatTrack extends animPoseInfoLoggerEntry {
  native let floatTrack: animNamedTrackIndex;
  native let showOnlyWhenPositive: Bool;
}

public native class animPoseInfoLoggerEntry_Transform extends animPoseInfoLoggerEntry {
  native let transform: animTransformIndex;
  native let logInModelSpace: Bool;
}

public abstract native class animPoseInfoLoggerEntry extends ISerializable {}

public native struct animPoseLimitWeights {
  native let min: Float;
  native let mid: Float;
  native let max: Float;
  native let poseTrackIndex: Int16;
  native let type: Uint8;
  native let isCachable: Bool;
}

public native struct animPoseLink {
  native let node: wref<animAnimNode_Base>;
}

enum animPositionProjectionType {
  Disabled = 0,
  ShortestPath = 1,
  Directional = 2,
}

public native struct animPropSetup {}

enum animQuaternionInterpolationType {
  Linear = 0,
  Spherical = 1,
}

public native struct animQuaternionLink {
  native let node: wref<animAnimNode_QuaternionValue>;
}

public native class animRig extends CResource {
  native let boneNames: array<CName>;
  native let trackNames: array<CName>;
  native let rigExtraTracks: array<animFloatTrackInfo>;
  native let levelOfDetailStartIndices: array<Int16>;
  native let distanceCategoryToLodMap: array<Int16>;
  native let turnOffLOD: Int32;
  native let turningOffUpdateAndSample: Bool;
  native let referenceTracks: array<Float>;
  native let referencePoseMS: array<QsTransform>;
  native let aPoseLS: array<QsTransform>;
  native let aPoseMS: array<QsTransform>;
  native let tags: redTagList;
  native let parts: array<animRigPart>;
  native let retargets: array<animRigRetarget>;
  native let ikSetups: array<ref<animIRigIkSetup>>;
  native let ragdollDesc: array<physicsRagdollBodyInfo>;
  native let ragdollNames: array<physicsRagdollBodyNames>;
}

public native class animRigIk2Setup extends animIRigIkSetup {
  native let firstBone: CName;
  native let secondBone: CName;
  native let endBone: CName;
  native let hingeAxis: animAxis;
  native let firstBoneIdx: Int16;
  native let secondBoneIdx: Int16;
  native let endBoneIdx: Int16;
}

public native class animRigIkLeftFootSetup extends animRigIk2Setup {}

public native class animRigIkRightFootSetup extends animRigIk2Setup {}

public native struct animRigPart {
  native let name: CName;
  native let singleBones: array<animRigPartBone>;
  native let treeBones: array<animRigPartBoneTree>;
  native let bonesWithRotationInModelSpace: array<CName>;
  native let mask: array<animTransformMask>;
  native let maskRotMS: array<Int32>;
}

public native struct animRigPartBone {
  native let bone: CName;
  native let weight: Float;
}

public native struct animRigPartBoneTree {
  native let rootBone: CName;
  native let weight: Float;
  native let subtreesToChange: array<animRigPartBoneTree>;
}

public native struct animRigRetarget {
  native let sourceRig: ResourceRef; // rRef<animRig>
}

public native class animRigSharedData extends CResource {
  native let parts: array<animRigPart>;
  native let ikSetups: array<ref<animIRigIkSetup>>;
}

public native class animRigTagCondition extends animIStaticCondition {
  native let tag: CName;
}

public native struct animSAnimationBufferBitwiseCompressedBoneTrack {
  native let position: animSAnimationBufferBitwiseCompressedData;
  native let orientation: animSAnimationBufferBitwiseCompressedData;
  native let scale: animSAnimationBufferBitwiseCompressedData;
}

public native struct animSAnimationBufferBitwiseCompressedData {
  native let dt: Float;
  native let compression: Int8;
  native let numFrames: Uint16;
  native let dataAddr: Uint32;
  native let dataAddrFallback: Uint32;
}

public native struct animSAnimationBufferBitwiseCompressionSettings {
  native let translationTolerance: Float;
  native let translationSkipFrameTolerance: Float;
  native let orientationTolerance: Float;
  native let orientationCompressionMethod: SAnimationBufferOrientationCompressionMethod;
  native let orientationSkipFrameTolerance: Float;
  native let scaleTolerance: Float;
  native let scaleSkipFrameTolerance: Float;
  native let trackTolerance: Float;
  native let trackSkipFrameTolerance: Float;
}

public native struct animSApplyRotationIKSolver {}

public native struct animSApplyRotationIKSolverData {
  native let bone: animTransformIndex;
}

public native struct animSBehaviorConstraintNodeFloorIKCachedTrace {}

public native struct animSBehaviorConstraintNodeFloorIKCommon {}

public native struct animSBehaviorConstraintNodeFloorIKCommonData {
  native let gravityCentreBone: animTransformIndex;
  native let rootRotationBlendTime: Float;
  native let verticalVelocityOffsetUpBlendTime: Float;
  native let verticalVelocityOffsetDownBlendTime: Float;
  native let slidingOnSlopeBlendTime: Float;
}

public native struct animSBehaviorConstraintNodeFloorIKDebugTrace {}

public native struct animSBehaviorConstraintNodeFloorIKFrontBackWeightHandler {}

public native struct animSBehaviorConstraintNodeFloorIKLeg {}

public native struct animSBehaviorConstraintNodeFloorIKLegs {}

public native struct animSBehaviorConstraintNodeFloorIKLegsData {
  native let verticalOffsetBlendUpTime: Float;
  native let verticalOffsetBlendDownTime: Float;
}

public native struct animSBehaviorConstraintNodeFloorIKLegsIKWeightHandler {}

public native struct animSBehaviorConstraintNodeFloorIKMaintainLookBone {}

public native struct animSBehaviorConstraintNodeFloorIKMaintainLookBoneData {
  native let bone: CName;
  native let amountOfRotation: Float;
}

public native struct animSBehaviorConstraintNodeFloorIKVerticalBone {}

public native struct animSBehaviorConstraintNodeFloorIKVerticalBoneData {
  native let bone: animTransformIndex;
  native let offsetToDesiredBlendTime: Float;
  native let verticalOffsetBlendTime: Float;
  native let stiffness: Float;
}

public native struct animSBehaviorConstraintNodeFloorIKWeightHandler {}

public native struct animSermoPoseInfo {
  native let lod: Uint8;
  native let type: Uint8;
  native let trackIndex: Uint16;
}

public native struct animSermoTestController {
  native let faceEnvelope: Float;
  native let upperFace: Float;
  native let lowerFace: Float;
  native let lipSyncEnvelope: Float;
  native let lipSyncLeftEnvelope: Float;
  native let lipSyncRightEnvelope: Float;
  native let jaliJaw: Float;
  native let jaliLips: Float;
  native let muzzleLips: Float;
  native let muzzleEyes: Float;
  native let muzzleBrows: Float;
  native let muzzleEyeDirections: Float;
  native let eye_l_blink: Float;
  native let eye_r_blink: Float;
  native let eye_l_widen: Float;
  native let eye_r_widen: Float;
  native let eye_l_dir_up: Float;
  native let eye_l_dir_dn: Float;
  native let eye_l_dir_in: Float;
  native let eye_l_dir_out: Float;
  native let eye_r_dir_up: Float;
  native let eye_r_dir_dn: Float;
  native let eye_r_dir_in: Float;
  native let eye_r_dir_out: Float;
  native let eye_l_pupil_narrow: Float;
  native let eye_r_pupil_narrow: Float;
  native let eye_l_pupil_wide: Float;
  native let eye_r_pupil_wide: Float;
  native let eye_l_brows_raise_in: Float;
  native let eye_r_brows_raise_in: Float;
  native let eye_l_brows_raise_out: Float;
  native let eye_r_brows_raise_out: Float;
  native let eye_l_brows_lower: Float;
  native let eye_r_brows_lower: Float;
  native let eye_l_brows_lateral: Float;
  native let eye_r_brows_lateral: Float;
  native let eye_l_oculi_squint_inner: Float;
  native let eye_r_oculi_squint_inner: Float;
  native let eye_l_oculi_squint_outer_lower: Float;
  native let eye_r_oculi_squint_outer_lower: Float;
  native let eye_l_oculi_squint_outer_upper: Float;
  native let eye_r_oculi_squint_outer_upper: Float;
  native let nose_l_compress: Float;
  native let nose_r_compress: Float;
  native let nose_l_breathe_in: Float;
  native let nose_r_breathe_in: Float;
  native let nose_l_breathe_out: Float;
  native let nose_r_breathe_out: Float;
  native let nose_l_snear: Float;
  native let nose_r_snear: Float;
  native let lips_l_nasolabialDeepener: Float;
  native let lips_r_nasolabialDeepener: Float;
  native let lips_l_upper_raise: Float;
  native let lips_r_upper_raise: Float;
  native let lips_l_pull: Float;
  native let lips_r_pull: Float;
  native let lips_l_corner_up: Float;
  native let lips_r_corner_up: Float;
  native let lips_l_corner_wide: Float;
  native let lips_r_corner_wide: Float;
  native let lips_l_corner_stretch: Float;
  native let lips_r_corner_stretch: Float;
  native let lips_l_stretch: Float;
  native let lips_r_stretch: Float;
  native let lips_l_corner_sharp_up: Float;
  native let lips_r_corner_sharp_up: Float;
  native let lips_suck_up: Float;
  native let lips_suck_dn: Float;
  native let lips_puff_up: Float;
  native let lips_puff_dn: Float;
  native let lips_apart_up: Float;
  native let lips_apart_dn: Float;
  native let lips_l_lower_raise: Float;
  native let lips_r_lower_raise: Float;
  native let lips_l_corner_dn: Float;
  native let lips_r_corner_dn: Float;
  native let lips_chin_raise: Float;
  native let lips_together_up: Float;
  native let lips_together_dn: Float;
  native let lips_l_purse: Float;
  native let lips_r_purse: Float;
  native let lips_l_funnel: Float;
  native let lips_r_funnel: Float;
  native let lips_tighten_up: Float;
  native let lips_tighten_dn: Float;
  native let lips_mid_shift_l: Float;
  native let lips_mid_shift_r: Float;
  native let lips_mid_shift_up: Float;
  native let lips_mid_shift_dn: Float;
  native let lips_corner_sticky: Float;
  native let lips_l_corner_up_in_sticky_cutScene: Float;
  native let lips_l_corner_dn_in_sticky_cutScene: Float;
  native let lips_l_corner_up_out_sticky_cutScene: Float;
  native let lips_l_corner_dn_out_sticky_cutScene: Float;
  native let lips_r_corner_up_in_sticky_cutScene: Float;
  native let lips_r_corner_up_out_sticky_cutScene: Float;
  native let lips_r_corner_dn_in_sticky_cutScene: Float;
  native let lips_r_corner_dn_out_sticky_cutScene: Float;
  native let cheek_l_suck: Float;
  native let cheek_r_suck: Float;
  native let cheek_l_puff: Float;
  native let cheek_r_puff: Float;
  native let jaw_mid_open: Float;
  native let jaw_mid_close: Float;
  native let jaw_mid_shift_l: Float;
  native let jaw_mid_shift_r: Float;
  native let jaw_mid_shift_fwd: Float;
  native let jaw_mid_shift_back: Float;
  native let jaw_mid_clench: Float;
  native let neck_l_stretch: Float;
  native let neck_r_stretch: Float;
  native let neck_tighten: Float;
  native let neck_l_sternocleidomastoid_flex: Float;
  native let neck_r_sternocleidomastoid_flex: Float;
  native let neck_l_platysma_flex: Float;
  native let neck_r_platysma_flex: Float;
  native let neck_throat_adamsApple_up: Float;
  native let neck_throat_adamsApple_dn: Float;
  native let neck_throat_compress: Float;
  native let neck_throat_open: Float;
  native let neck_l_turn: Float;
  native let neck_r_turn: Float;
  native let neck_up_turn: Float;
  native let neck_dn_turn: Float;
  native let neck_l_tilt: Float;
  native let neck_r_tilt: Float;
  native let head_neck_up_turn: Float;
  native let head_neck_dn_turn: Float;
  native let head_neck_l_tilt: Float;
  native let head_neck_r_tilt: Float;
  native let ear_l_shift_up: Float;
  native let ear_r_shift_up: Float;
  native let sculp_mid_slide: Float;
  native let face_gravity_fwd: Float;
  native let face_gravity_back: Float;
  native let face_gravity_l: Float;
  native let face_gravity_r: Float;
  native let tongue_mid_base_l: Float;
  native let tongue_mid_base_r: Float;
  native let tongue_mid_base_dn: Float;
  native let tongue_mid_base_up: Float;
  native let tongue_mid_base_fwd: Float;
  native let tongue_mid_base_front: Float;
  native let tongue_mid_base_back: Float;
  native let tongue_mid_fwd: Float;
  native let tongue_mid_lift: Float;
  native let tongue_mid_tip_l: Float;
  native let tongue_mid_tip_r: Float;
  native let tongue_mid_tip_dn: Float;
  native let tongue_mid_tip_up: Float;
  native let tongue_mid_twist_l: Float;
  native let tongue_mid_twist_r: Float;
  native let tongue_mid_thick: Float;
  native let nose_l_snearAnimOverrideWeight: Float;
  native let nose_r_snearAnimOverrideWeight: Float;
  native let lips_l_nasolabialDeepenerAnimOverrideWeight: Float;
  native let lips_r_nasolabialDeepenerAnimOverrideWeight: Float;
  native let lips_l_upper_raiseAnimOverrideWeight: Float;
  native let lips_r_upper_raiseAnimOverrideWeight: Float;
  native let lips_l_pullAnimOverrideWeight: Float;
  native let lips_r_pullAnimOverrideWeight: Float;
  native let lips_l_corner_upAnimOverrideWeight: Float;
  native let lips_r_corner_upAnimOverrideWeight: Float;
  native let lips_l_corner_wideAnimOverrideWeight: Float;
  native let lips_r_corner_wideAnimOverrideWeight: Float;
  native let lips_l_corner_stretchAnimOverrideWeight: Float;
  native let lips_r_corner_stretchAnimOverrideWeight: Float;
  native let lips_l_stretchAnimOverrideWeight: Float;
  native let lips_r_stretchAnimOverrideWeight: Float;
  native let lips_l_corner_sharp_upAnimOverrideWeight: Float;
  native let lips_r_corner_sharp_upAnimOverrideWeight: Float;
  native let lips_suck_upAnimOverrideWeight: Float;
  native let lips_suck_dnAnimOverrideWeight: Float;
  native let lips_puff_upAnimOverrideWeight: Float;
  native let lips_puff_dnAnimOverrideWeight: Float;
  native let lips_apart_upAnimOverrideWeight: Float;
  native let lips_apart_dnAnimOverrideWeight: Float;
  native let lips_l_lower_raiseAnimOverrideWeight: Float;
  native let lips_r_lower_raiseAnimOverrideWeight: Float;
  native let lips_l_corner_dnAnimOverrideWeight: Float;
  native let lips_r_corner_dnAnimOverrideWeight: Float;
  native let lips_chin_raiseAnimOverrideWeight: Float;
  native let lips_together_upAnimOverrideWeight: Float;
  native let lips_together_dnAnimOverrideWeight: Float;
  native let lips_l_purseAnimOverrideWeight: Float;
  native let lips_r_purseAnimOverrideWeight: Float;
  native let lips_l_funnelAnimOverrideWeight: Float;
  native let lips_r_funnelAnimOverrideWeight: Float;
  native let lips_tighten_upAnimOverrideWeight: Float;
  native let lips_tighten_dnAnimOverrideWeight: Float;
  native let lips_mid_shift_lAnimOverrideWeight: Float;
  native let lips_mid_shift_rAnimOverrideWeight: Float;
  native let lips_mid_shift_upAnimOverrideWeight: Float;
  native let lips_mid_shift_dnAnimOverrideWeight: Float;
  native let cheek_l_puffAnimOverrideWeight: Float;
  native let cheek_r_puffAnimOverrideWeight: Float;
  native let jaw_mid_openAnimOverrideWeight: Float;
  native let jaw_mid_closeAnimOverrideWeight: Float;
  native let jaw_mid_shift_lAnimOverrideWeight: Float;
  native let jaw_mid_shift_rAnimOverrideWeight: Float;
  native let jaw_mid_shift_fwdAnimOverrideWeight: Float;
  native let jaw_mid_shift_backAnimOverrideWeight: Float;
  native let jaw_mid_clenchAnimOverrideWeight: Float;
  native let neck_l_stretchAnimOverrideWeight: Float;
  native let neck_r_stretchAnimOverrideWeight: Float;
  native let neck_tightenAnimOverrideWeight: Float;
  native let neck_l_sternocleidomastoid_flexAnimOverrideWeight: Float;
  native let neck_r_sternocleidomastoid_flexAnimOverrideWeight: Float;
  native let neck_l_platysma_flexAnimOverrideWeight: Float;
  native let neck_r_platysma_flexAnimOverrideWeight: Float;
  native let neck_throat_adamsApple_upAnimOverrideWeight: Float;
  native let neck_throat_adamsApple_dnAnimOverrideWeight: Float;
  native let neck_throat_compressAnimOverrideWeight: Float;
  native let neck_throat_openAnimOverrideWeight: Float;
  native let lips_corner_stickyAnimOverrideWeight: Float;
  native let lips_l_corner_up_in_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_l_corner_dn_in_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_l_corner_up_out_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_l_corner_dn_out_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_r_corner_up_in_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_r_corner_up_out_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_r_corner_dn_in_sticky_cutSceneAnimOverrideWeight: Float;
  native let lips_r_corner_dn_out_sticky_cutSceneAnimOverrideWeight: Float;
  native let tongue_mid_base_lAnimOverrideWeight: Float;
  native let tongue_mid_base_rAnimOverrideWeight: Float;
  native let tongue_mid_base_dnAnimOverrideWeight: Float;
  native let tongue_mid_base_upAnimOverrideWeight: Float;
  native let tongue_mid_base_fwdAnimOverrideWeight: Float;
  native let tongue_mid_base_frontAnimOverrideWeight: Float;
  native let tongue_mid_base_backAnimOverrideWeight: Float;
  native let tongue_mid_fwdAnimOverrideWeight: Float;
  native let tongue_mid_liftAnimOverrideWeight: Float;
  native let tongue_mid_tip_lAnimOverrideWeight: Float;
  native let tongue_mid_tip_rAnimOverrideWeight: Float;
  native let tongue_mid_tip_dnAnimOverrideWeight: Float;
  native let tongue_mid_tip_upAnimOverrideWeight: Float;
  native let tongue_mid_twist_lAnimOverrideWeight: Float;
  native let tongue_mid_twist_rAnimOverrideWeight: Float;
  native let tongue_mid_thickAnimOverrideWeight: Float;
  native let eye_l_blinkLipsyncPoseOutput: Float;
  native let eye_r_blinkLipsyncPoseOutput: Float;
  native let eye_l_widenLipsyncPoseOutput: Float;
  native let eye_r_widenLipsyncPoseOutput: Float;
  native let eye_l_dir_upLipsyncPoseOutput: Float;
  native let eye_l_dir_dnLipsyncPoseOutput: Float;
  native let eye_l_dir_inLipsyncPoseOutput: Float;
  native let eye_l_dir_outLipsyncPoseOutput: Float;
  native let eye_r_dir_upLipsyncPoseOutput: Float;
  native let eye_r_dir_dnLipsyncPoseOutput: Float;
  native let eye_r_dir_inLipsyncPoseOutput: Float;
  native let eye_r_dir_outLipsyncPoseOutput: Float;
  native let eye_l_pupil_narrowLipsyncPoseOutput: Float;
  native let eye_r_pupil_narrowLipsyncPoseOutput: Float;
  native let eye_l_pupil_wideLipsyncPoseOutput: Float;
  native let eye_r_pupil_wideLipsyncPoseOutput: Float;
  native let eye_l_brows_raise_inLipsyncPoseOutput: Float;
  native let eye_r_brows_raise_inLipsyncPoseOutput: Float;
  native let eye_l_brows_raise_outLipsyncPoseOutput: Float;
  native let eye_r_brows_raise_outLipsyncPoseOutput: Float;
  native let eye_l_brows_lowerLipsyncPoseOutput: Float;
  native let eye_r_brows_lowerLipsyncPoseOutput: Float;
  native let eye_l_brows_lateralLipsyncPoseOutput: Float;
  native let eye_r_brows_lateralLipsyncPoseOutput: Float;
  native let eye_l_oculi_squint_innerLipsyncPoseOutput: Float;
  native let eye_r_oculi_squint_innerLipsyncPoseOutput: Float;
  native let eye_l_oculi_squint_outer_lowerLipsyncPoseOutput: Float;
  native let eye_r_oculi_squint_outer_lowerLipsyncPoseOutput: Float;
  native let eye_l_oculi_squint_outer_upperLipsyncPoseOutput: Float;
  native let eye_r_oculi_squint_outer_upperLipsyncPoseOutput: Float;
  native let nose_l_compressLipsyncPoseOutput: Float;
  native let nose_r_compressLipsyncPoseOutput: Float;
  native let nose_l_breathe_inLipsyncPoseOutput: Float;
  native let nose_r_breathe_inLipsyncPoseOutput: Float;
  native let nose_l_breathe_outLipsyncPoseOutput: Float;
  native let nose_r_breathe_outLipsyncPoseOutput: Float;
  native let nose_l_snearLipsyncPoseOutput: Float;
  native let nose_r_snearLipsyncPoseOutput: Float;
  native let lips_l_nasolabialDeepenerLipsyncPoseOutput: Float;
  native let lips_r_nasolabialDeepenerLipsyncPoseOutput: Float;
  native let lips_l_upper_raiseLipsyncPoseOutput: Float;
  native let lips_r_upper_raiseLipsyncPoseOutput: Float;
  native let lips_l_pullLipsyncPoseOutput: Float;
  native let lips_r_pullLipsyncPoseOutput: Float;
  native let lips_l_corner_upLipsyncPoseOutput: Float;
  native let lips_r_corner_upLipsyncPoseOutput: Float;
  native let lips_l_corner_wideLipsyncPoseOutput: Float;
  native let lips_r_corner_wideLipsyncPoseOutput: Float;
  native let lips_l_corner_stretchLipsyncPoseOutput: Float;
  native let lips_r_corner_stretchLipsyncPoseOutput: Float;
  native let lips_l_stretchLipsyncPoseOutput: Float;
  native let lips_r_stretchLipsyncPoseOutput: Float;
  native let lips_l_corner_sharp_upLipsyncPoseOutput: Float;
  native let lips_r_corner_sharp_upLipsyncPoseOutput: Float;
  native let lips_suck_upLipsyncPoseOutput: Float;
  native let lips_suck_dnLipsyncPoseOutput: Float;
  native let lips_puff_upLipsyncPoseOutput: Float;
  native let lips_puff_dnLipsyncPoseOutput: Float;
  native let lips_apart_upLipsyncPoseOutput: Float;
  native let lips_apart_dnLipsyncPoseOutput: Float;
  native let lips_l_lower_raiseLipsyncPoseOutput: Float;
  native let lips_r_lower_raiseLipsyncPoseOutput: Float;
  native let lips_l_corner_dnLipsyncPoseOutput: Float;
  native let lips_r_corner_dnLipsyncPoseOutput: Float;
  native let lips_chin_raiseLipsyncPoseOutput: Float;
  native let lips_together_upLipsyncPoseOutput: Float;
  native let lips_together_dnLipsyncPoseOutput: Float;
  native let lips_l_purseLipsyncPoseOutput: Float;
  native let lips_r_purseLipsyncPoseOutput: Float;
  native let lips_l_funnelLipsyncPoseOutput: Float;
  native let lips_r_funnelLipsyncPoseOutput: Float;
  native let lips_tighten_upLipsyncPoseOutput: Float;
  native let lips_tighten_dnLipsyncPoseOutput: Float;
  native let lips_mid_shift_lLipsyncPoseOutput: Float;
  native let lips_mid_shift_rLipsyncPoseOutput: Float;
  native let lips_mid_shift_upLipsyncPoseOutput: Float;
  native let lips_mid_shift_dnLipsyncPoseOutput: Float;
  native let lips_corner_stickyLipsyncPoseOutput: Float;
  native let lips_l_corner_up_in_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_l_corner_dn_in_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_l_corner_up_out_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_l_corner_dn_out_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_r_corner_up_in_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_r_corner_up_out_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_r_corner_dn_in_sticky_cutSceneLipsyncPoseOutput: Float;
  native let lips_r_corner_dn_out_sticky_cutSceneLipsyncPoseOutput: Float;
  native let cheek_l_suckLipsyncPoseOutput: Float;
  native let cheek_r_suckLipsyncPoseOutput: Float;
  native let cheek_l_puffLipsyncPoseOutput: Float;
  native let cheek_r_puffLipsyncPoseOutput: Float;
  native let jaw_mid_openLipsyncPoseOutput: Float;
  native let jaw_mid_closeLipsyncPoseOutput: Float;
  native let jaw_mid_shift_lLipsyncPoseOutput: Float;
  native let jaw_mid_shift_rLipsyncPoseOutput: Float;
  native let jaw_mid_shift_fwdLipsyncPoseOutput: Float;
  native let jaw_mid_shift_backLipsyncPoseOutput: Float;
  native let jaw_mid_clenchLipsyncPoseOutput: Float;
  native let neck_l_stretchLipsyncPoseOutput: Float;
  native let neck_r_stretchLipsyncPoseOutput: Float;
  native let neck_tightenLipsyncPoseOutput: Float;
  native let neck_l_sternocleidomastoid_flexLipsyncPoseOutput: Float;
  native let neck_r_sternocleidomastoid_flexLipsyncPoseOutput: Float;
  native let neck_l_platysma_flexLipsyncPoseOutput: Float;
  native let neck_r_platysma_flexLipsyncPoseOutput: Float;
  native let neck_throat_adamsApple_upLipsyncPoseOutput: Float;
  native let neck_throat_adamsApple_dnLipsyncPoseOutput: Float;
  native let neck_throat_compressLipsyncPoseOutput: Float;
  native let neck_throat_openLipsyncPoseOutput: Float;
  native let neck_l_turnLipsyncPoseOutput: Float;
  native let neck_r_turnLipsyncPoseOutput: Float;
  native let neck_up_turnLipsyncPoseOutput: Float;
  native let neck_dn_turnLipsyncPoseOutput: Float;
  native let neck_l_tiltLipsyncPoseOutput: Float;
  native let neck_r_tiltLipsyncPoseOutput: Float;
  native let head_neck_up_turnLipsyncPoseOutput: Float;
  native let head_neck_dn_turnLipsyncPoseOutput: Float;
  native let head_neck_l_tiltLipsyncPoseOutput: Float;
  native let head_neck_r_tiltLipsyncPoseOutput: Float;
  native let ear_l_shift_upLipsyncPoseOutput: Float;
  native let ear_r_shift_upLipsyncPoseOutput: Float;
  native let sculp_mid_slideLipsyncPoseOutput: Float;
  native let face_gravity_fwdLipsyncPoseOutput: Float;
  native let face_gravity_backLipsyncPoseOutput: Float;
  native let face_gravity_lLipsyncPoseOutput: Float;
  native let face_gravity_rLipsyncPoseOutput: Float;
  native let tongue_mid_base_lLipsyncPoseOutput: Float;
  native let tongue_mid_base_rLipsyncPoseOutput: Float;
  native let tongue_mid_base_dnLipsyncPoseOutput: Float;
  native let tongue_mid_base_upLipsyncPoseOutput: Float;
  native let tongue_mid_base_fwdLipsyncPoseOutput: Float;
  native let tongue_mid_base_frontLipsyncPoseOutput: Float;
  native let tongue_mid_base_backLipsyncPoseOutput: Float;
  native let tongue_mid_fwdLipsyncPoseOutput: Float;
  native let tongue_mid_liftLipsyncPoseOutput: Float;
  native let tongue_mid_tip_lLipsyncPoseOutput: Float;
  native let tongue_mid_tip_rLipsyncPoseOutput: Float;
  native let tongue_mid_tip_dnLipsyncPoseOutput: Float;
  native let tongue_mid_tip_upLipsyncPoseOutput: Float;
  native let tongue_mid_twist_lLipsyncPoseOutput: Float;
  native let tongue_mid_twist_rLipsyncPoseOutput: Float;
  native let tongue_mid_thickLipsyncPoseOutput: Float;
  native let eye_l_oculi_squint_outer_lowerWrnkl: Float;
  native let eye_r_oculi_squint_outer_lowerWrnkl: Float;
  native let eye_l_oculi_squint_outer_upperWrnkl: Float;
  native let eye_r_oculi_squint_outer_upperWrnkl: Float;
  native let eye_l_brows_raise_inWrnkl: Float;
  native let eye_r_brows_raise_inWrnkl: Float;
  native let eye_l_brows_raise_outWrnkl: Float;
  native let eye_r_brows_raise_outWrnkl: Float;
  native let eye_l_brows_lowerWrnkl: Float;
  native let eye_r_brows_lowerWrnkl: Float;
  native let eye_l_brows_lateralWrnkl: Float;
  native let eye_r_brows_lateralWrnkl: Float;
  native let nose_l_snearWrnkl: Float;
  native let nose_r_snearWrnkl: Float;
  native let lips_l_upper_raiseWrnkl: Float;
  native let lips_r_upper_raiseWrnkl: Float;
  native let lips_l_corner_upWrnkl: Float;
  native let lips_r_corner_upWrnkl: Float;
  native let lips_l_corner_wideWrnkl: Float;
  native let lips_r_corner_wideWrnkl: Float;
  native let lips_l_corner_stretchWrnkl: Float;
  native let lips_r_corner_stretchWrnkl: Float;
  native let lips_l_lower_raiseWrnkl: Float;
  native let lips_r_lower_raiseWrnkl: Float;
  native let lips_chin_raiseWrnkl: Float;
  native let lips_l_purseWrnkl: Float;
  native let lips_r_purseWrnkl: Float;
  native let lips_l_funnelWrnkl: Float;
  native let lips_r_funnelWrnkl: Float;
  native let jaw_mid_openWrnkl: Float;
  native let neck_l_stretchWrnkl: Float;
  native let neck_r_stretchWrnkl: Float;
  native let head_neck_dn_turnWrnkl: Float;
}

public native struct animSetBoneTransform_JsonEntry {
  native let transformToChange: CName;
  native let setMethod: animSetBoneTransformEntry_SetMethod;
  native let snapToReference: Bool;
  native let sourceBone: CName;
  native let offsetToReference: Bool;
  native let offsetSpaceBone: CName;
  native let offset: QsTransform;
}

public native class animSetBoneTransform_JsonProperties extends ISerializable {
  native let entries: array<animSetBoneTransform_JsonEntry>;
}

enum animSetBoneTransformEntry_SetMethod {
  NoSnapping = 0,
  WholeTransform = 1,
  TranslationOnly = 2,
  RotationOnly = 3,
}

public native struct animSetBoneTransformEntry {
  native let transformToChange: animTransformIndex;
  native let setMethod: animSetBoneTransformEntry_SetMethod;
  native let snapToReference: Bool;
  native let sourceBone: animTransformIndex;
  native let offsetToReference: Bool;
  native let offsetSpaceBone: animTransformIndex;
  native let offset: QsTransform;
}

public native class animSimpleBounce_JsonProperties extends ISerializable {
  native let multiplier: Float;
  native let negativeMultiplier: Float;
  native let smoothStep: Float;
  native let offset: Float;
  native let delay: Float;
  native let startTransform: animTransformIndex;
  native let endTransform: animTransformIndex;
  native let transformOutputs: array<animSimpleBounceTransformOutput>;
  native let trackOutputs: array<animSimpleBounceTrackOutput>;
  native let outputDriverTrack: animNamedTrackIndex;
}

public native struct animSimpleBounceTrackOutput {
  native let targetTrack: animNamedTrackIndex;
  native let multiplier: Float;
}

public native struct animSimpleBounceTransformOutput_ChannelEntry {
  native let transformChannel: animTransformChannel;
  native let multiplier: Float;
}

public native struct animSimpleBounceTransformOutput {
  native let targetTransform: animTransformIndex;
  native let parentTransform: animTransformIndex;
  native let targetTransformChannel: animTransformChannel;
  native let multiplier: Float;
  native let channelEntries: array<animSimpleBounceTransformOutput_ChannelEntry>;
}

public native struct animSmoothFloatClamp {
  native let min: Float;
  native let max: Float;
  native let marginEaseOutCurve: CurveDataFloat;
}

public native struct animSnapToTerrainIkRequest {
  native let ikChain: CName;
  native let footTransformIndex: animTransformIndex;
  native let poleVectorRefTransformIndex: animTransformIndex;
  native let enableFootLockFloatTrack: animNamedTrackIndex;
}

public native class animSplineCompressedMotionExtraction extends animIMotionExtraction {
  native let duration: Float;
  native let posKeysData: array<Uint8>;
  native let rotKeysData: array<Uint8>;
}

enum animSpringProjectionType {
  Disabled = 0,
  ShortestPath = 1,
}

public native struct animStackTracksExtender_JsonEntry {
  native let name: CName;
  native let referenceValue: Float;
}

public native class animStackTracksExtender_JsonProperties extends ISerializable {
  native let entries: array<animStackTracksExtender_JsonEntry>;
}

public native struct animStackTransformsExtender_Entry {
  native let transformInfo: animTransformInfo;
  native let snapMethod: animStackTransformsExtender_SnapToBoneMethod;
  native let snapToReference: Bool;
  native let snapTargetBone: animTransformIndex;
  native let offsetToReference: Bool;
  native let offsetSpaceBone: animTransformIndex;
  native let offset: QsTransform;
}

public native struct animStackTransformsExtender_JsonEntry {
  native let name: CName;
  native let parentName: CName;
  native let referenceTransformLs: QsTransform;
  native let snapMethod: animStackTransformsExtender_SnapToBoneMethod;
  native let snapToReference: Bool;
  native let snapTargetBone: CName;
  native let offsetToReference: Bool;
  native let offsetSpaceBone: CName;
  native let offset: QsTransform;
}

public native class animStackTransformsExtender_JsonProperties extends ISerializable {
  native let entries: array<animStackTransformsExtender_JsonEntry>;
}

enum animStackTransformsExtender_SnapToBoneMethod {
  NoSnapping = 0,
  WholeTransform = 1,
  TranslationOnly = 2,
  RotationOnly = 3,
}

enum animStateTag {
  ST_Invalid = 0,
  Idle = 1,
  Cover = 2,
}

public native struct animSTwoBonesIKSolver {}

public native struct animSTwoBonesIKSolverData {
  native let upperBone: animTransformIndex;
  native let jointBone: animTransformIndex;
  native let subLowerBone: animTransformIndex;
  native let lowerBone: animTransformIndex;
  native let ikBone: animTransformIndex;
  native let limitToLengthPercentage: Float;
  native let reverseBend: Bool;
  native let allowToLock: Bool;
  native let autoSetupDirs: Bool;
  native let jointSideWeightUpper: Float;
  native let jointSideWeightJoint: Float;
  native let jointSideWeightLower: Float;
}

public native class animSyncMethodByEvent extends animISyncMethod {
  native let eventName: CName;
}

public native class animSyncMethodByFootPhase extends animISyncMethod {}

public native class animSyncMethodByProgress extends animISyncMethod {}

public native class animSyncMethodLocomotion extends animISyncMethod {
  native let locomotionFeatureName: CName;
  native let accelStopTimeEvent: CName;
}

public native struct animTEMP_IKTargetsControllerBodyType {
  native let genderTag: CName;
  native let bodyTypeTag: CName;
  native let ikChainSettings: array<IKChainSettings>;
}

enum animTransformChannel {
  PosX = 0,
  PosY = 1,
  PosZ = 2,
  RotX = 3,
  RotY = 4,
  RotZ = 5,
  ScaleX = 6,
  ScaleY = 7,
  ScaleZ = 8,
}

public native struct animTransformIndex {
  native let name: CName;
}

public native struct animTransformInfo {
  native let name: CName;
  native let parentName: CName;
  native let referenceTransformLs: QsTransform;
}

public native struct animTransformLink {
  native let node: wref<animAnimNode_TransformValue>;
}

public native struct animTransformMask {
  native let index: Int32;
  native let weight: Float;
}

public native struct animTwistOutput {
  native let positiveScale: Float;
  native let negativeScale: Float;
  native let twistAxis: animAxis;
  native let twistedTransform: animTransformIndex;
  native let outputAngleTrack: animNamedTrackIndex;
}

public native class animUncompressedAllAnglesMotionExtraction extends animIMotionExtraction {
  native let duration: Float;
  native let frames: array<Transform>;
}

public native class animUncompressedMotionExtraction extends animIMotionExtraction {
  native let frames: array<Vector4>;
  native let duration: Float;
}

enum animVectorCoordinateType {
  X = 0,
  Y = 1,
  Z = 2,
  W = 3,
}

public native struct animVectorLink {
  native let node: wref<animAnimNode_VectorValue>;
}

public native class animVisualTagCondition extends animIStaticCondition {
  native let visualTag: CName;
}

public native struct appearanceAlternateAppearanceEntry {
  native let Original: CName;
  native let Alternate: CName;
  native let AlternateAppearanceIndex: Uint8;
}

public native class appearanceAppearanceDefinition extends ISerializable {
  native let name: CName;
  native let parentAppearance: CName;
  native let partsMasks: array<array<CName>>;
  native let partsValues: array<appearanceAppearancePart>;
  native let partsOverrides: array<appearanceAppearancePartOverrides>;
  native let proxyMesh: ResourceAsyncRef; // raRef<CMesh>
  native let forcedLodDistance: Uint8;
  native let proxyMeshAppearance: CName;
  native let cookedDataPathOverride: ResourceAsyncRef; // raRef<CResource>
  native let parametersBuffer: entEntityParametersBuffer;
  native let visualTags: redTagList;
  native let inheritedVisualTags: redTagList;
  native let hitRepresentationOverrides: array<HitRepresentationOverride>;
  native let resolvedDependencies: array<ResourceAsyncRef>;
  native let looseDependencies: array<ResourceAsyncRef>;
  native let censorFlags: Uint32;
}

public native struct appearanceAppearancePart {
  native let resource: ResourceAsyncRef; // raRef<entEntityTemplate>
}

public native struct appearanceAppearancePartOverrides {
  native let partResource: ResourceAsyncRef; // raRef<entEntityTemplate>
  native let componentsOverrides: array<appearancePartComponentOverrides>;
}

public native class appearanceAppearanceResource extends resStreamedResource {
  native let alternateAppearanceSettingName: CName;
  native let alternateAppearanceSuffixes: array<CName>;
  native let alternateAppearanceMapping: array<appearanceAlternateAppearanceEntry>;
  native let censorshipMapping: array<appearanceCensorshipEntry>;
  native let Wounds: array<ref<entdismembermentWoundResource>>;
  native let DismEffects: array<ref<entdismembermentEffectResource>>;
  native let DismWoundConfig: entdismembermentWoundsConfigSet;
  native let baseType: CName;
  native let baseEntityType: CName;
  native let baseEntity: ResourceAsyncRef; // raRef<entEntityTemplate>
  native let partType: CName;
  native let preset: CName;
  native let appearances: array<ref<appearanceAppearanceDefinition>>;
  native let commonCookData: ResourceAsyncRef; // raRef<appearanceCookedAppearanceData>
  native let proxyPolyCount: Int32;
  native let forceCompileProxy: Bool;
  native let generatePlayerBlockingCollisionForProxy: Bool;
}

public native struct appearanceCensorshipEntry {
  native let Original: CName;
  native let Censored: CName;
  native let CensorFlags: Uint32;
}

public native struct appearanceChunkMaskSettings {
  native let chunksIds: array<Uint64>;
  native let meshLayout: array<Uint32>;
  native let meshGeometryHash: Uint64;
}

public native class appearanceCookedAppearanceData extends CResource {
  native let dependencies: array<ResourceRef>;
  native let totalSizeOnDisk: Uint32;
}

public native struct appearancePartComponentOverrides {
  native let componentName: CName;
  native let meshAppearance: CName;
  native let chunkMask: Uint64;
  native let useCustomTransform: Bool;
  native let initialTransform: Transform;
  native let visualScale: Vector3;
  native let acceptDismemberment: Bool;
}

public native class AppearancesReadyTPPRepresentationEvent extends Event {}

public native class AreaShapeOutline extends ISerializable {
  native let points: array<Vector3>;
  native let height: Float;
}

public native class at_uiBackendUtility extends IScriptable {
  public final native func ClickOnWidget()
  public final native func FindWidgetByATID()
  public final native func GetAllWidgetGameControllersOfType()
  public final native func GetWidgetGameControllerOfType()
}

public native class AtmosphereAreaSettings extends IAreaSettings {
  native let skydomeColor: CurveDataHDRColor;
  native let skylightColor: CurveDataHDRColor;
  native let groundReflectance: CurveDataHDRColor;
  native let sunMinZ: CurveDataFloat;
  native let horizonMinZ: CurveDataFloat;
  native let horizonFalloff: CurveDataFloat;
  native let turbidity: CurveDataFloat;
  native let lutTurbidity: CurveDataFloat;
  native let artisticDarkeningColor: CurveDataHDRColor;
  native let artisticDarkeningStartPoint: CurveDataFloat;
  native let artisticDarkeningEndPoint: CurveDataFloat;
  native let artisticDarkeningExponent: CurveDataFloat;
  native let sunColor: CurveDataHDRColor;
  native let sunFalloff: CurveDataFloat;
  native let rayTracedSunShadowRange: CurveDataFloat;
  native let moonColor: CurveDataHDRColor;
  native let moonFalloff: CurveDataFloat;
  native let moonGlowIntensity: CurveDataFloat;
  native let moonGlowFalloff: CurveDataFloat;
  native let moonTexture: ResourceRef; // rRef<CBitmapTexture>
  native let galaxyIntensity: CurveDataFloat;
  native let starMapIntensity: CurveDataFloat;
  native let starMapBrightScale: CurveDataFloat;
  native let starMapDimScale: CurveDataFloat;
  native let starMapConstelationsScale: CurveDataFloat;
  native let starCornerLuminanceFix: CurveDataFloat;
  native let starMapTexture: ResourceRef; // rRef<CCubeTexture>
  native let galaxyTexture: ResourceRef; // rRef<CBitmapTexture>
  native let probeColorOverrideHorizon: CurveDataHDRColor;
  native let probeAlphaOverrideHorizon: CurveDataFloat;
  native let probeColorOverrideZenith: CurveDataHDRColor;
  native let probeAlphaOverrideZenith: CurveDataFloat;
}

public native class AttachEntity extends Event {
  native let entity: wref<Entity>;
}

public native struct AttachmentSlotData {
  native let slotID: TweakDBID;
  native let itemObject: ref<ItemObject>;
  native let activeItemID: ItemID;
  native let prevItemID: ItemID;
  native let appearanceItemID: ItemID;
}

public native class AttitudePrereq extends IPrereq {
  native let attitude: EAIAttitude;
}

public native class AttitudePrereqState extends PrereqState {}

public native class attrAttribute extends ISerializable {}

public native class attrCancelable extends attrAttribute {}

public native class attrChoice extends attrAttribute {
  native let tions: array<String>;
}

public native class attrCommand extends attrAttribute {}

public native class attrDynamicChoice extends attrAttribute {}

public native class attrIcon extends attrAttribute {
  native let onName: String;
}

public native class attrLabel extends attrAttribute {
  native let xt: String;
}

public native class attrLongOperation extends attrAttribute {}

public native class attrMinMax extends attrAttribute {
  native let n: Float;
  native let x: Float;
}

public native class attrMinMaxVector3 extends attrAttribute {
  native let n: Vector3;
  native let x: Vector3;
}

public native class attrNotExposed extends attrAttribute {}

public native class attrReportsProgress extends attrAttribute {}

public native class attrSlider extends attrAttribute {
  native let ep: Float;
}

public native class attrSoftMinMax extends attrAttribute {
  native let n: Float;
  native let x: Float;
}

public native class attrToggleBtn extends attrAttribute {
  native let nLabel: String;
}

public native class attrTooltip extends attrAttribute {
  native let xt: String;
}

public native class audioAccumulatedSoundDecoratorMetadata extends audioEmitterMetadata {
  native let accumulatedSounds: array<CName>;
  native let inSpammingMode: Bool;
  native let fadeParam: CName;
  native let soundTimeout: Float;
  native let loopStart: CName;
  native let loopEnd: CName;
  native let spammingSound: CName;
  native let spammingSoundInterval: Float;
}

public native class audioAcousticConstantsPreset extends audioAudioMetadata {
  native let dopplerFactor: Float;
  native let speedOfSound: Float;
  native let wideInteriorLimit: Float;
  native let enclosedCeilingDistance: Float;
  native let urbanNarrowDistance: Float;
  native let urbanStreetDistance: Float;
  native let exteriorWideAltitude: Float;
  native let elevatedOpenDistance: Float;
  native let ambExteriorCeilingMinDistance: Float;
  native let ambExteriorCeilingMaxDistance: Float;
  native let badlandsWideRelativeAltitude: Float;
  native let repositioningStandardZoomFactor: Float;
  native let repositioningScanningZoomFactor: Float;
  native let repositioningVoStandardZoomFactor: Float;
  native let repositioningVoScanningZoomFactor: Float;
  native let groupingExcludedVisualTags: array<CName>;
  native let windowEventName: CName;
  native let maxWindowOffset: Float;
}

public native class audioAcousticsEmitterMetadata extends audioEmitterMetadata {
  native let obstuctionEnabled: Bool;
  native let occlusionEnabled: Bool;
  native let repositioningEnabled: Bool;
  native let obstructionFadeTime: Float;
  native let enableOutdoorness: Bool;
  native let postDopplerFactor: Bool;
  native let dopplerParameter: CName;
  native let ignoreOcclusionRadius: Float;
  native let elevateSource: Bool;
  native let leakingFloorHack: Bool;
}

public native class audioAcousticZoneMetadata extends audioAudioMetadata {
  native let priority: Int32;
  native let bleadingDistance: Float;
  native let eventsOnEnter: array<CName>;
  native let eventsOnExit: array<CName>;
  native let eventsOnActive: array<CName>;
  native let soundBanks: array<CName>;
  native let parameters: array<audioAcousticZoneParameterMapItem>;
  native let reverbSettings: CName;
  native let voReverbSettings: CName;
  native let footstepMaterialOverride: CName;
}

public native class audioAcousticZoneParameterMapItem extends audioAudioMetadata {
  native let param: CName;
  native let value: Float;
  native let enterCurveTime: Float;
  native let exitCurveTime: Float;
}

enum audioAdvertIndoorFilter {
  Always = 0,
  OnlyIndoor = 1,
  OnlyOutdoor = 2,
}

public native class audioAdvertMetadata extends audioEmitterMetadata {
  native let advertSoundNames: array<CName>;
  native let minSilenceTime: Float;
  native let maxSilenceTime: Float;
  native let minDistance: Float;
  native let filter: audioAdvertIndoorFilter;
}

public native class audioAdvertSoundMetadata extends audioAudioMetadata {
  native let audioEvent1: CName;
  native let audioEvent2: CName;
  native let audioEvent3: CName;
  native let audioEvent4: CName;
  native let useCustomDelays: Bool;
  native let speedOfSound: Float;
  native let soundDelay1: Float;
  native let soundDelay2: Float;
  native let soundDelay3: Float;
  native let soundDelay4: Float;
}

public native class audioAmbientAreaContextActivatedASTCD extends audioAudioStateTransitionConditionData {
  native let areaMixingContext: CName;
}

public native struct audioAmbientAreaGroupingSettings {
  native let GroupCountTag: CName;
  native let GroupCountRtpc: CName;
  native let GroupAvgDistanceRtpc: CName;
  native let groupingVariant: audioAmbientGroupingVariant;
  native let MinDistance: Float;
  native let MaxDistance: Float;
  native let GroupingVerticallimit: Float;
}

public native class audioAmbientAreaNotifier extends worldITriggerAreaNotifer {
  native let Settings: ref<audioAmbientAreaSettings>;
  native let usePhysicsObstruction: Bool;
  native let occlusionEnabled: Bool;
  native let acousticRepositioningEnabled: Bool;
  native let obstructionChangeTime: Float;
  native let overrideRolloff: Bool;
  native let rolloffOverride: Float;
  native let useAutoOutdoorness: Bool;
}

public native class audioAmbientAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class audioAmbientAreaSettings extends audioAudioMetadata {
  native let MetadataParent: CName;
  native let EmitterDecorator: CName;
  native let Priority: Int32;
  native let EventsOnEnter: array<audioAudEventStruct>;
  native let EventsOnExit: array<audioAudEventStruct>;
  native let EventsOnActive: array<audioAudEventStruct>;
  native let SoundBanks: array<audioSoundBankStruct>;
  native let Switches: array<audioAudSwitch>;
  native let Parameters: array<audioAudParameter>;
  native let Reverb: CName;
  native let reverbTransitionTime: Float;
  native let VoReverb: CName;
  native let FootstepMaterialOverride: CName;
  native let soundsLimitingSettings: CName;
  native let isMusic: Bool;
  native let groupingSettings: audioAmbientAreaGroupingSettings;
  native let quadSettings: audioQuadEmitterSettings;
  native let outerDistance: Float;
  native let verticalOuterDistance: Float;
  native let insideSourceDistance: Float;
  native let eventOverrides: CName;
  native let outdoornessOverride: Bool;
  native let outdoorness: Float;
  native let mergeRoomsWithinArea: Bool;
  native let mixingContext: CName;
  native let ambientPaletteEntries: array<audioAmbientPaletteEntry>;
}

enum audioAmbientGroupingVariant {
  AllEntities = 0,
  IndoorEntities = 1,
  OutdoorEntities = 2,
  AllEntitiesAllDirections = 3,
  IndoorAllDirections = 4,
  OutdoorAllDirections = 5,
  SameRoomEntities = 6,
  DifferentRoomEntities = 7,
  DistanceExclusion = 8,
}

public native struct audioAmbientPaletteBrush {
  native let distributionBucketSize: Float;
  native let virtualHearingRadius: Float;
  native let hearingDistanceCooldown: Float;
  native let eventsPool: array<CName>;
  native let radioStationMetadata: CName;
}

public native class audioAmbientPaletteBrushCategory extends audioAudioMetadata {
  native let brushes: ref<audioAmbientPaletteBrushDictionary>;
}

public native class audioAmbientPaletteBrushDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioAmbientPaletteBrushDictionaryItem>;
}

public native class audioAmbientPaletteBrushDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: audioAmbientPaletteBrush;
}

public native struct audioAmbientPaletteEntry {
  native let brushCategory: CName;
}

public native class audioAnimationOverrideDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioAnimationOverrideDictionaryItem>;
}

public native class audioAnimationOverrideDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioAnimationOverrideMetadata extends audioAudioMetadata {
  native let animationOverrides: ref<audioAnimationOverrideDictionary>;
}

public native struct audioAnyStateTransitionEntry {
  native let isDisabled: Bool;
  native let sourceStateId: Uint8;
  native let targetStateId: Uint8;
  native let transitionTime: Float;
}

public native class audioAppearancesGroup extends audioAudioMetadata {
  native let appearances: array<CName>;
}

public native struct audioAppearanceToFoleyLoopMetadata {
  native let appearances: array<CName>;
  native let loop: audioFoleyLoopMetadata;
}

public native struct audioAppearanceToNPCMetadata {
  native let appearances: array<CName>;
  native let foleyNPCMetadata: CName;
}

public native struct audioAppearanceToPlayerMetadata {
  native let appearances: array<CName>;
  native let foleyPlayerMetadata: CName;
  native let priority: audioFoleyItemPriority;
}

public abstract native struct audioApplySoundPositionStrategy {}

public native class audioAudBulletTimeModeMap extends audioAudioMetadata {
  native let bulletTimeMapItems: array<audioAudBulletTimeModeMapItem>;
}

public native class audioAudBulletTimeModeMapItem extends audioAudioMetadata {
  native let enterEvent: CName;
  native let exitEvent: CName;
  native let timeModeRTPC: CName;
}

public native struct audioAudEventStruct {
  native let event: CName;
}

public native class audioAudioAttractAreaSounds extends audioAudioMetadata {
  native let NPCgrunts: array<audioDynamicEventsPerVisualTags>;
  native let environmentSounds: array<audioDynamicEventsWithInterval>;
}

public native class audioAudioEventArray extends ISerializable {
  native let isSortedByRedHash: Bool;
  native let events: array<audioAudioEventMetadataArrayElement>;
  native let switchGroup: array<audioAudioEventMetadataArrayElement>;
  native let switch: array<audioAudioEventMetadataArrayElement>;
  native let stateGroup: array<audioAudioEventMetadataArrayElement>;
  native let state: array<audioAudioEventMetadataArrayElement>;
  native let gameParameter: array<audioAudioEventMetadataArrayElement>;
  native let bus: array<audioAudioEventMetadataArrayElement>;
}

public native class audioAudioEventMetadata extends ISerializable {
  native let wwiseId: Uint32;
  native let maxAttenuation: Float;
  native let minDuration: Float;
  native let maxDuration: Float;
  native let isLooping: Bool;
  native let stopActionEvents: array<CName>;
  native let tags: array<CName>;
}

public native class audioAudioEventPostedASTCD extends audioAudioStateTransitionConditionData {
  native let audioEvent: CName;
}

public native struct audioAudioFoliageMaterial {
  native let loopStart: CName;
  native let loopEnd: CName;
}

public native class audioAudioFoliageMaterialDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioAudioFoliageMaterialDictionaryItem>;
}

public native class audioAudioFoliageMaterialDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: audioAudioFoliageMaterial;
}

public native class audioAudioFoliageMetadata extends audioAudioMetadata {
  native let loopStartEvent: CName;
  native let loopStopEvent: CName;
  native let locomotionTotalVelocityParam: CName;
  native let locomotionTotalVelocityThreshold: Float;
  native let locomotionAngularVelocityMultiplier: Float;
  native let minFoliageMeshVolumeThreshold: Float;
  native let maxFoliageMeshHeight: Float;
  native let playerInsideRequiredPercentage: Float;
  native let foliageMaterials: ref<audioAudioFoliageMaterialDictionary>;
}

public native class audioAudioMaterialMetadataMapItem extends audioAudioMetadata {
  native let footstepsMetadata: CName;
  native let npcFootstepsMetadata: CName;
  native let ragdollMetadata: CName;
  native let physicalMaterial: CName;
  native let obstructionData: CName;
  native let reflectionParams: CName;
  native let meleeMaterialName: CName;
  native let vehicleMaterialName: CName;
  native let foliageMaterialName: CName;
  native let foliagePaletteTag: CName;
  native let meleeMaterialType: audioMeleeMaterialType;
}

public abstract native class audioAudioMetadata extends audioAudioMetadataBase {}

public abstract native class audioAudioMetadataBase extends ISerializable {
  native let name: CName;
}

public native class audioAudioSceneData extends audioAudioMetadata {
  native let anyStateArray: [audioAudioStateData; 1];
  native let states: array<audioAudioStateData>;
  native let anyStateTransitionsTable: array<audioAnyStateTransitionEntry>;
  native let voLineSignals: array<audioVoLineSignal>;
  native let signalLeadingToShutdown: CName;
  native let templateScene: CName;
  native let templateSceneStateOverrides: array<audioAudioSceneStateOverride>;
  native let templateSceneSignalOverrides: array<audioAudioSceneSignalOverride>;
}

public native class audioAudioSceneDefaults extends audioAudioMetadata {
  native let parameters: array<audioAudSimpleParameter>;
}

public native class audioAudioSceneDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioAudioSceneDictionaryItem>;
}

public native class audioAudioSceneDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native struct audioAudioSceneSignalOverride {
  native let templateSignal: CName;
  native let signalOverride: CName;
}

public native class audioAudioScenesMap extends audioAudioMetadata {
  native let defaultScene: CName;
  native let scenesToActivateByQuestEvent: ref<audioAudioSceneDictionary>;
}

public native struct audioAudioSceneStateOverride {
  native let templateStateName: CName;
  native let enterEventOverride: CName;
  native let exitEventOverride: CName;
}

public native struct audioAudioSceneVariableReadActionData {
  native let name: CName;
  native let comparer: audioNumberComparer;
  native let value: Int32;
}

public native struct audioAudioSceneVariableWriteActionData {
  native let name: CName;
  native let operation: audioNumberOperation;
  native let value: Int32;
}

public native struct audioAudioStateData {
  native let stateName: CName;
  native let enterEvent: CName;
  native let exitEvent: CName;
  native let exitTransitions: array<audioAudioStateTransitionData>;
  native let mixingActions: array<audioMixingActionData>;
  native let interruptionSources: array<CName>;
  native let writeVariableActions: array<audioAudioSceneVariableWriteActionData>;
}

public abstract native class audioAudioStateTransitionConditionData extends audioAudioMetadata {}

public native struct audioAudioStateTransitionData {
  native let targetStateId: Uint8;
  native let allConditionsFulfilled: Bool;
  native let transitionTime: Float;
  native let exitTime: Float;
  native let exitSignal: CName;
  native let readVariableActions: array<audioAudioSceneVariableReadActionData>;
  native let conditions: array<CName>;
}

enum audioAudioVehicleCurve {
  ThrottleInput = 0,
  RPM = 1,
  Gear = 2,
}

public native struct audioAudParameter {
  native let name: CName;
  native let value: Float;
  native let enterCurveType: audioESoundCurveType;
  native let enterCurveTime: Float;
  native let exitCurveType: audioESoundCurveType;
  native let exitCurveTime: Float;
}

public native struct audioAudSimpleParameter {
  native let name: CName;
  native let value: Float;
}

public native struct audioAudSwitch {
  native let name: CName;
  native let value: CName;
}

public native struct audioAuxiliaryMetadata {
  native let physicalPropSettings: CName;
}

public native struct audioBaseAudioSquadHandler {}

public native struct audioBaseRadioAnnouncementPlayer {}

enum audiobreathingEventTag {
  Walk = 0,
  Jog = 1,
  Run = 2,
  Sneak = 3,
  Cloth = 4,
  FootStepRegular = 5,
  FootStepSprint = 6,
  LandingRegular = 7,
  LandingHard = 8,
  LandingVeryHard = 9,
  Climb = 10,
  Jump = 11,
  Player = 12,
  Stop = 13,
  Drop_Body = 14,
  Pick_Up_Body = 15,
  Standing_Event = 16,
}

enum audiobreathingLoopBehavior {
  TimedBreathing = 0,
  BreathEvery2ndStep = 1,
  BreathEveryStep = 2,
  HoldingBreath = 3,
}

public native class audioBreathingSettings extends audioAudioMetadata {
  native let exhaustionRtpc: CName;
  native let idleFadeOutRtpc: CName;
  native let initialState: CName;
}

public native class audioBreathingStateMetadata extends audioAudioMetadata {
  native let inhaleSound: CName;
  native let exhaleSound: CName;
  native let paramChangeSpeed: Float;
  native let targetBpm: Float;
  native let targetTimeDistortion: Float;
  native let stateMinimalTime: Float;
  native let exhaustionChangeSpeed: Float;
  native let targetExhaustion: Float;
  native let loopBehavior: audiobreathingLoopBehavior;
  native let startStateFromBreath: Bool;
}

public native class audioBreathingStateTransitionMetadata extends audioAudioMetadata {
  native let fromNames: array<CName>;
  native let toName: CName;
  native let transitionStateName: CName;
  native let conditionType: audioBreathingTransitionType;
  native let conditionComparator: audioBreathingTransitionComparator;
  native let value: CName;
  native let eventTags: array<audiobreathingEventTag>;
  native let isImmediate: Bool;
}

public native class audioBreathingTemporaryStateMetadata extends audioAudioMetadata {
  native let inhaleSound: CName;
  native let exhaleSound: CName;
  native let paramChangeSpeed: Float;
  native let targetBpm: Float;
  native let targetTimeDistortion: Float;
  native let time: Float;
  native let exhaustionChangeSpeed: Float;
  native let targetExhaustion: Float;
  native let loopBehavior: audiobreathingLoopBehavior;
  native let startStateFromBreath: Bool;
}

enum audioBreathingTransitionComparator {
  Less = 0,
  Equal = 1,
  Greater = 2,
}

enum audioBreathingTransitionType {
  PlayerSpeed = 0,
  Event = 1,
  AllEventTags = 2,
  AnyEventTag = 3,
}

public native class audioBreathingUnderwaterMetadata extends audioAudioMetadata {
  native let inhaleSound: CName;
  native let exhaleSound: CName;
  native let emergenceSound: CName;
  native let struggledEmergenceSound: CName;
  native let divingSuitRTPC: CName;
  native let BPM: Float;
  native let lowOxygen: Float;
}

public native class audioBulletImpactSettings extends audioEntitySettings {
  native let lowImpactSound: CName;
  native let medImpactSound: CName;
  native let hiImpactSound: CName;
  native let critImpactSound: CName;
  native let npcImpactSound: CName;
  native let mediumDamageDistance: Float;
  native let highDamageDistance: Float;
}

enum audioClassificationMethod {
  HasAnyTag = 0,
  HasAllTags = 1,
  NameEquals = 2,
  EventNameEquals = 3,
  HasAllEventTags = 4,
}

public native class audioCombatVoManagerSettings extends audioAudioMetadata {
  native let thresholdDbForCombatDialog: Float;
  native let maxVoHearableHorizontalDistance: Float;
  native let maxVoHearableVerticalDistance: Float;
  native let maxVoVisibleDistance: Float;
  native let triggerVoEventBufferTime: Float;
  native let triggerIdleChattersTime: Float;
  native let minNoVOTimeNeededToTryPlayingGenericVO: Float;
  native let specificVoicesetVoVariationMinRepeatTime: Float;
  native let forceApucVoiceTagSelectionProbability: Float;
  native let voiceTagSelectionRandomTimeOffset: Float;
  native let genericRelaxedVOContexts: array<CName>;
  native let genericFearVOContexts: array<CName>;
  native let genericAlertedVOContexts: array<CName>;
  native let genericCombatVOContexts: array<CName>;
  native let genericCombatLosingVOContexts: array<CName>;
  native let genericCombatSingleEnemyVOContexts: array<CName>;
}

public native class audioCombatVoSettings extends audioAudioMetadata {
  native let answerGroupName: CName;
  native let isPlayerAlly: Bool;
  native let contexts: CName;
  native let voTriggerVariations: CName;
  native let generalGruntSettings: audioGeneralVoiceGruntSettings;
  native let voTriggerLimits: audioVoiceTriggerLimits;
  native let overridingVoTriggerLimits: CName;
  native let barkTriggerLimits: audioVoiceTriggerLimits;
  native let gruntTriggerLimits: audioVoiceTriggerLimits;
  native let minDamageToInterruptVoWithPainShort: Float;
  native let minDamageToInterruptVoWithPainLong: Float;
}

public native class audioCombatVoTriggerVariationsMap extends audioAudioMetadata {
  native let voTriggerVariations: array<audioCombatVoTriggerVariationsMapItem>;
}

public native struct audioCombatVoTriggerVariationsMapItem {
  native let name: CName;
  native let numberOfVariations: Int32;
  native let shuffle: Bool;
}

public native struct audioCommonEntitySettings {
  native let onAttachEvent: CName;
  native let onDetachEvent: CName;
  native let stopAllSoundsOnDetach: Bool;
}

public native class audioCompoundEmitterMetadata extends audioEmitterMetadata {
  native let childrenNames: array<CName>;
}

public native class audioContextualAudEventMap extends audioAudioMetadata {
  native let contextualAudEventMapItems: array<audioContextualAudEventMapItem>;
}

public native class audioContextualAudEventMapItem extends audioAudioMetadata {
  native let context: CName;
  native let event: CName;
}

public native struct audioContextualVoiceGrunt {
  native let regularGrunt: CName;
  native let stealthGrunt: CName;
}

public native struct audioContextualVoiceGruntSettings {
  native let painShort: audioContextualVoiceGrunt;
  native let effort: audioContextualVoiceGrunt;
}

public native struct audioConversationCharacterCondition {
  native let voiceTag: CName;
  native let characterRecordId: Uint64;
  native let actorContextName: CName;
  native let actorsInitialWorkspotNodeRefHash: Uint64;
}

public native struct audioConversationItemMetadata {
  native let sceneFile: CName;
  native let characterConditions: array<audioConversationCharacterCondition>;
  native let shouldSceneInstanceBeSaved: Bool;
}

public native class audioConversationMetadata extends audioAudioMetadata {
  native let conversations: array<audioConversationItemMetadata>;
}

enum audioConversationSavingStrategy {
  Default = 0,
  Save = 1,
  DontSave = 2,
}

public native class audioCookedMetadataResource extends CResource {
  native let entries: array<ref<audioAudioMetadata>>;
}

public native class audioCpoConversation extends audioAudioMetadata {
  native let characterOne: audioVoCpoCharacter;
  native let characterTwo: audioVoCpoCharacter;
  native let voTriggers: array<CName>;
}

public abstract native class audioCustomEmitterMetadata extends audioAudioMetadata {}

public native class audioDefaultMixingSignposts extends audioAudioMetadata {
  native let endOfCombat: CName;
  native let inCombat: CName;
  native let inStealth: CName;
  native let aiAlerted: CName;
  native let sceneBootstrapSignpost: CName;
  native let reservedSignposts: array<CName>;
}

public abstract native class audioDeviceSettings extends audioEntitySettings {
  native let deviceSettings: audioDeviceStateSettings;
}

public native struct audioDeviceStateSettings {
  native let powerRestoredSound: CName;
  native let powerCutSound: CName;
  native let turnOnSound: CName;
  native let turnOffSound: CName;
  native let breakingSound: CName;
}

public native struct audioDialogLineEventData {
  native let stringId: CRUID;
  native let context: locVoiceoverContext;
  native let expression: locVoiceoverExpression;
  native let isPlayer: Bool;
  native let isRewind: Bool;
  native let isHolocall: Bool;
  native let customVoEvent: CName;
  native let seekTime: Float;
  native let playbackSpeedParameter: Float;
}

public native class audioDirectorSystemSettings extends audioAudioMetadata {
  native let combatVoManagerSettingsName: CName;
  native let singleConversationMinRepeatTime: Float;
  native let allConversationsMinRepeatTime: Float;
  native let maxVelocityMagnitudeToConsiderPlayerVehicleInactive: Float;
  native let maxVelocityMagnitudeToConsiderTrafficVehicleIdle: Float;
  native let playerInactiveMinTimeNeededToEngageMovingFaster: Float;
  native let vehEngageMovingFasterInterpolation: audioVehicleEngageMovingFasterInterpolationData;
  native let playerBrakeEventCooldown: Float;
  native let trafficSpeedRC: Float;
  native let trafficAccelerationRC: Float;
  native let trafficRpmRC: Float;
  native let trafficSlipRatioSkidThreshold: Float;
  native let trafficHornSingleVehicleCooldown: Float;
  native let trafficHornAllVehiclesCooldown: Float;
  native let trafficHornMaxDistanceRangeToPlayer: Float;
  native let overHeadVisibilityMaxOcclusion: Float;
  native let overHeadVisibilityMaxObstruction: Float;
  native let conversationMixCooldown: Float;
  native let enemyPingCooldown: Float;
  native let idleTimeBeforeAllowingOwMusicChange: Float;
  native let drivingStreamingAmbientEmittersDistanceRolloff: Float;
  native let lowHealthStateMaxTime: Float;
  native let lowGearMaxTrafficSpeed: Float;
  native let lowGearAccelerationThreshold: Float;
  native let mediumGearMaxTrafficSpeed: Float;
  native let mediumGearAccelerationThreshold: Float;
  native let highGearAccelerationThreshold: Float;
}

public native class audioDismembermentSoundSettings extends audioAudioMetadata {
  native let headEvent: CName;
  native let armEvent: CName;
  native let legEvent: CName;
}

public native class audioDistanceSoundDecoratorMetadata extends audioEmitterMetadata {
  native let onEnter: CName;
  native let onLeave: CName;
  native let triggerDistance: Float;
  native let stopOnlyVirtualSounds: Bool;
}

public native class audioDoorDecoratorMetadata extends audioEmitterMetadata {
  native let startOpen: CName;
  native let startClose: CName;
  native let endOpen: CName;
  native let endClose: CName;
  native let openLoop: CName;
  native let closeLoop: CName;
  native let openTime: Float;
  native let closeTime: Float;
}

public native class audioDoorsSettings extends audioDeviceSettings {
  native let openEvent: CName;
  native let openFailedEvent: CName;
  native let closeEvent: CName;
  native let lockEvent: CName;
  native let unlockEvent: CName;
  native let sealEvent: CName;
  native let soundBank: CName;
}

public native class audioDroneGlobalSettings extends audioAudioMetadata {
  native let speedRtpc: CName;
  native let thrustRtpc: CName;
}

public native class audioDroneMetadata extends audioCustomEmitterMetadata {
  native let boneName: CName;
  native let engineStart: CName;
  native let engineStop: CName;
  native let combatEnter: CName;
  native let combatExit: CName;
  native let targetLost: CName;
  native let idle: CName;
  native let initialReaction: CName;
  native let investigationIgnore: CName;
  native let noClearShot: CName;
  native let targetComplies: CName;
  native let lookForIntruder: CName;
  native let droneDestroyed: CName;
  native let droneDefeated: CName;
  native let commandHolsterWeapon: CName;
  native let commandLeaveArea: CName;
  native let finalWarning: CName;
  native let playDistance: Float;
  native let decorators: array<CName>;
}

public native struct audioDynamicEventsPerVisualTags {
  native let visualTags: array<CName>;
  native let grunts: array<audioDynamicEventsWithInterval>;
}

public native struct audioDynamicEventsWithInterval {
  native let events: array<CName>;
  native let interval: Float;
}

public native class audioDynamicReverbSettings extends audioAudioMetadata {
  native let reverbType: audioDynamicReverbType;
  native let crossover1: audioReverbCrossoverParams;
  native let crossover2: audioReverbCrossoverParams;
  native let maxDistance: Float;
  native let smallReverb: CName;
  native let smallReverbMaxDistance: Float;
  native let smallReverbFadeOutThreshold: Float;
  native let mediumReverb: CName;
  native let largeReverb: CName;
  native let vehicleReverb: CName;
  native let overrideWeaponTail: Bool;
  native let sourceBasedReverbSet: CName;
  native let weaponTailType: audioWeaponTailEnvironment;
  native let echoPositionType: audioEchoPositionType;
  native let reportPositionType: audioEchoPositionType;
}

enum audioDynamicReverbType {
  Dynamic = 0,
  StaticSmall = 1,
  EnvironmentSmallStaticMedium = 2,
  DynamicSource = 3,
}

enum audioEchoPositionType {
  DynamicEnvironment = 0,
  Simple = 1,
}

public native class audioEditorSelectedData extends audioAudioMetadata {
  native let selectedWeaponConfigurationName: CName;
  native let selectedFootstepsEventName: CName;
}

public native class audioEditorSelectedMeleeWeapon extends audioAudioMetadata {
  native let selectedWeaponConfigurationName: CName;
}

public native class audioElevatorSettings extends audioEntitySettings {
  native let musicEvents: audioMusicController;
  native let movementEvents: audioLoopingSoundController;
  native let callingEvent: CName;
  native let destinationReachedEvent: CName;
  native let panelSelectionEvent: CName;
}

public native class audioEmitter extends IPlacedComponent {
  native let EmitterName: CName;
  native let EmitterType: audioEntityEmitterContextType;
  native let OnAttach: gameAudioSyncs;
  native let OnDetach: gameAudioSyncs;
  native let updateDistance: Float;
  native let emitterMetadataName: CName;
  native let Tags: array<CName>;
  native let TagList: redTagList;
}

public abstract native class audioEmitterMetadata extends audioAudioMetadata {}

enum audioEnemyState {
  InCombat = 0,
  Alerted = 1,
  Afraid = 2,
  Alive = 3,
  Dead = 4,
}

public native class audioEnemyStateCountASTCD extends audioAudioStateTransitionConditionData {
  native let enemiesState: audioEnemyState;
  native let countComparer: audioNumberComparer;
  native let enemiesCount: Uint32;
}

enum audioEntityEmitterContextType {
  Entity_Emitter = 0,
  Radio_Emitter = 2,
}

public native struct audioEntityEmitterSettings {
  native let emitterName: CName;
  native let positionName: CName;
  native let emitterDecorators: array<CName>;
  native let keepAlive: Bool;
  native let isObjectPerPositionEmitter: Bool;
}

public native class audioEntityMetadata extends audioAudioMetadata {
  native let fallbackDecorators: array<CName>;
  native let defaultPositionName: CName;
  native let defaultEmitterName: CName;
  native let isDefaultForEntityType: CName;
  native let preferSoundComponentPosition: Bool;
  native let priority: Int32;
  native let rigMetadata: CName;
  native let emitterDescriptions: array<audioEntityEmitterSettings>;
  native let alwaysCreateDefaultEmitter: Bool;
}

public abstract native class audioEntitySettings extends audioAudioMetadata {
  native let commonSettings: audioCommonEntitySettings;
  native let scanningSettings: audioScanningSettings;
  native let auxiliaryMetadata: audioAuxiliaryMetadata;
  native let emitterDecoratorMetadata: CName;
  native let preferSoundComponentPosition: Bool;
}

public native class audioEnvelopeSettings extends audioAudioMetadata {
  native let attackTime: Float;
  native let releaseTime: Float;
  native let holdTime: Float;
}

enum audioESoundCurveType {
  Log3 = 0,
  Sine = 1,
  InversedSCurve = 3,
  Linear = 4,
  SCurve = 5,
  Exp1 = 6,
  ReciprocalOfSineCurve = 7,
  Exp3 = 8,
}

public native class audioEventOverrideDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioEventOverrideDictionaryItem>;
}

public native class audioEventOverrideDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioEventOverrides extends audioAudioMetadata {
  native let eventOverrides: ref<audioEventOverrideDictionary>;
}

public native struct audioFlybySettings {
  native let movementSpeed: Float;
  native let flybyEvent: CName;
}

enum audioFoleyActionType {
  FastHeavy = 0,
  FastMedium = 1,
  FastLight = 2,
  NormalHeavy = 3,
  NormalMedium = 4,
  NormalLight = 5,
  SlowHeavy = 6,
  SlowMedium = 7,
  SlowLight = 8,
  Walk = 9,
  Run = 10,
}

public native class audioFoleyAppearanceName extends audioAudioMetadata {
  native let void: Bool;
}

public native class audioFoleyGlobalMetadata extends audioAudioMetadata {
  native let fadeoutTime: Float;
  native let fadeoutRtpc: CName;
}

enum audioFoleyItemPriority {
  P0 = 0,
  P1 = 1,
  P2 = 2,
  P3 = 3,
  P4 = 4,
  P5 = 5,
  P6 = 6,
}

enum audioFoleyItemType {
  Jacket = 0,
  Top = 1,
  Bottom = 2,
  Jewelry = 3,
}

public native class audioFoleyLoopMappingMetadata extends audioAudioMetadata {
  native let loopsPerAppearance: array<audioAppearanceToFoleyLoopMetadata>;
  native let loopsPerVisualTag: array<audioVisualTagToFoleyLoopMetadata>;
}

public native struct audioFoleyLoopMetadata {
  native let startEvent: CName;
  native let stopEvent: CName;
}

public native class audioFoleyNPCAppearanceMappingMetadata extends audioAudioMetadata {
  native let fallbackMetadata: CName;
  native let NPCsPerAppearance: array<audioAppearanceToNPCMetadata>;
  native let NPCsPerMainMaterial: array<audioVisualTagToNPCMetadata>;
  native let NPCsPerAdditive: array<audioVisualTagToNPCMetadata>;
}

public native class audioFoleyNPCMetadata extends audioAudioMetadata {
  native let fastHeavy: audioMeleeSound;
  native let fastMedium: audioMeleeSound;
  native let fastLight: audioMeleeSound;
  native let normalHeavy: audioMeleeSound;
  native let normalMedium: audioMeleeSound;
  native let normalLight: audioMeleeSound;
  native let slowHeavy: audioMeleeSound;
  native let slowMedium: audioMeleeSound;
  native let slowLight: audioMeleeSound;
  native let walk: audioMeleeSound;
  native let run: audioMeleeSound;
}

public native class audioFoleyPlayerAppearanceMappingMetadata extends audioAudioMetadata {
  native let fallbackMetadata: CName;
  native let jacketSettings: array<audioAppearanceToPlayerMetadata>;
  native let topSettings: array<audioAppearanceToPlayerMetadata>;
  native let bottomSettings: array<audioAppearanceToPlayerMetadata>;
  native let jewelrySettings: array<audioAppearanceToPlayerMetadata>;
}

public native struct audioFootstepDecalMaterialEntry {
  native let materialTag: CName;
  native let eventsByLocomotionState: ref<audioLocomotionStateEventDictionary>;
}

public native class audioFootstepDecalMaterialsMap extends audioAudioMetadata {
  native let closestDecalDetectionRadius: Float;
  native let entries: array<audioFootstepDecalMaterialEntry>;
}

public native class audioFootstepsMetadata extends audioAudioMetadata {
  native let defaultFootwearMetadata: CName;
  native let footwearMetadataArray: array<CName>;
  native let slideEvent: CName;
  native let onEnterSound: CName;
  native let onExitSound: CName;
  native let defaultFootwearVfxMetadata: CName;
  native let footwearVfxMetadataArray: array<CName>;
}

public native class audioFootwearType extends audioAudioMetadata {
  native let itemNames: array<CName>;
}

public native class audioFootwearVsMaterialMetadata extends audioAudioMetadata {
  native let footwearType: CName;
  native let skidEvent: CName;
  native let defaultFootstep: CName;
  native let locomotionStates: ref<audioLocomotionStateEventDictionary>;
  native let customActionEvents: ref<audioLocomotionCustomActionEventDictionary>;
}

public native class audioFootwearVsMaterialVfxMetadata extends audioAudioMetadata {
  native let footwearType: CName;
  native let defaultVfx: ResourceAsyncRef; // raRef<CResource>
  native let locomotionStates: ref<audioLocomotionStateVfxDictionary>;
  native let customActionVfx: ref<audioLocomotionCustomActionVfxDictionary>;
}

public native class AudioFunctionalTests extends IScriptable {
  public final native func IsSoundbankLoaded()
}

enum audioGameplayTier {
  Undefined = 0,
  Tier1_FullGameplay = 1,
  Tier2_StagedGameplay = 2,
  Tier3_LimitedGameplay = 3,
  Tier4_FPPCinematic = 4,
  Tier5_Cinematic = 5,
}

public native class audioGameplayTierActivatedASTCD extends audioAudioStateTransitionConditionData {
  native let gameplayTier: audioGameplayTier;
}

public native class audioGearSweetener extends audioAudioMetadata {
  native let gear: Uint32;
  native let rpmThreshold: Float;
  native let cooldown: Float;
  native let soundEvent: CName;
  native let burnoutFactor: Float;
}

public native struct audioGeneralVoiceGruntSettings {
  native let variationsCount: Uint32;
  native let painLong: CName;
  native let agressionShort: CName;
  native let agressionLong: CName;
  native let longFall: CName;
  native let death: CName;
  native let silentDeath: CName;
  native let grapple: CName;
  native let grappleMovement: CName;
  native let environmentalKnockdown: CName;
  native let bump: CName;
  native let curious: CName;
  native let fear: CName;
  native let jump: CName;
  native let effortLong: CName;
  native let deathShort: CName;
  native let greet: CName;
  native let laughHard: CName;
  native let laughSoft: CName;
  native let phone: CName;
  native let braindanceExcited: CName;
  native let braindanceFearful: CName;
  native let braindanceNeutral: CName;
  native let braindanceSexual: CName;
  native let contextualVoiceGruntSettings: audioContextualVoiceGruntSettings;
  native let gruntVariations: audioVoiceGruntVariations;
}

public native class audioGenericEntitySettings extends audioEntitySettings {}

public native class audioGenericGameplayEventOccurredASTCD extends audioAudioStateTransitionConditionData {
  native let gameplayEvent: CName;
}

public native class audioGenericNameEventDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioGenericNameEventItem>;
}

public native class audioGenericNameEventItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioGenericNameEventMap extends audioAudioMetadata {
  native let eventOverrides: ref<audioGenericNameEventDictionary>;
}

public native class audioGrenadeEntitySettings extends audioEntitySettings {
  native let explosionSound: CName;
}

public native class audioGroupingCountableMetadata extends audioEmitterMetadata {
  native let void: Bool;
}

public native class audioGroupingLimitMetadata extends audioAudioMetadata {
  native let limit: Float;
}

public native class audioGroupingShapeClassifierMetadata extends audioAudioMetadata {
  native let useAngle: Bool;
  native let minGroupSize: Float;
  native let maxGroupSize: Float;
  native let minGroupAngleSpread: Float;
  native let maxGroupAngleSpread: Float;
  native let floorLimit: Bool;
  native let ceilingLimit: Bool;
  native let minDistanceLimit: CName;
  native let maxDistanceLimit: CName;
}

public native class audioGroupingTagMetadata extends audioAudioMetadata {
  native let shape: CName;
  native let classificationMethod: audioClassificationMethod;
  native let inputEmitterName: CName;
  native let inputEventNames: array<CName>;
  native let inputTags: array<CName>;
  native let outputEventId: CName;
  native let minimalGroupCount: Float;
  native let fullGroupCount: Float;
}

public abstract native struct audioIBasicGameInterface {}

public native class audioInlinedAudioMetadata extends audioAudioMetadataBase {}

public native class audioKeySoundEventDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioKeySoundEventPairDictionaryItem>;
}

public native class audioKeySoundEventPairDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioKeyUiControlDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioKeyUiControlPairDictionaryItem>;
}

public native class audioKeyUiControlPairDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: audioUiControl;
}

public native class audioKeyUiSoundDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioKeyUiSoundPairDictionaryItem>;
}

public native class audioKeyUiSoundPairDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: audioUiSound;
}

public native struct audioLanguage {
  native let longName: String;
  native let codeName: String;
  native let hasVO: Bool;
}

public native class audioLanguageGameConfiguration extends audioAudioMetadata {
  native let langsInProject: array<audioLanguageMapItem>;
}

public native class audioLanguageMapItem extends audioAudioMetadata {
  native let language: audioLanguage;
}

public native struct audioLimitedSound {
  native let soundType: audioLimitedSoundType;
  native let attenuationDistance: Float;
}

enum audioLimitedSoundType {
  Locomotion = 0,
  Footsteps = 1,
  Impact = 2,
  Ragdoll = 3,
  Physics = 4,
  Destructibles = 5,
  Ono = 6,
  VO = 7,
}

public native class audioLocomotionCustomActionEventDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioLocomotionCustomActionEventDictionaryItem>;
}

public native class audioLocomotionCustomActionEventDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioLocomotionCustomActionType extends audioAudioMetadata {
  native let void: Bool;
}

public native class audioLocomotionCustomActionVfxDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioLocomotionCustomActionVfxDictionaryItem>;
}

public native class audioLocomotionCustomActionVfxDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: ResourceAsyncRef; // raRef<CResource>
}

public native class audioLocomotionEmitterMetadata extends audioEmitterMetadata {
  native let customMaterialLookup: CName;
  native let isPlayer: Bool;
  native let diveSuitName: CName;
}

public native class audioLocomotionEventMetadata extends audioAudioMetadata {}

public native class audioLocomotionStateEventDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioLocomotionStateEventDictionaryItem>;
}

public native class audioLocomotionStateEventDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioLocomotionStateType extends audioAudioMetadata {
  native let void: Bool;
}

public native class audioLocomotionStateVfxDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioLocomotionStateVfxDictionaryItem>;
}

public native class audioLocomotionStateVfxDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: ResourceAsyncRef; // raRef<CResource>
}

public native struct audioLocomotionWaterContextSettings {
  native let minDistanceBetweenImpulsesSquared: Float;
  native let impulseStrength: Float;
  native let impulseMinRadius: Float;
  native let impulseMaxRadius: Float;
}

public native class audioLocomotionWaterSettings extends audioAudioMetadata {
  native let defaultLegVfx: ResourceAsyncRef; // raRef<CResource>
  native let locomotionStatesLegVfx: ref<audioLocomotionStateVfxDictionary>;
  native let customActionLegVfx: ref<audioLocomotionCustomActionVfxDictionary>;
  native let minSpeedToApplyImpulses: Float;
  native let minHeelDepthToApplyImpulses: Float;
  native let shallowWaterDepth: Float;
  native let intermediateWaterDepth: Float;
  native let shallowSettings: audioLocomotionWaterContextSettings;
  native let intermediateSettings: audioLocomotionWaterContextSettings;
  native let deepSettings: audioLocomotionWaterContextSettings;
  native let minHeelDepthToSpawnFallFx: Float;
  native let minDownwardSpeedForRegularFall: Float;
  native let minDownwardSpeedForFastFall: Float;
  native let regularFallVfx: ResourceAsyncRef; // raRef<CResource>
  native let regularFallEvent: CName;
  native let fastFallVfx: ResourceAsyncRef; // raRef<CResource>
  native let fastFallEvent: CName;
}

public native class audioLoopedSoundEmitterMetadata extends audioEmitterMetadata {
  native let loopSound: CName;
}

public native struct audioLoopingSoundController {
  native let playEvent: CName;
  native let preStopEvent: CName;
  native let stopEvent: CName;
}

enum audioMaterialHardnessOverride {
  None = 0,
  SetAsSoft = 1,
  SetAsSolid = 2,
  SetAsHard = 3,
}

public native class audioMaterialMeleeSoundDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioMaterialMeleeSoundDictionaryItem>;
}

public native class audioMaterialMeleeSoundDictionaryItem extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: audioMeleeSound;
}

public native struct audioMaterialOverride {
  native let base: CName;
  native let override: CName;
}

public native struct audioMeleeAttackSettings {
  native let hitEvent: CName;
  native let penetratingHitEvent: CName;
  native let criticalHitEvent: CName;
  native let killingHitEvent: CName;
}

public native struct audioMeleeEvent {
  native let event: CName;
  native let params: array<audioAudSimpleParameter>;
}

enum audioMeleeHitPerMaterialType {
  Light = 0,
  Light_Hard = 1,
  Light_Soft = 2,
  Light_Solid = 3,
  Light_Flesh = 4,
  Light_Flesh_Head = 5,
  Light_Robot = 6,
  Light_Robot_Head = 7,
  Light_Android = 8,
  Light_Android_Head = 9,
  Light_Mech = 10,
  Light_Mech_Head = 11,
  Light_Water = 12,
  Normal = 13,
  Normal_Hard = 14,
  Normal_Soft = 15,
  Normal_Solid = 16,
  Normal_Flesh = 17,
  Normal_Flesh_Head = 18,
  Normal_Robot = 19,
  Normal_Robot_Head = 20,
  Normal_Android = 21,
  Normal_Android_Head = 22,
  Normal_Mech = 23,
  Normal_Mech_Head = 24,
  Normal_Water = 25,
  Heavy = 26,
  Heavy_Hard = 27,
  Heavy_Soft = 28,
  Heavy_Solid = 29,
  Heavy_Flesh = 30,
  Heavy_Flesh_Head = 31,
  Heavy_Robot = 32,
  Heavy_Robot_Head = 33,
  Heavy_Android = 34,
  Heavy_Android_Head = 35,
  Heavy_Mech = 36,
  Heavy_Mech_Head = 37,
  Heavy_Water = 38,
  Slash = 39,
  Slash_Hard = 40,
  Slash_Soft = 41,
  Slash_Solid = 42,
  Slash_Flesh = 43,
  Slash_Flesh_Head = 44,
  Slash_Robot = 45,
  Slash_Robot_Head = 46,
  Slash_Android = 47,
  Slash_Android_Head = 48,
  Slash_Mech = 49,
  Slash_Mech_Head = 50,
  Slash_Water = 51,
  Cut = 52,
  Cut_Hard = 53,
  Cut_Soft = 54,
  Cut_Solid = 55,
  Cut_Flesh = 56,
  Cut_Flesh_Head = 57,
  Cut_Robot = 58,
  Cut_Robot_Head = 59,
  Cut_Android = 60,
  Cut_Android_Head = 61,
  Cut_Mech = 62,
  Cut_Mech_Head = 63,
  Cut_Water = 64,
  Stab = 65,
  Stab_Hard = 66,
  Stab_Soft = 67,
  Stab_Solid = 68,
  Stab_Flesh = 69,
  Stab_Flesh_Head = 70,
  Stab_Robot = 71,
  Stab_Robot_Head = 72,
  Stab_Android = 73,
  Stab_Android_Head = 74,
  Stab_Mech = 75,
  Stab_Mech_Head = 76,
  Stab_Water = 77,
  Finisher = 78,
  Finisher_Hard = 79,
  Finisher_Soft = 80,
  Finisher_Solid = 81,
  Finisher_Flesh = 82,
  Finisher_Flesh_Head = 83,
  Finisher_Robot = 84,
  Finisher_Robot_Head = 85,
  Finisher_Android = 86,
  Finisher_Android_Head = 87,
  Finisher_Mech = 88,
  Finisher_Mech_Head = 89,
  Finisher_Water = 90,
  Weak = 91,
  Weak_Hard = 92,
  Weak_Soft = 93,
  Weak_Solid = 94,
  Weak_Flesh = 95,
  Weak_Flesh_Head = 96,
  Weak_Robot = 97,
  Weak_Robot_Head = 98,
  Weak_Android = 99,
  Weak_Android_Head = 100,
  Weak_Mech = 101,
  Weak_Mech_Head = 102,
  Weak_Water = 103,
  Throw = 104,
  Throw_Hard = 105,
  Throw_Soft = 106,
  Throw_Solid = 107,
  Throw_Flesh = 108,
  Throw_Flesh_Head = 109,
  Throw_Robot = 110,
  Throw_Robot_Head = 111,
  Throw_Android = 112,
  Throw_Android_Head = 113,
  Throw_Mech = 114,
  Throw_Mech_Head = 115,
  Throw_Water = 116,
}

public native class audioMeleeHitSoundMetadata extends audioAudioMetadata {
  native let meleeSoundsByMaterial: ref<audioMaterialMeleeSoundDictionary>;
}

enum audioMeleeHitType {
  Light = 0,
  Normal = 1,
  Heavy = 2,
  Slash = 3,
  Cut = 4,
  Stab = 5,
  Finisher = 6,
  Weak = 7,
  Throw = 8,
}

public native class audioMeleeHitTypeMeleeSoundDictionary extends audioInlinedAudioMetadata {
  native let entries: array<audioMeleeHitTypeMeleeSoundDictionaryItem>;
}

public native class audioMeleeHitTypeMeleeSoundDictionaryItem extends audioInlinedAudioMetadata {
  native let key: audioMeleeHitPerMaterialType;
  native let value: audioMeleeSound;
}

enum audioMeleeMaterialType {
  Hard = 0,
  Soft = 1,
  Solid = 2,
  Flesh = 3,
  Robot = 4,
  Android = 5,
  Mech = 6,
  Water = 7,
}

public native class audioMeleeRigMap extends audioAudioMetadata {
  native let mapItems: array<audioMeleeRigMapItem>;
}

public native class audioMeleeRigMapItem extends audioAudioMetadata {
  native let matchingRigs: array<CName>;
}

public native struct audioMeleeRigTypeMeleeWeaponConfigurationMap {
  native let mapItems: array<audioMeleeRigTypeMeleeWeaponConfigurationMapItem>;
}

public native struct audioMeleeRigTypeMeleeWeaponConfigurationMapItem {
  native let name: CName;
  native let meleeWeaponConfiguration: CName;
}

public native struct audioMeleeSound {
  native let events: array<audioMeleeEvent>;
}

public native class audioMeleeWeaponConfiguration extends audioAudioMetadata {
  native let fastWhoosh: audioMeleeSound;
  native let normalWhoosh: audioMeleeSound;
  native let slowWhoosh: audioMeleeSound;
  native let detailSound: audioMeleeSound;
  native let handlingSound: audioMeleeSound;
  native let equipSound: audioMeleeSound;
  native let unequipSound: audioMeleeSound;
  native let blockSound: audioMeleeSound;
  native let parrySound: audioMeleeSound;
  native let attackChargedThreshold: Float;
  native let attackChargedSound: audioMeleeSound;
  native let attackDischargedSound: audioMeleeSound;
  native let meleeSoundsByHitPerMaterialType: ref<audioMeleeHitTypeMeleeSoundDictionary>;
  native let meleeWeaponConfigurationsByRigTypeMap: audioMeleeRigTypeMeleeWeaponConfigurationMap;
}

public native class audioMeleeWeaponNpcSettings extends audioMeleeWeaponSettings {}

public native class audioMeleeWeaponPlayerSettings extends audioMeleeWeaponSettings {}

public abstract native class audioMeleeWeaponSettings extends audioAudioMetadata {
  native let quickAttackSettings: audioMeleeAttackSettings;
  native let strongAttackSettings: audioMeleeAttackSettings;
  native let weaponHandlingSettings: audioWeaponHandlingSettings;
}

public native class audioMeleeWeaponVariations extends audioAudioMetadata {
  native let playerWeaponConfigurationName: CName;
  native let NPCWeaponConfigurationName: CName;
}

public native struct audioMixingActionData {
  native let actionType: audioMixingActionType;
  native let voContext: locVoiceoverContext;
  native let tagValue: CName;
  native let dbOffset: Float;
  native let distanceRolloffFactor: Float;
  native let voEventOverride: CName;
  native let customParametersSetKey: Uint64;
  native let customParameters: array<audioAudSimpleParameter>;
}

enum audioMixingActionType {
  VoContext = 0,
  EmitterTag = 1,
  SoundTag = 2,
  ActorName = 3,
  DisableCombatVo = 4,
  GlobalParameter = 5,
}

public native struct audioMixParamDescription {
  native let parameter: CName;
  native let defaultValue: Float;
}

enum audioMixParamsAction {
  Mull = 0,
  MullPercent = 1,
  MullComplemtement = 2,
  MullComplemtementPercent = 3,
  Add = 4,
}

public native class audioMixSettings extends audioAudioMetadata {
  native let masterVolume: Float;
  native let sfxVolume: Float;
  native let musicVolume: Float;
  native let voVolume: Float;
  native let uiMenuVolume: Float;
  native let onStartupEvent: CName;
}

public native struct audioMusicController {
  native let playEvent: CName;
  native let stopEvent: CName;
  native let muteEvent: CName;
  native let unmuteEvent: CName;
}

enum audioMusicSyncType {
  Beat = 1,
  Bar = 0,
  Grid = 2,
  User = 3,
  EntryCue = 5,
  ExitCue = 6,
  Transition = 4,
}

public native class audioNpcGunChoirSettings extends audioAudioMetadata {
  native let voices: array<CName>;
}

public native class audioNpcGunChoirVoice extends audioAudioMetadata {
  native let fireSound: CName;
  native let burstFireSound: CName;
  native let chargedSound: CName;
  native let autoFireSound: CName;
  native let autoFireStop: CName;
  native let shutdown: CName;
  native let init: CName;
}

public native class audioNpcWeaponSettings extends audioWeaponSettings {
  native let gunChoir: CName;
  native let tails: CName;
  native let obstructionEnabled: Bool;
  native let occlusionEnabled: Bool;
  native let repositionEnabled: Bool;
  native let obstructionChangeTime: Float;
  native let disablePathfinding: Bool;
  native let voiceSwitchCooldown: Float;
  native let reloadSound: CName;
  native let quickMeleeAttackSound: CName;
  native let quickMeleeHitSound: CName;
}

enum audioNumberComparer {
  Equal = 0,
  NotEqual = 1,
  Greater = 2,
  GreaterOrEqual = 3,
  Lower = 4,
  LowerOrEqual = 5,
}

enum audioNumberOperation {
  SetEqual = 0,
  Add = 1,
  Subtract = 2,
  MultiplyBy = 3,
  DivideBy = 4,
}

enum audioObstructionTestPattern {
  Direct = 0,
  Cone = 1,
}

enum audioObstructionTestType {
  SingleShot = 0,
  Continuous = 1,
}

public native class audioPanicModeVirtualizeList extends audioAudioMetadata {
  native let tags: array<CName>;
}

public native class audioParamMixerDecoratorMetadata extends audioEmitterMetadata {
  native let inParams: array<audioMixParamDescription>;
  native let outputName: CName;
  native let operation: audioMixParamsAction;
  native let globalOutput: Bool;
}

public native struct audioPerfectChargePerkSounds {
  native let perfectChargeChargingSound: CName;
  native let perfectChargeChargedSound: CName;
  native let perfectChargeShootingSound: CName;
}

public native class audioPhysicalMaterialSettings extends audioAudioMetadata {
  native let softImpact: CName;
  native let solidImpact: CName;
  native let hardImpact: CName;
  native let useFoliageSystem: Bool;
  native let enableRollingOrScraping: Bool;
  native let scrape: CName;
  native let roll: CName;
  native let materialHardnessOverride: audioMaterialHardnessOverride;
  native let collideOnlyOnce: Bool;
  native let bulletImpact: CName;
  native let bulletImpactSniper: CName;
  native let bulletImpactShotgun: CName;
  native let bulletImpactRail: CName;
  native let bulletImpactNpc: CName;
  native let bulletImpactNpcSniper: CName;
  native let bulletImpactNpcAuto: CName;
  native let bulletImpactNpcShotgun: CName;
  native let bulletImpactNpcRail: CName;
}

public native class audioPhysicalMaterialToAudioMetadataMatrix extends audioAudioMetadata {
  native let physicalToAudioMaterialAssignments: array<audioAudioMaterialMetadataMapItem>;
}

public native class audioPhysicalObstructionSettings extends audioAudioMetadata {
  native let initialAbsorbtion: Float;
  native let absorptionPerMeter: Float;
}

public native class audioPhysicalPropSettings extends audioAudioMetadata {
  native let shockwaveSound: CName;
  native let damagedSound: CName;
  native let destroyedSound: CName;
  native let materialOverrides: array<CName>;
}

public native class audioPlayerInVehicleASTCD extends audioAudioStateTransitionConditionData {
  native let isInside: Bool;
}

public native class audioPlayerWeaponSettings extends audioWeaponSettings {
  native let fireSound: CName;
  native let preFireSound: CName;
  native let burstFireSound: CName;
  native let autoFireSound: CName;
  native let autoFireStop: CName;
  native let timeLimitForAutoFireSingleShot: Float;
  native let padVibrationGain: Float;
  native let padVibrationReloadGain: Float;
  native let tails: CName;
  native let shellCasingsSettings: CName;
  native let animEventOverrides: ref<audioWeaponEventOverrides>;
  native let quickMeleeHitEvent: CName;
  native let initEvent: CName;
  native let shutdownEvent: CName;
  native let aimEnterSound: CName;
  native let aimExitSound: CName;
  native let dryFireSound: CName;
  native let reloadSound: CName;
  native let triggerEffectSingle: CName;
  native let triggerEffectAiming: CName;
  native let triggerEffectAuto: CName;
  native let perfectChargePerkSounds: audioPerfectChargePerkSounds;
}

public native class audioPlaylistEmitterMetadata extends audioEmitterMetadata {
  native let receiverType: CName;
  native let playlistMetadataName: CName;
}

public native class audioPlaylistMetadata extends audioAudioMetadata {
  native let broadcastChannel: Uint8;
  native let tracks: array<CName>;
}

public native struct audioPlaylistTrackEventStruct {
  native let playlistName: CName;
  native let trackName: CName;
}

public native class audioPoliceDispatcherMetadata extends audioAudioMetadata {
  native let regularInputs: array<CName>;
  native let playerChaseStartInputs: array<CName>;
  native let playerChaseBackupNeededInputs: array<CName>;
  native let playerChaseEndInputs: array<CName>;
  native let dispatcherTimeInterval: Float;
  native let sceneFilePath: String;
}

public native struct audioQuadEmitterSettings {
  native let Enabled: Bool;
  native let Interleaved: Bool;
  native let Radius: Float;
  native let Offset: Vector3;
  native let Angle: Float;
  native let Events: [audioAudEventStruct; 4];
}

public native struct audioRadioBlip {
  native let blipEventName: CName;
}

enum audioRadioSoundType {
  Song = 0,
  AnnouncementScene = 1,
}

enum audioRadioSpeakerType {
  Stanley = 0,
  MaximumMike = 1,
  PoliceDispatch = 2,
  Kurtz = 3,
  Ash = 4,
  None = 5,
}

public native struct audioRadioStationJingleMetadata {
  native let introJingleEvent: CName;
  native let introDuration: Float;
  native let middleJingleEvent: CName;
  native let endJingleEvent: CName;
  native let outroDuration: Float;
}

public native class audioRadioStationMetadata extends audioAudioMetadata {
  native let tracks: array<CName>;
  native let blips: array<audioRadioBlip>;
  native let speaker: audioRadioSpeakerType;
}

public native class audioRadioStationMetadataMap extends audioAudioMetadata {
  native let radioStations: array<CName>;
  native let switchStationEvent: CName;
  native let turnOnRadioEvent: CName;
  native let turnOffRadioEvent: CName;
  native let defaultBackgroundJingle: audioRadioStationJingleMetadata;
}

public native struct audioRadioStationSongEventStruct {
  native let radioStationName: CName;
  native let radioSongName: CName;
}

public native struct audioRadioTrack {
  native let trackEventName: CName;
  native let localizationKey: CName;
  native let primaryLocKey: Uint64;
  native let isStreamingFriendly: Bool;
}

public native class audioRadioTracksMetadata extends audioAudioMetadata {
  native let radioTracks: array<audioRadioTrack>;
}

public native class audioRagdollCollisionMaterial extends audioAudioMetadata {
  native let lightCollisionEventName: CName;
  native let heavyCollisionEventName: CName;
  native let dismemberedLimbCollisionEventName: CName;
}

public native class audioReflectionEmitterSettings extends audioAudioMetadata {
  native let reflectionEvent: CName;
  native let fadeout: Float;
  native let reflectionDeltaThreshold: Float;
  native let maxConcurrentReflections: Uint32;
  native let broadcastChannel: Uint32;
  native let listenerRelativePosition: Bool;
  native let upReflectionEnabled: Bool;
  native let shortReflectionIndoors: Bool;
  native let reflectionVariant: audioReflectionVariant;
  native let backReflectionCutoffSpread: Float;
  native let backReflectionCutoffStrength: Float;
  native let backReflectionCutoffSoftness: Float;
  native let farReflectionDistance: Float;
  native let nearReflectionDistance: Float;
  native let minimumFaceAlignement: Float;
  native let fixedRaycastPitch: Float;
}

public native class audioReflectionMaterialSettings extends audioAudioMetadata {
  native let lowPass: Float;
  native let highPass: Float;
  native let gain: Float;
}

enum audioReflectionVariant {
  WorldSpaceFixedDrections = 0,
  LocalSpaceFixedDirections = 1,
  FindingMaximumFaceAlignemnt = 2,
  LocalSpaceSideDirections = 3,
  FindingMaximumFaceAligment2Sides = 4,
}

public native struct audioReverbCrossoverParams {
  native let dist: Float;
  native let fade: Float;
}

public native class audioRigMetadata extends audioAudioMetadata {
  native let positionBones: array<CName>;
  native let defaultBone: CName;
}

public native struct audioScanningSettings {
  native let scanningStartEvent: CName;
  native let scanningStopEvent: CName;
  native let scanningCompleteEvent: CName;
  native let scanningAvailableEvent: CName;
}

public abstract native class audioScriptableAudioInterface extends IScriptable {}

public native class audioSecurityTurretMetadata extends audioCustomEmitterMetadata {
  native let singleFire: CName;
  native let activated: CName;
  native let deactivaed: CName;
  native let destroyed: CName;
  native let idleStart: CName;
  native let idleStop: CName;
  native let triggerEffectSingle: CName;
  native let triggerEffectAuto: CName;
  native let obstructionEnabled: Bool;
  native let occlusionEnabled: Bool;
}

public native class audioShockwaveGlobalSettings extends audioAudioMetadata {
  native let explosionPropagationSpeed: Float;
  native let thumpPropagationSpeed: Float;
  native let electroshockPropagationSpeed: Float;
  native let revealPropagationSpeed: Float;
}

public native class audioShockwaveMetadata extends audioEmitterMetadata {
  native let explosionMetadataName: CName;
  native let thumpMetadataName: CName;
  native let electroshockMetadataName: CName;
  native let revealMetadataName: CName;
}

public native class audioShockwavePropertyMetadata extends audioAudioMetadata {
  native let eventName: CName;
  native let maxDistance: Float;
  native let probability: Float;
}

public native struct audioSoundBankStruct {
  native let soundBank: CName;
}

public native class audioSoundsLimiterMetadata extends audioAudioMetadata {
  native let tooManyPlayingGruntsAndVOsLimitation: array<audioLimitedSound>;
  native let gunsAreLoudAndMusicIsActiveLimitation: array<audioLimitedSound>;
  native let gunsAreLoudLimitation: array<audioLimitedSound>;
  native let tooManyPlayingSoundsLimitation: array<audioLimitedSound>;
}

public native class audioSourceBasedReverbBussesMetadata extends audioAudioMetadata {
  native let exterior: CName;
  native let interiorLarge: CName;
  native let interiorMedium: CName;
  native let interiorSmall: CName;
}

public native class audioSpatialSoundLimitMetadata extends audioAudioMetadata {
  native let eventNames: array<CName>;
  native let writeOnlyEventNames: array<CName>;
  native let readOnlyEventNames: array<CName>;
  native let radius: Float;
}

public native class audioTriggerEffectMetadata extends audioAudioMetadata {
  native let mode: audioTriggerEffectMode;
  native let target: audioTriggerEffectTarget;
  native let strength: Float;
  native let startPosition: Float;
  native let endPosition: Float;
  native let frequency: Float;
}

enum audioTriggerEffectMode {
  Off = 0,
  Feedback = 1,
  Weapon = 2,
  Vibration = 3,
}

enum audioTriggerEffectTarget {
  L2 = 0,
  R2 = 1,
  Both = 2,
}

enum audiottsvoicesFemale {
  Olivia = 7,
  Emily = 8,
  Jessica = 9,
  Sophie = 10,
  Elizabeth = 11,
  Carolina = 12,
  Sarah = 13,
}

enum audiottsvoicesMale {
  Andrew = 0,
  Oliver = 1,
  Jack = 2,
  Harry = 3,
  Simon = 4,
  Charlie = 5,
  Thomas = 6,
}

enum audiottsvoicesPolishFemale {
  Iwona = 16,
  Paulina = 17,
}

enum audiottsvoicesPolishMale {
  Mateusz = 14,
  Pawel = 15,
}

public native struct audioUiControl {
  native let uiEventsByAction: ref<audioKeyUiSoundDictionary>;
}

public native class audioUiControlEventsSettingsMapItem extends audioAudioMetadata {
  native let baseEvent: CName;
  native let customActionsDictionary: ref<audioKeySoundEventDictionary>;
}

public native class audioUiControlMap extends audioAudioMetadata {
  native let uiControlsByName: ref<audioKeyUiControlDictionary>;
}

public native class audioUiGenericControlSettingsMap extends audioAudioMetadata {
  native let uiControlMatrix: array<audioUiGenericControlSettingsMapItem>;
}

public native class audioUiGenericControlSettingsMapItem extends audioAudioMetadata {
  native let uiEventToAudioEventDictionary: ref<audioKeySoundEventDictionary>;
}

public native struct audioUiSound {
  native let events: array<CName>;
}

public native class audioUiSpecificControlSettingsMap extends audioAudioMetadata {
  native let specificControlSettingsMatrix: array<audioUiSpecificControlSettingsMapItem>;
}

public native class audioUiSpecificControlSettingsMapItem extends audioAudioMetadata {
  native let uiEventSettingsMatrix: array<audioUiControlEventsSettingsMapItem>;
}

public native class audioVehicleCollisionMap extends audioAudioMetadata {
  native let minImpactVelocityThreshold: Float;
  native let minRumbleVelocityThreshold: Float;
  native let rumbleCooldown: Float;
  native let scrapingMinTangentialVelocityThreshold: Float;
  native let scrapingMaxCollisionCooldown: Float;
  native let scrapingMinVehicleUpCollisionContactAngle: Float;
  native let useScrapingMinVehicleUpCollisionContactAngle: Bool;
  native let explosionEvent: CName;
  native let bigFireEvent: CName;
  native let engineFireEvent: CName;
  native let coolerDamageEvent: CName;
  native let interiorCollisionEvent: CName;
  native let collisionSettings: array<audioVehicleCollisionMapItem>;
}

public native struct audioVehicleCollisionMapItem {
  native let name: CName;
  native let impactEvent: CName;
  native let scrapingLoopStart: CName;
  native let scrapingLoopEnd: CName;
}

public native struct audioVehicleDestructionGridCell {
  native let impactEvent: CName;
  native let impactDetailEvent: CName;
}

public native struct audioVehicleDestructionGridLayer {
  native let backLeft: audioVehicleDestructionGridCell;
  native let backRight: audioVehicleDestructionGridCell;
  native let centerBackLeft: audioVehicleDestructionGridCell;
  native let centerBackRight: audioVehicleDestructionGridCell;
  native let centerForwardLeft: audioVehicleDestructionGridCell;
  native let centerForwardRight: audioVehicleDestructionGridCell;
  native let frontLeft: audioVehicleDestructionGridCell;
  native let frontRight: audioVehicleDestructionGridCell;
}

public native struct audioVehicleDoorsSettings {
  native let openEvent: CName;
  native let closeEvent: CName;
}

public native struct audioVehicleDoorsSettingsMetadata {
  native let door: audioVehicleDoorsSettings;
  native let trunk: audioVehicleDoorsSettings;
  native let hood: audioVehicleDoorsSettings;
}

public native struct audioVehicleEmitterPositionData {
  native let engineEmitterPosition: Vector3;
  native let exaustEmitterPosition: Vector3;
  native let centralEmitterPosition: Vector3;
  native let hoodEmitterPosition: Vector3;
  native let trunkEmitterPosition: Vector3;
  native let wheel1Position: Vector3;
  native let wheel2Position: Vector3;
  native let wheel3Position: Vector3;
  native let wheel4Position: Vector3;
}

public native struct audioVehicleEngageMovingFasterInterpolationData {
  native let enterCurveType: audioESoundCurveType;
  native let enterCurveTime: Float;
  native let exitCurveType: audioESoundCurveType;
  native let exitCurveTime: Float;
}

public native struct audioVehicleGeneralData {
  native let revSoundbankName: CName;
  native let revElectricSoundbankName: CName;
  native let reverbSoundbankName: CName;
  native let enterVehicleEvent: CName;
  native let exitVehicleEvent: CName;
  native let ignitionStartEvent: CName;
  native let ignitionEndEvent: CName;
  native let UIStartEvent: CName;
  native let UIEndEvent: CName;
  native let hornOnEvent: CName;
  native let hornOffEvent: CName;
  native let policeHornOnEvent: CName;
  native let policeHornOffEvent: CName;
  native let trafficPanicHornOnEvent: CName;
  native let trafficPanicHornOffEvent: CName;
  native let sirenOnEvent: CName;
  native let sirenOffEvent: CName;
  native let rainStartEvent: CName;
  native let rainStopEvent: CName;
  native let waterStartEvent: CName;
  native let waterStopEvent: CName;
  native let tyreBurstEvent: CName;
  native let skid: CName;
  native let inclination: CName;
  native let impactVelocity: CName;
  native let impactGridCellRawChange: CName;
  native let collisionSoundEvent: CName;
  native let brakeApplyEvent: CName;
  native let brakeReleaseEvent: CName;
  native let handbrakeApplyEvent: CName;
  native let handbrakeReleaseEvent: CName;
  native let brakeLoopStartEvent: CName;
  native let brakeLoopEndEvent: CName;
  native let lightsOnEvent: CName;
  native let lightsOffEvent: CName;
  native let interiorReverbBus: CName;
  native let acoustingIsolationFactor: CName;
  native let dopplerShift: CName;
  native let vehicleDoorsSettings: audioVehicleDoorsSettingsMetadata;
  native let vehicleInteriorParameterData: audioVehicleInteriorParameterData;
  native let vehicleTemperatureSettings: audioVehicleTemperatureSettings;
}

public native class audioVehicleGridDestruction extends audioAudioMetadata {
  native let minGridCellRawChangeThreshold: Float;
  native let specificGridCellImpactCooldown: Float;
  native let minGridCellValueToPlayDetailedEvent: Float;
  native let bottomLayer: audioVehicleDestructionGridLayer;
  native let upperLayer: audioVehicleDestructionGridLayer;
}

public native struct audioVehicleInteriorParameterData {
  native let enterCurveType: audioESoundCurveType;
  native let enterCurveTime: Float;
  native let enterDelayTime: Float;
  native let exitCurveType: audioESoundCurveType;
  native let exitCurveTime: Float;
  native let exitDelayTime: Float;
}

public native struct audioVehicleMechanicalData {
  native let engineStartEvent: CName;
  native let engineStopEvent: CName;
  native let gearUpBeginEvent: CName;
  native let gearUpEndEvent: CName;
  native let gearDownBeginEvent: CName;
  native let gearDownEndEvent: CName;
  native let throttleOnEvent: CName;
  native let throttleOffEvent: CName;
  native let suspensionSqueekEvent: CName;
  native let fullThrottleAppliedEvent: CName;
  native let acelleration: CName;
  native let speed: CName;
  native let gear: CName;
  native let brake: CName;
  native let rpm: CName;
  native let throttle: CName;
  native let sidewaysThrottle: CName;
  native let thrust: CName;
  native let temperature: CName;
}

public native class audioVehicleMetadata extends audioCustomEmitterMetadata {
  native let generalData: audioVehicleGeneralData;
  native let mechanicalData: audioVehicleMechanicalData;
  native let wheelData: audioVehicleWheelData;
  native let emitterPositionData: audioVehicleEmitterPositionData;
  native let minRpm: Float;
  native let maxRpm: Float;
  native let vehicleCollisionSettings: CName;
  native let vehicleGridDestructionSettings: CName;
  native let vehiclePartSettings: CName;
  native let collisionCooldown: Float;
  native let maxPlayingDistance: Float;
  native let dopplerFactor: Float;
  native let suspensionSqueekTimeout: Float;
  native let exitDelay: Float;
  native let gearSweeteners: array<CName>;
  native let testWheelMaterial: Bool;
  native let hasRadioReceiver: Bool;
  native let usesPoliceRadioStation: Bool;
  native let acousticIsolationFactor: Float;
  native let trafficEmitterMetadata: CName;
  native let radioReceiverType: CName;
  native let matchingStartupRadioStations: array<CName>;
  native let radioPlaysWhenEngineStartsProbability: Float;
}

public native struct audioVehicleMultipliers {
  native let throttleInputMultiplier: Float;
  native let rpmMultiplier: Float;
}

public native class audioVehicleNpcOcclusionMetadata extends audioEmitterMetadata {
  native let void: Bool;
}

public native class audioVehiclePartSettingsMap extends audioAudioMetadata {
  native let minAcousticsIsolationFactorValue: Float;
  native let partSettings: array<audioVehiclePartSettingsMapItem>;
}

public native struct audioVehiclePartSettingsMapItem {
  native let name: CName;
  native let onDetachEvent: CName;
  native let onDetachAcousticsIsolationFactorReduction: Float;
}

public native struct audioVehicleTemperatureSettings {
  native let rpmThreshold: Float;
  native let timeToActivateTemperature: Float;
  native let cooldownTime: Float;
}

public native struct audioVehicleWheelData {
  native let wheelStartEvents: array<CName>;
  native let wheelStopEvents: array<CName>;
  native let wheelRegularSuspensionImpacts: array<CName>;
  native let wheelLandingSuspensionImpacts: array<CName>;
  native let suspensionPressureMultiplier: Float;
  native let landingSuspensionPressureMultiplier: Float;
  native let suspensionPressureLimit: Float;
  native let minSuspensionPressureThreshold: Float;
  native let suspensionImpactCooldown: Float;
  native let minWheelTimeInAirBeforeLanding: Float;
}

public native class audioVehicleWheelMaterialsMap extends audioAudioMetadata {
  native let vehicleWheelMaterials: array<audioVehicleWheelMaterialsMapItem>;
}

public native struct audioVehicleWheelMaterialsMapItem {
  native let name: CName;
  native let audioMaterialCoeff: Float;
}

public native struct audioVisualTagAppearanceGroup {
  native let appearances: array<CName>;
  native let visualTags: array<CName>;
}

public native class audioVisualTagAppearanceMapping extends audioAudioMetadata {
  native let mappings: array<audioVisualTagAppearanceGroup>;
}

public native struct audioVisualTagToFoleyLoopMetadata {
  native let visualtags: array<CName>;
  native let loop: audioFoleyLoopMetadata;
}

public native struct audioVisualTagToNPCMetadata {
  native let visualTags: array<CName>;
  native let foleyNPCMetadata: CName;
}

enum audioVoBarkType {
  None = 0,
  Curse = 1,
  Morale = 2,
  Combat_Aggro = 3,
  Combat_Despair = 4,
  Stealth_Curious = 5,
}

enum audioVoCpoCharacter {
  None = 0,
  Solo = 1,
  Assassin = 2,
  Techie = 3,
  Netrunner = 4,
}

enum audioVoGruntInterruptMode {
  DontInterrupt = 0,
  PlayOnlyOnInterrupt = 1,
  CanInterrupt = 2,
}

enum audioVoGruntType {
  None = -1,
  PainShort = 23,
  PainLong = 0,
  AgroShort = 1,
  AgroLong = 2,
  Effort = 25,
  LongFall = 3,
  Death = 4,
  SilentDeath = 5,
  Grapple = 6,
  GrappleMovement = 7,
  EnvironmentalKnockdown = 8,
  Bump = 9,
  Curious = 10,
  Fear = 11,
  Jump = 12,
  EffortLong = 13,
  DeathShort = 14,
  Greet = 15,
  LaughHard = 16,
  LaughSoft = 17,
  Phone = 18,
  BraindanceExcited = 19,
  BraindanceFearful = 20,
  BraindanceNeutral = 21,
  BraindanceSexual = 22,
}

public native struct audioVoiceContextAnswer {
  native let answerContext: CName;
  native let radius: Float;
}

public native class audioVoiceContextMap extends audioAudioMetadata {
  native let includes: array<CName>;
  native let contexts: array<audioVoiceContextMapItem>;
}

public native class audioVoiceContextMapItem extends audioAudioMetadata {
  native let voTrigger: CName;
  native let bark: audioVoBarkType;
  native let grunt: audioVoGruntType;
  native let answer: audioVoiceContextAnswer;
  native let overridingVoContext: locVoiceoverContext;
  native let gruntInterruptMode: audioVoGruntInterruptMode;
}

public native struct audioVoiceGruntVariations {
  native let cachedVariations: array<CName>;
}

public native struct audioVoiceTagAppearanceGroup {
  native let appearances: array<CName>;
  native let voicetags: array<CName>;
}

public native class audioVoiceTagAppearanceMapping extends audioAudioMetadata {
  native let mappings: array<audioVoiceTagAppearanceGroup>;
}

public native class audioVoiceTagGroup extends audioAudioMetadata {
  native let voiceTags: array<CName>;
}

public native struct audioVoiceTriggerData {
  native let name: CName;
  native let variationIndex: Uint32;
  native let variationNumber: Uint32;
  native let overridingVoContext: locVoiceoverContext;
}

public native struct audioVoiceTriggerLimits {
  native let probability: Float;
  native let singleNpcMinRepeatTime: Float;
  native let allNpcsMinRepeatTime: Float;
  native let allNpcsSharingVoicesetMinRepeatTime: Float;
  native let combatVolume: Float;
}

public native class audioVoiceTriggerLimitsMap extends audioAudioMetadata {
  native let includes: array<CName>;
  native let triggers: array<audioVoiceTriggerLimitsMapItem>;
}

public native struct audioVoiceTriggerLimitsMapItem {
  native let name: CName;
  native let limits: audioVoiceTriggerLimits;
}

public native class audioVoiceTriggerPerSquadOrderMap extends audioAudioMetadata {
  native let items: array<audioVoiceTriggerPerSquadOrderMapItem>;
}

public native struct audioVoiceTriggerPerSquadOrderMapItem {
  native let name: CName;
  native let triggerName: CName;
}

public native class audioVoiceTriggerRewireMap extends audioAudioMetadata {
  native let includes: array<CName>;
  native let items: array<audioVoiceTriggerRewireMapItem>;
}

public native struct audioVoiceTriggerRewireMapItem {
  native let name: CName;
  native let inputToBeRewiredVariationIndex: Uint32;
  native let inputToBeActuallyPlayedName: CName;
  native let inputToBeActuallyPlayedVariationIndex: Uint32;
  native let allowReuse: Bool;
}

public native struct audioVoLineSignal {
  native let ruid: CRUID;
  native let signal: CName;
}

public native class audioWaitTimeASTCD extends audioAudioStateTransitionConditionData {
  native let timeToWait: Float;
}

public native class audioWeaponAmmoSettingsMap extends audioAudioMetadata {
  native let standardFlyby: audioFlybySettings;
  native let sniperFlyby: audioFlybySettings;
  native let shotFlyby: audioFlybySettings;
  native let railFlyby: audioFlybySettings;
  native let automaticFlyby: audioFlybySettings;
  native let smartFlyby: audioFlybySettings;
  native let smartSniperFlyby: audioFlybySettings;
  native let hmgFlyby: audioFlybySettings;
  native let flybyMinDistance: Float;
}

enum audioWeaponBulletType {
  standard = 0,
  sniper = 1,
  shot = 2,
  rail = 3,
  automatic = 4,
  smart = 5,
  smart_sniper = 6,
  hmg = 7,
}

public native class audioWeaponEventOverride extends audioInlinedAudioMetadata {
  native let key: CName;
  native let value: CName;
}

public native class audioWeaponEventOverrides extends audioInlinedAudioMetadata {
  native let entries: array<audioWeaponEventOverride>;
}

public native struct audioWeaponFireModeSounds {
  native let burst: CName;
  native let charge: CName;
  native let fullAuto: CName;
  native let semiAuto: CName;
  native let windup: CName;
}

public native struct audioWeaponHandlingSettings {
  native let equipEvent: CName;
  native let unequipStartedEvent: CName;
  native let unequippedEvent: CName;
}

public abstract native class audioWeaponSettings extends audioAudioMetadata {
  native let bulletType: audioWeaponBulletType;
  native let shellCasingType: audioWeaponShellCasingType;
  native let weaponHandlingSettings: audioWeaponHandlingSettings;
  native let singleShotInSandevistan: Bool;
  native let chargeStartSound: CName;
  native let chargeReadySound: CName;
  native let chargeOverchargeSound: CName;
  native let chargeDischargeSound: CName;
  native let fireModeSounds: audioWeaponFireModeSounds;
}

public native class audioWeaponSettingsGroup extends audioAudioMetadata {
  native let playerSettings: CName;
  native let playerSilenced: CName;
  native let npcSettings: CName;
  native let npcSilenced: CName;
}

enum audioWeaponShellCasingDirection {
  rightFront = 0,
  rightBack = 1,
  leftFront = 2,
  leftBack = 3,
}

enum audioWeaponShellCasingMode {
  none = 0,
  onShoot = 1,
  onReload = 2,
}

public native class audioWeaponShellCasingSettings extends audioAudioMetadata {
  native let mode: audioWeaponShellCasingMode;
  native let direction: audioWeaponShellCasingDirection;
  native let firstCollisionEventName: CName;
  native let secondCollisionEventName: CName;
  native let initialDelay: Float;
}

enum audioWeaponShellCasingType {
  standard = 0,
  large = 1,
  cartridge = 2,
}

enum audioWeaponTailEnvironment {
  InteriorDefault = 0,
  InteriorWide = 1,
  ExteriorWide = 2,
  ExteriorUrbanNarrow = 3,
  ExteriorUrbanStreet = 4,
  ExteriorUrbanStreetWide = 5,
  ExteriorUrbanOpen = 6,
  ExteriorUrbanEnclosed = 7,
  ExteriorBadlandsOpen = 8,
  ExteriorBadlandsCanyon = 9,
}

public native class audioWeaponTailSettings extends audioAudioMetadata {
  native let interiorDefault: CName;
  native let interiorWide: CName;
  native let interiorCar: CName;
  native let exteriorWide: CName;
  native let exteriorUrbanNarrow: CName;
  native let exteriorUrbanStreet: CName;
  native let exteriorUrbanStreetWide: CName;
  native let exteriorUrbanOpen: CName;
  native let exteriorUrbanEnclosed: CName;
  native let exteriorBadlandsOpen: CName;
  native let exteriorBadlandsCanyon: CName;
}

public native class audioWwiseIgnoredNames extends audioAudioMetadata {
  native let ignoredNames: array<CName>;
}

public importonly native class BakedDestructionComponent extends PhysicalMeshComponent {
  native let meshFractured: ResourceAsyncRef; // raRef<CMesh>
  native let meshFracturedAppearance: CName;
  native let numFrames: Float;
  native let frameRate: Float;
  native let playOnlyOnce: Bool;
  native let restartOnTrigger: Bool;
  native let disableCollidersOnTrigger: Bool;
  native let damageThreshold: Float;
  native let damageEndurance: Float;
  native let impulseToDamage: Float;
  native let contactToDamage: Float;
  native let accumulateDamage: Bool;
  native let destructionEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let audioMetadata: CName;
}

public native class Bink extends CResource {}

public native class BlackboardPrereq extends IComparisonPrereq {
  native let blackboardValue: gameBlackboardPropertyBindingDefinition;
  native let value: Variant;
}

public native class BlackboardPrereqState extends PrereqState {}

public importonly native struct BlackboardSerializableID {
  native let blackboardName: CName;
  native let fieldName: CName;
}

public native class BlackboardUpdateProxy extends IBlackboardUpdateProxy {}

public native class BloomAreaSettings extends IAreaSettings {
  native let blurSizeX: Float;
  native let blurSizeY: Float;
  native let mipColors: [Color; 5];
  native let mipLuminanceClamp: [Float; 3];
  native let luminanceThresholdMin: Float;
  native let luminanceThresholdMax: Float;
  native let sceneColorScale: Float;
  native let bloomColorScale: Float;
  native let numDownsamplePasses: Uint8;
  native let shaftsAreaSettings: ShaftsAreaSettings;
}

public native class BlurAreaSettings extends IAreaSettings {
  native let circularBlurRadius: Float;
}

public native class BraindanceDissolveComponent extends IComponent {
  native let dissolveRadius: Float;
}

public native class BumpAgent extends ISerializable {}

public native class BumpReactionSetting extends ISerializable {
  native let reaction: gameinteractionsBumpIntensity;
  native let maxVelocity: Float;
}

public native class C2dArray extends CResource {
  native let headers: array<String>;
  native let data: array<array<String>>;
}

public native class CameraAreaSettings extends IAreaSettings {
  native let cameraNearPlane: Float;
  native let cameraFarPlane: Float;
  native let automated: Bool;
  native let ISO: Uint32;
  native let shutterTime: Float;
  native let fStop: Float;
}

public native struct CameraCompensationAreaSettings {
  native let automated: Bool;
  native let ISO: Uint32;
  native let shutterTime: Float;
  native let fStop: Float;
}

public native class CarriedObjectAttached extends Event {}

public native class CarriedObjectDestroy extends Event {}

public native class CasinoChips extends GameObject {
  native let digitNames: array<CName>;
  native let flippedDigitNames: array<CName>;
}

public native struct CBaseEngine {}

public native class CBitmapTexture extends ITexture {
  native let width: Uint32;
  native let height: Uint32;
  native let depth: Uint32;
  native let setup: STextureGroupSetup;
  native let histBiasMulCoef: Vector3;
  native let histBiasAddCoef: Vector3;
  native let renderResourceBlob: ref<IRenderResourceBlob>;
  native let renderTextureResource: rendRenderTextureResource;
}

public native struct CCombatTargetData {}

public native struct CCombatTargetDataPtr {}

public native struct CComStaticSkeletonData {
  native let entries: array<CComStaticSkeletonDataEntry>;
}

public native struct CComStaticSkeletonDataEntry {
  native let boneIndex: Int32;
  native let mass: Float;
  native let locationLS: Vector4;
}

public native class CCubeTexture extends ITexture {
  native let setup: STextureGroupSetup;
  native let size: Uint32;
  native let renderResourceBlob: ref<IRenderResourceBlob>;
  native let renderTextureResource: rendRenderTextureResource;
}

public native class CDecalSpawner extends ISerializable {
  native let materialStatic: ResourceRef; // rRef<IMaterial>
  native let materialSkinned: ResourceRef; // rRef<IMaterial>
  native let specularColor: Color;
  native let specularScale: Float;
  native let specularBase: Float;
  native let roughnessScale: Float;
  native let normalThreshold: Float;
  native let additiveNormals: Bool;
  native let diffuseRandomColor0: Color;
  native let diffuseRandomColor1: Color;
  native let subUVType: ERenderDynamicDecalAtlas;
  native let specularity: Float;
  native let farZ: Float;
  native let nearZ: Float;
  native let size: ref<IEvaluatorFloat>;
  native let depthFadePower: Float;
  native let normalFadeBias: Float;
  native let normalFadeScale: Float;
  native let doubleSided: Bool;
  native let projectionMode: ERenderDynamicDecalProjection;
  native let decalLifetime: ref<IEvaluatorFloat>;
  native let decalFadeTime: Float;
  native let decalFadeInTime: Float;
  native let projectOnStatic: Bool;
  native let projectOnSkinned: Bool;
  native let startScale: Float;
  native let scaleTime: Float;
  native let useVerticalProjection: Bool;
  native let spawnPriority: EDynamicDecalSpawnPriority;
  native let autoHideDistance: Float;
}

public native class CDistantLightsResource extends resStreamedResource {}

public native struct CEnvDisplaySettingsParams {
  native let enableInstantAdaptation: Bool;
  native let enableGlobalLightingTrajectory: Bool;
  native let enableEnvProbeInstantUpdate: Bool;
  native let allowEnvProbeUpdate: Bool;
  native let allowBloom: Bool;
  native let allowColorMod: Bool;
  native let allowAntialiasing: Bool;
  native let allowGlobalFog: Bool;
  native let allowDOF: Bool;
  native let allowSSAO: Bool;
  native let allowCloudsShadow: Bool;
  native let allowWaterShader: Bool;
  native let gamma: Float;
}

public native class CEvaluatorColorConst extends IEvaluatorColor {
  native let value: Color;
}

public native class CEvaluatorColorCurve extends IEvaluatorColor {
  native let curves: CurveDataVector4;
  native let numberOfCurveSamples: Uint32;
}

public native class CEvaluatorColorMultiCurve extends IEvaluatorColor {
  native let numberOfCurveSamples: Uint32;
}

public native class CEvaluatorColorRandom extends IEvaluatorColor {
  native let min: Color;
  native let max: Color;
  native let randomPerChannel: Bool;
}

public native class CEvaluatorColorStartEnd extends IEvaluatorColor {
  native let start: Color;
  native let end: Color;
}

public native class CEvaluatorFloatConst extends IEvaluatorFloat {
  native let value: Float;
}

public native class CEvaluatorFloatCurve extends IEvaluatorFloat {
  native let curves: CurveDataFloat;
  native let numberOfCurveSamples: Uint32;
}

public native class CEvaluatorFloatRandomUniform extends IEvaluatorFloat {
  native let min: Float;
  native let max: Float;
}

public native class CEvaluatorFloatStartEnd extends IEvaluatorFloat {
  native let start: Float;
  native let end: Float;
}

public native class CEvaluatorVectorConst extends IEvaluatorVector {
  native let value: Vector4;
}

public native class CEvaluatorVectorCurve extends IEvaluatorVector {
  native let curves: CurveDataVector4;
  native let numberOfCurveSamples: Uint32;
}

public native class CEvaluatorVectorMultiCurve extends IEvaluatorVector {
  native let numberOfCurveSamples: Uint32;
}

public native class CEvaluatorVectorRandomUniform extends IEvaluatorVector {
  native let min: Vector4;
  native let max: Vector4;
  native let lockX: Bool;
  native let lockY: Bool;
  native let lockZ: Bool;
  native let lockW: Bool;
}

public native class CEvaluatorVectorStartEnd extends IEvaluatorVector {
  native let start: Vector4;
  native let end: Vector4;
}

public native class CFoliageProfile extends CResource {
  native let cutoffAlphaMinMip: Float;
  native let cutoffAlphaMaxMip: Float;
  native let billboardCutoffAlpha: Float;
  native let aoScale: Float;
  native let terrainBlendScale: Float;
  native let terrainBlendBias: Float;
  native let billboardDepthScale: Float;
  native let billboardRoughnessBias: Float;
  native let colorGradient: ResourceRef; // rRef<CGradient>
  native let colorGradientWeight: Float;
  native let colorGradientDarkenWeight: Float;
  native let preserveOriginalColor: Float;
}

public native class CGIDataResource extends resStreamedResource {
  native let sectorHash: Uint64;
}

public native class CGradient extends CResource {
  native let gradientEntries: array<rendGradientEntry>;
}

public native class CHairProfile extends CResource {
  native let sampleCount: Uint16;
  native let gradientEntriesID: array<rendGradientEntry>;
  native let gradientEntriesRootToTip: array<rendGradientEntry>;
}

public native class ChangeCameraControlHintVisibilityEvent extends Event {
}

public importonly native class ChangeRadioReceiverStation extends Event {}

public importonly native class ChangeRadioTierEvent extends Event {}

public native class CharacterBrighteningAreaSettings extends IAreaSettings {
  native let effectStrengthMultiplier: Float;
  native let minDistance: Float;
  native let maxDistance: Float;
  native let envMultiplier: CurveDataFloat;
}

public native class ChromaticAberrationAreaSettings extends IAreaSettings {
  native let chromaticAberrationEnabled: Bool;
  native let chromaticAberrationMargin: Float;
  native let chromaticAberrationSize: Vector2;
  native let chromaticAberrationExp: Float;
  native let subpixelDispersal: Float;
}

public native class CIESDataResource extends CResource {
  native let samples: [Uint16; 128];
}

public native class CloudAreaSettings extends IAreaSettings {
  native let cloudSunShadowFaloff: CurveDataFloat;
  native let cloudSunScattering: CurveDataFloat;
  native let cloudMoonScattering: CurveDataFloat;
  native let cloudLightColor: CurveDataHDRColor;
  native let cloudAmbientIntensity: CurveDataFloat;
  native let cloudCirrusOpacity: CurveDataFloat;
  native let cloudCirrusScale: CurveDataFloat;
  native let cloudCirrusAltitude: CurveDataFloat;
  native let cloudCirrusTexture: ResourceRef; // rRef<CBitmapTexture>
  native let volWeatherTexture: ResourceRef; // rRef<CBitmapTexture>
  native let volNoiseTexture: ResourceRef; // rRef<CBitmapTexture>
  native let volHorizonCoverage: Float;
  native let volCoverage: CurveDataFloat;
  native let volDensity: CurveDataFloat;
  native let cloudsBottom: Float;
  native let cloudsTop: Float;
  native let rayStartOffset: Float;
  native let rayStartFalloff: Float;
  native let lightIntensity: CurveDataFloat;
  native let reflectionProbeLightIntensity: CurveDataFloat;
  native let shadowIntensity: CurveDataFloat;
  native let worldShadowIntensity: CurveDataFloat;
  native let ambientIntensity: CurveDataFloat;
  native let ambientOutscatter: CurveDataFloat;
  native let inScatter: Float;
  native let outScatter: Float;
  native let inVsOutScatter: Float;
  native let silverLining: Float;
  native let volCoverageWindInfluence: Float;
  native let volNoiseWindInfluence: Float;
  native let volDetailWindInfluence: Float;
  native let volDistantFogOpacity: Float;
  native let volCoverageOffset: Vector2;
}

public native class CMaterialLayerLibrary extends CResource {
  native let uvTiling: Float;
  native let mbTiling: Float;
  native let microblendContrast: Float;
  native let paletteColorIndex: Uint32;
  native let layers: array<MaterialLayerDef>;
  native let microblends: array<MicroblendDef>;
}

public abstract native class CMaterialParameter extends ISerializable {
  native let parameterName: CName;
  native let register: Uint32;
}

public native class CMaterialParameterColor extends CMaterialParameter {
  native let color: Color;
}

public native class CMaterialParameterCpuNameU64 extends CMaterialParameter {
  native let name: CName;
}

public native class CMaterialParameterCube extends CMaterialParameter {
  native let texture: ResourceRef; // rRef<ITexture>
}

public native class CMaterialParameterDynamicTexture extends CMaterialParameter {
  native let texture: ResourceRef; // rRef<ITexture>
}

public native class CMaterialParameterFoliageParameters extends CMaterialParameter {
  native let foliageProfile: ResourceRef; // rRef<CFoliageProfile>
}

public native class CMaterialParameterGradient extends CMaterialParameter {
  native let gradient: ResourceRef; // rRef<CGradient>
}

public native class CMaterialParameterHairParameters extends CMaterialParameter {
  native let hairProfile: ResourceRef; // rRef<CHairProfile>
}

public native class CMaterialParameterMultilayerMask extends CMaterialParameter {
  native let mask: ResourceRef; // rRef<Multilayer_Mask>
}

public native class CMaterialParameterMultilayerSetup extends CMaterialParameter {
  native let setup: ResourceRef; // rRef<Multilayer_Setup>
}

public native class CMaterialParameterScalar extends CMaterialParameter {
  native let scalar: Float;
  native let min: Float;
  native let max: Float;
}

public native class CMaterialParameterSkinParameters extends CMaterialParameter {
  native let skinProfile: ResourceRef; // rRef<CSkinProfile>
}

public native class CMaterialParameterStructBuffer extends CMaterialParameter {}

public native class CMaterialParameterTerrainSetup extends CMaterialParameter {
  native let setup: ResourceRef; // rRef<CTerrainSetup>
}

public native class CMaterialParameterTexture extends CMaterialParameter {
  native let texture: ResourceRef; // rRef<ITexture>
}

public native class CMaterialParameterTextureArray extends CMaterialParameter {
  native let texture: ResourceRef; // rRef<ITexture>
}

public native class CMaterialParameterVector extends CMaterialParameter {
  native let vector: Vector4;
}

public native class CMaterialTemplate extends IMaterialDefinition {
  native let name: CName;
  native let parameters: [array<ref<CMaterialParameter>>; 3];
  native let techniques: array<MaterialTechnique>;
  native let samplerStates: [array<SamplerStateInfo>; 3];
  native let usedParameters: [array<MaterialUsedParameter>; 3];
  native let materialPriority: EMaterialPriority;
  native let materialType: ERenderMaterialType;
  native let audioTag: CName;
  native let resourceVersion: Uint8;
}

public native class CMesh extends resStreamedResource {
  native let parameters: array<ref<meshMeshParameter>>;
  native let boundingBox: Box;
  native let surfaceAreaPerAxis: Vector3;
  native let materialEntries: array<CMeshMaterialEntry>;
  native let externalMaterials: array<ResourceAsyncRef>;
  native let localMaterialInstances: array<ref<CMaterialInstance>>;
  native let localMaterialBuffer: meshMeshMaterialBuffer;
  native let preloadExternalMaterials: array<ResourceRef>;
  native let preloadLocalMaterialInstances: array<ref<IMaterial>>;
  native let inplaceResources: array<ResourceRef>;
  native let appearances: array<ref<meshMeshAppearance>>;
  native let objectType: ERenderObjectType;
  native let renderResourceBlob: ref<IRenderResourceBlob>;
  native let lodLevelInfo: array<Float>;
  native let floatTrackNames: array<CName>;
  native let boneNames: array<CName>;
  native let boneRigMatrices: array<Matrix>;
  native let boneVertexEpsilons: array<Float>;
  native let lodBoneMask: array<Uint8>;
  native let constrainAutoHideDistanceToTerrainHeightMap: Bool;
  native let forceLoadAllAppearances: Bool;
  native let castGlobalShadowsCachedInCook: Bool;
  native let castLocalShadowsCachedInCook: Bool;
  native let useRayTracingShadowLODBias: Bool;
  native let castsRayTracedShadowsFromOriginalGeometry: Bool;
  native let isShadowMesh: Bool;
  native let isPlayerShadowMesh: Bool;
}

public native struct ColorBalance {
  native let Red: Float;
  native let Green: Float;
  native let Blue: Float;
  native let Luminance: Float;
}

public native class ColorGradingAreaSettings extends IAreaSettings {
  native let contrast: Float;
  native let contrastPivot: Float;
  native let saturation: Float;
  native let hue: Float;
  native let brightness: Float;
  native let lift: ColorBalance;
  native let gammaValue: ColorBalance;
  native let gain: ColorBalance;
  native let offset: ColorBalance;
  native let lowRange: Float;
  native let shadowOffset: ColorBalance;
  native let midtoneOffset: ColorBalance;
  native let highRange: Float;
  native let highlightOffset: ColorBalance;
  native let ldrLut: ColorGradingLutParams;
  native let hdrLut: ColorGradingLutParams;
  native let forceHdrLut: Bool;
}

public native struct ColorGradingLutParams {
  native let LUT: ResourceRef; // rRef<CBitmapTexture>
  native let inputMapping: EColorMappingFunction;
  native let outputMapping: EColorMappingFunction;
}

public native class CombatSquad extends SquadBase {}

public importonly native class CommandsManager extends ICommandsManager {}

public native class communityArea extends ISerializable {
  native let entriesData: array<communityCommunityEntrySpotsData>;
}

public native struct communityCommunityEntryPhaseSpotsData {
  native let timePeriodsData: array<communityCommunityEntryPhaseTimePeriodData>;
  native let entryPhaseName: CName;
}

public native struct communityCommunityEntryPhaseTimePeriodData {
  native let periodName: CName;
  native let spotNodeIds: array<GlobalNodeID>;
  native let isSequence: Bool;
}

public native struct communityCommunityEntrySpotsData {
  native let phasesData: array<communityCommunityEntryPhaseSpotsData>;
  native let entryName: CName;
}

public native class communityCommunitySpawnSetTemplate extends communityCommunityTemplate {}

public native class communityCommunityTemplate extends CResource {
  native let communityTemplate: ref<communityCommunityTemplateData>;
}

public native class communityCommunityTemplateData extends ISerializable {
  native let entries: array<ref<communitySpawnEntry>>;
  native let crowdEntries: array<gameCrowdTemplateEntry>;
  native let spawnSetReference: CName;
}

enum communityECommunitySpawnTime {
  Morning = 0,
  Day = 1,
  Evening = 2,
  Night = 3,
  Midnight = 4,
  _1_00 = 5,
  _2_00 = 6,
  _3_00 = 7,
  _4_00 = 8,
  _5_00 = 9,
  _6_00 = 10,
  _7_00 = 11,
  _8_00 = 12,
  _9_00 = 13,
  _10_00 = 14,
  _11_00 = 15,
  _12_00___Noon = 16,
  _13_00 = 17,
  _14_00 = 18,
  _15_00 = 19,
  _16_00 = 20,
  _17_00 = 21,
  _18_00 = 22,
  _19_00 = 23,
  _20_00 = 24,
  _21_00 = 25,
  _22_00 = 26,
  _23_00 = 27,
}

enum communityESquadType {
  Global = 0,
  Community = 1,
  Security = 2,
  Unknown = 3,
}

public native class communityPatrolInitializer extends communitySpawnInitializer {
  native let patrolRole: ref<AIPatrolRole>;
}

public native class communityRole extends ISerializable {
  native let roleName: CName;
}

public native class communitySpawnEntry extends ISerializable {
  native let entryName: CName;
  native let characterRecordId: TweakDBID;
  native let phases: array<ref<communitySpawnPhase>>;
  native let spawnInView: gameSpawnInViewState;
  native let initializers: array<ref<communitySpawnInitializer>>;
}

public abstract native class communitySpawnInitializer extends ISerializable {}

public native class communitySpawnPhase extends ISerializable {
  native let phaseName: CName;
  native let appearances: array<CName>;
  native let timePeriods: array<communityPhaseTimePeriod>;
  native let alwaysSpawned: gameAlwaysSpawnedState;
  native let prefetchAppearance: Bool;
}

public native class communitySquadInitializer extends communitySpawnInitializer {
  native let entries: array<communitySquadInitializerEntry>;
}

public native struct communitySquadInitializerEntry {
  native let type: communityESquadType;
  native let value: CName;
}

public native struct communityTimePeriod {
  native let hour: communityECommunitySpawnTime;
}

public native class communityVoiceTagInitializer extends communitySpawnInitializer {
  native let voiceTagName: CName;
}

enum ConfigGraphicsQualityLevel {
  Low = 0,
  Medium = 1,
  High = 2,
  Ultra = 3,
  RaytracingLow = 5,
  RaytracingMedium = 6,
  RaytracingUltra = 7,
  RaytracingOverdrive = 8,
  Cinematic = 9,
  Cinematic_Raytracing = 10,
  CinematicEXR = 11,
  CinematicEXR_Raytracing = 12,
  PlayStation4 = 13,
  XboxOne = 14,
  PlayStation4Pro = 15,
  XboxOneX = 16,
  PlayStation5_Performance = 17,
  PlayStation5_Quality = 18,
  PlayStation5_Backcompat_Performance = 19,
  PlayStation5_Backcompat_Quality = 20,
  XboxSeriesS_Performance = 21,
  XboxSeriesS_Quality = 22,
  XboxSeriesS_Backcompat = 23,
  XboxSeriesX_Performance = 24,
  XboxSeriesX_Quality = 25,
  XboxSeriesX_Backcompat_Performance = 26,
  XboxSeriesX_Backcompat_Quality = 27,
  SteamDeck = 4,
  SafeMode = 30,
  GeForceNow = 28,
  IconsGeneration = 29,
  Auto = 31,
  GGP_Performance = 34,
  GGP_Quality = 35,
}

enum ConfigMeshQualityLevel {
  Default = 0,
  Console = 1,
  Console_XboxSeriesS = 2,
}

enum ConfigTextureQualityLevel {
  Console = 0,
  ConsoleSafe = 1,
  Low = 2,
  Medium = 3,
  High = 4,
  SafeMode = 5,
  Auto = 6,
}

public native struct ContactShadowsConfig {
  native let range: Float;
  native let rangeLimit: Float;
  native let screenEdgeFadeRange: Float;
  native let distanceFadeLimit: Float;
  native let distanceFadeRange: Float;
}

public native class ContactShadowsSettings extends IAreaSettings {
  native let contactShadows: ContactShadowsConfig;
}

public native class ContainerVisibilityChangedEvent extends Event {}

public native class ContextualLookAtAddEvent extends LookAtAddEvent {
  native let contextName: CName;
}

public native class ContextualLookAtRemoveEvent extends LookAtRemoveEvent {
  native let contextName: CName;
}

public native struct ConvexHull {
  native let planes: array<Vector4>;
}

public native class CookedMultilayer_Setup extends CResource {
  native let dependencies: array<ResourceRef>;
}

public native struct Coordinates {
  native let latitude: Int32;
  native let longitude: Int32;
}

public native class CorpseComponent extends ISkinableComponent {
  native let filterData: ref<physicsFilterData>;
  native let material: CName;
}

public native class CoverSelectionSystem extends AIICoverSelectionSystem {}

public native class cpAnimFeature_Stairs extends AnimFeature {
  native let onOff: Bool;
}

public native class CParticleDrawerBeam extends CParticleDrawerFacingBeam {
  native let rotation: Float;
}

public native class CParticleDrawerBillboard extends IParticleDrawer {
  native let isGPUBased: Bool;
}

public native class CParticleDrawerEmitterOrientation extends IParticleDrawer {
  native let coordinateSystem: EulerAngles;
  native let isGPUBased: Bool;
}

public native class CParticleDrawerFacingBeam extends IParticleDrawer {
  native let texturesPerUnit: Float;
  native let dynamicTexCoords: Bool;
  native let transparencyOffset: Float;
  native let transparencyLength: Float;
  native let numSegments: Uint32;
  native let sourceTangent: Vector4;
  native let targetTangent: Vector4;
  native let debugTargetTranslation: Vector3;
}

public native class CParticleDrawerFacingTrail extends CParticleDrawerTrail {}

public native class CParticleDrawerMesh extends IParticleDrawer {
  native let meshes: array<ResourceRef>;
  native let orientationMode: EMeshParticleOrientationMode;
}

public native class CParticleDrawerMotionBlur extends IParticleDrawer {
  native let stretchPerVelocity: Float;
  native let isGPUBased: Bool;
}

public native class CParticleDrawerScreen extends IParticleDrawer {
  native let isGPUBased: Bool;
}

public native class CParticleDrawerSphereAligned extends IParticleDrawer {
  native let verticalFixed: Bool;
  native let isGPUBased: Bool;
}

public native class CParticleDrawerTrail extends IParticleDrawer {
  native let texturesPerUnit: Float;
  native let dynamicTexCoords: Bool;
  native let minSegmentsPer360Degrees: Int32;
  native let ribbonize: Bool;
  native let ribbonTesselationDelta: Float;
}

public native class CParticleEmitter extends IParticleModule {
  native let modules: array<ref<IParticleModule>>;
  native let positionX: Int32;
  native let positionY: Int32;
  native let material: ResourceRef; // rRef<IMaterial>
  native let localMaterialInstance: ref<IMaterial>;
  native let maxParticles: Uint16;
  native let diffuseWrapFactor: Float;
  native let backLightingFactor: Float;
  native let lightingMipBias: Uint32;
  native let emitterLoops: Int8;
  native let particleDrawer: ref<IParticleDrawer>;
  native let decalSpawner: ref<CDecalSpawner>;
  native let maskInsideCar: Bool;
  native let maskInsideInterior: Bool;
  native let maskAboveWater: Bool;
  native let maskUnderWater: Bool;
  native let useSubFrameEmission: Bool;
  native let keepSimulationLocal: Bool;
  native let killOnCollision: Bool;
  native let initialParticleCount: Uint8;
  native let envColorGroup: EEnvColorGroup;
  native let emitterGroup: EEmitterGroup;
  native let renderObjectType: ERenderObjectType;
  native let windInfluence: Float;
  native let internalPriority: Uint8;
  native let lods: array<SParticleEmitterLODLevel>;
  native let renderResourceBlob: ref<IRenderResourceBlob>;
  native let Enabled: Bool;
  native let Relative: Bool;
  native let UseEnvironmentFogColor: Bool;
  native let Color: HDRColor;
  native let Size: Float;
  native let Density: Float;
  native let Falloff: Float;
  native let NoiseScale: Float;
  native let NoiseThreshold: Float;
  native let NoiseVelocity: Vector3;
}

public native class CParticleEventGenerator extends IParticleEvent {
  native let evtType: EParticleEventType;
  native let frequency: Float;
  native let probability: Float;
}

public native class CParticleEventReceiverSpawn extends IParticleEvent {
  native let spawnObject: EParticleEventSpawnObject;
}

public native class CParticleInitializerAlpha extends IParticleInitializer {
  native let alpha: ref<IEvaluatorFloat>;
}

public native class CParticleInitializerColor extends IParticleInitializer {
  native let color: ref<IEvaluatorColor>;
}

public native class CParticleInitializerLifeTime extends IParticleInitializer {
  native let lifeTime: ref<IEvaluatorFloat>;
}

public native class CParticleInitializerPosition extends IParticleInitializer {
  native let offset: Float;
  native let position: ref<IEvaluatorVector>;
  native let worldSpace: Bool;
}

public native class CParticleInitializerRotation extends IParticleInitializer {
  native let rotation: ref<IEvaluatorFloat>;
}

public native class CParticleInitializerRotation3D extends IParticleInitializer {
  native let rotation: ref<IEvaluatorVector>;
}

public native class CParticleInitializerRotationRate extends IParticleInitializer {
  native let rotationRate: ref<IEvaluatorFloat>;
}

public native class CParticleInitializerRotationRate3D extends IParticleInitializer {
  native let rotationRate: ref<IEvaluatorVector>;
}

public native class CParticleInitializerSize extends IParticleInitializer {
  native let size: ref<IEvaluatorVector>;
  native let scale: Float;
}

public native class CParticleInitializerSpawnBox extends IParticleInitializer {
  native let extents: ref<IEvaluatorVector>;
  native let worldSpace: Bool;
  native let surfaceOnly: Bool;
}

public native class CParticleInitializerSpawnCircle extends IParticleInitializer {
  native let innerRadius: ref<IEvaluatorFloat>;
  native let outerRadius: ref<IEvaluatorFloat>;
  native let surfaceOnly: Bool;
  native let worldSpace: Bool;
  native let spawnToLocal: Matrix;
}

public native class CParticleInitializerSpawnSphere extends IParticleInitializer {
  native let innerRadius: ref<IEvaluatorFloat>;
  native let outerRadius: ref<IEvaluatorFloat>;
  native let surfaceOnly: Bool;
  native let spawnPositiveX: Bool;
  native let spawnNegativeX: Bool;
  native let spawnPositiveY: Bool;
  native let spawnNegativeY: Bool;
  native let spawnPositiveZ: Bool;
  native let spawnNegativeZ: Bool;
  native let velocity: Bool;
  native let worldSpace: Bool;
  native let forceScale: ref<IEvaluatorFloat>;
}

public native class CParticleInitializerVelocity extends IParticleInitializer {
  native let velocity: ref<IEvaluatorVector>;
  native let scale: Float;
  native let worldSpace: Bool;
}

public native class CParticleInitializerVelocityInherit extends IParticleInitializer {
  native let scale: ref<IEvaluatorFloat>;
}

public native class CParticleInitializerVelocitySpread extends IParticleInitializer {
  native let scale: ref<IEvaluatorFloat>;
  native let conserveMomentum: Bool;
}

public native class CParticleModificatorAcceleration extends IParticleModificator {
  native let direction: ref<IEvaluatorVector>;
  native let scale: ref<IEvaluatorFloat>;
  native let worldSpace: Bool;
}

public native class CParticleModificatorAlphaByDistance extends IParticleModificator {
  native let nearBlendDistance: Vector2;
  native let farBlendDistance: Vector2;
}

public native class CParticleModificatorAlphaOverEffect extends IParticleModificator {}

public native class CParticleModificatorAlphaOverLife extends IParticleModificator {
  native let alpha: ref<IEvaluatorFloat>;
  native let modulate: Bool;
}

public native class CParticleModificatorCollision extends IParticleModificator {
  native let restitution: Float;
  native let dynamicFriction: Float;
  native let staticFriction: Float;
  native let velocityDamp: Float;
  native let angularVelocityDamp: Float;
  native let particleMass: Float;
  native let particleRadius: Float;
  native let useGPUAcceleration: Bool;
  native let disableGravity: Bool;
  native let killOnCollision: Bool;
}

public native class CParticleModificatorColorOverLife extends IParticleModificator {
  native let color: ref<IEvaluatorColor>;
  native let modulate: Bool;
}

public native class CParticleModificatorDepthCollision extends IParticleModificator {
  native let maxCollisions: Uint32;
  native let restitution: Float;
  native let friction: Float;
  native let radius: Float;
  native let collisionEffect: EDepthCollisionEffect;
}

public native class CParticleModificatorDrag extends IParticleModificator {
  native let dragCoefficient: ref<IEvaluatorFloat>;
  native let scale: Float;
}

public native class CParticleModificatorForce extends IParticleModificator {
  native let pivot: Vector3;
  native let radius: Float;
  native let scale: ref<IEvaluatorFloat>;
  native let damp: ref<IEvaluatorVector>;
}

public native class CParticleModificatorNoise extends IParticleModificator {
  native let amplitude: ref<IEvaluatorVector>;
  native let offset: ref<IEvaluatorVector>;
  native let frequency: ref<IEvaluatorVector>;
  native let changeRate: Vector3;
  native let applyToPosition: Bool;
  native let worldSpaceOffset: Bool;
  native let noiseType: ENoiseType;
}

public native class CParticleModificatorOrbit extends IParticleModificator {
  native let offset: ref<IEvaluatorVector>;
  native let frequency: ref<IEvaluatorVector>;
  native let phase: ref<IEvaluatorVector>;
  native let overridePosition: Bool;
}

public native class CParticleModificatorRotation3DOverLife extends IParticleModificator {
  native let rotation: ref<IEvaluatorVector>;
  native let modulate: Bool;
}

public native class CParticleModificatorRotationOverLife extends IParticleModificator {
  native let rotation: ref<IEvaluatorFloat>;
  native let modulate: Bool;
}

public native class CParticleModificatorRotationRate3DOverLife extends IParticleModificator {
  native let rotationRate: ref<IEvaluatorVector>;
}

public native class CParticleModificatorRotationRateOverLife extends IParticleModificator {
  native let rotationRate: ref<IEvaluatorFloat>;
  native let modulate: Bool;
}

public native class CParticleModificatorSizeByDistance extends IParticleModificator {
  native let nearDistanceRangeStart: ref<IEvaluatorFloat>;
  native let nearDistanceRangeEnd: ref<IEvaluatorFloat>;
  native let nearDistanceSizeMultiplier: ref<IEvaluatorFloat>;
  native let farDistanceRangeStart: ref<IEvaluatorFloat>;
  native let farDistanceRangeEnd: ref<IEvaluatorFloat>;
  native let farDistanceSizeMultiplier: ref<IEvaluatorFloat>;
}

public native class CParticleModificatorSizeOverLife extends IParticleModificator {
  native let size: ref<IEvaluatorVector>;
  native let scale: Float;
  native let modulate: Bool;
}

public native class CParticleModificatorTarget extends IParticleModificator {
  native let position: ref<IEvaluatorVector>;
  native let forceScale: ref<IEvaluatorFloat>;
  native let killRadius: ref<IEvaluatorFloat>;
  native let maxForce: Float;
}

public native class CParticleModificatorTargetNode extends IParticleModificator {
  native let forceScale: ref<IEvaluatorFloat>;
  native let killRadius: ref<IEvaluatorFloat>;
  native let maxForce: Float;
}

public native class CParticleModificatorTextureAnimation extends IParticleModificator {
  native let initialFrame: ref<IEvaluatorFloat>;
  native let animationSpeed: ref<IEvaluatorFloat>;
  native let animationMode: ETextureAnimationMode;
}

public native class CParticleModificatorVectorFieldAttractor extends IParticleModificator {
  native let inheritVelocity: Bool;
  native let attract: Bool;
  native let drag: Bool;
  native let restitution: ref<IEvaluatorFloat>;
}

public native class CParticleModificatorVelocityOverLife extends IParticleModificator {
  native let velocity: ref<IEvaluatorVector>;
  native let scale: Float;
  native let modulate: Bool;
  native let absolute: Bool;
}

public native class CParticleModificatorVelocityTurbulize extends IParticleModificator {
  native let scale: ref<IEvaluatorVector>;
  native let timelifeLimit: ref<IEvaluatorFloat>;
  native let noiseInterval: Float;
  native let duration: Float;
  native let worldSpace: Bool;
}

public native class CParticleSystem extends resStreamedResource {
  native let visibleThroughWalls: Bool;
  native let prewarmingTime: Float;
  native let emitters: array<ref<CParticleEmitter>>;
  native let boundingBox: Box;
  native let autoHideDistance: Float;
  native let autoHideRange: Float;
  native let lastLODFadeoutRange: Float;
  native let renderingPlane: ERenderingPlane;
  native let particleDamage: ref<ParticleDamage>;
}

public native class cpBumpEvent extends Event {
  native let amount: Uint32;
}

public native class cpConveyor extends GameObject {
  native let lines: array<cpConveyorLine>;
  native let movementCurve: CurveDataFloat;
  native let entityDistance: Float;
  native let entitySpawnOffset: Float;
  native let audioParameterLineActive: CName;
  native let audioParameterLineCycle: CName;
  native let audioParameterLineSpeed: CName;
}

public native class cpConveyorComponent extends IVisualComponent {}

public native struct cpConveyorLine {
  native let spline: NodeRef;
  native let template: CName;
  native let reverseDirection: Bool;
  native let physicsValidRanges: array<Vector2>;
}

public native class cpConveyorObject extends GameObject {
  native let rotationLerpFactor: Float;
  native let ignoreZAxis: Bool;
}

public native class cpConveyorSetupEvent extends Event {}

public native class cpExplosiveBarrel extends gameDestructibleObject {
  native let colliderComponentName: CName;
  native let destructionComponentName: CName;
}

public native class cpGameplayLightComponent extends LightComponent {
  native let reactToTime: Bool;
  native let begin: GameTime;
  native let end: GameTime;
  native let probability: Float;
  native let delayRange: GameTime;
}

public native class CPhysicsDecorationResource extends CMesh {}

public native class cpMeatBag extends GameObject {
  native let rotationLerpFactor: Float;
  native let kinematicBodyBoneName: CName;
  native let bagBodyBoneName: CName;
  native let physicalComponentName: CName;
  native let bagHitComponentName: CName;
  native let bagDestroyComponentName: CName;
  native let destructionEffectName: CName;
  native let jiggleEffectName: CName;
}

public native class cpPlayerDetector_PseudoDevice extends GameObject {
  native let playerDetector: NodeRef;
}

public native class cpPlayerDetector extends GameObject {
  native let range: Float;
}

public native class cpPlayerDetectorPS extends GameObjectPS {
  native persistent let secondsCounter: Int32;
}

public native class cpSplinePlacementProvider_Count extends cpSplinePlacementProvider_Distance {
  native let count: Uint32;
}

public native class cpSplinePlacementProvider_Distance extends cpSplinePlacementProvider {
  native let distance: Float;
}

public abstract native class cpSplinePlacementProvider extends ISerializable {}

public native class cpStairsTrigger extends GameObject {}

public native class cpTestComponent extends GameComponent {
  native let whatever: Float;
  native let whateverIE: Float;
}

public native class cpTestComponentPS extends GameComponentPS {
  native persistent let something: Int32;
  native persistent let somethingNotInstanceEdiable: Bool;
  native let nameEditable: CName;
  native let nameInstanceEditable: CName;
  native persistent let namePersistent: CName;
  native persistent let namePersistentEdiable: CName;
  native persistent let namePersistentInstanceEditable: CName;
}

public native class cpTestPhysXDynamicMovement extends GameObject {}

public native class cpTestPlatformController extends GameObject {
  native let platform: NodeRef;
  native let pointA: NodeRef;
  native let pointB: NodeRef;
  native let speed: Float;
}

public native class cpTimerTest extends GameObject {
  native let counter: Int32;
}

public native class CReflectionProbeDataResource extends resStreamedResource {
  native let textureData: rendRenderTextureResource;
  native let dataHash: Uint64;
  native let haveSkyData: Bool;
  native let faceDepth: [Float; 6];
}

public native class CRenderResourceBlobContainer extends ISerializable {
  native let blob: ref<IRenderResourceBlob>;
}

public native class CRenderSimWaterFFT extends IDynamicTextureGenerator {
  native let windDir: Float;
  native let windSpeed: Float;
  native let windScale: Float;
  native let amplitude: Float;
  native let lambda: Float;
}

public native class CRenderSimWaterImpulse extends IDynamicTextureGenerator {
  native let resolution: Int32;
  native let simulationSpeed: Float;
  public final static native func AddImpulse()
}

public native class CRenderTextureMaterial extends IDynamicTextureGenerator {}

public native class CSkinProfile extends CResource {
  native let blurSize: Float;
  native let diffuse: Color;
  native let falloff: Color;
  native let roughness0: Float;
  native let roughness1: Float;
  native let lobeMix: Float;
}

public native class CSourceTexture extends ISerializable {
  native let width: Uint32;
  native let height: Uint32;
  native let depth: Uint32;
  native let pitch: Uint32;
  native let format: ETextureRawFormat;
}

public native class CTerrainSetup extends CResource {
  native let tiling: array<Float>;
  native let physicalMaterial: array<CName>;
}

public native class CTextureArray extends ITexture {
  native let setup: STextureGroupSetup;
  native let renderResourceBlob: ref<IRenderResourceBlob>;
  native let renderTextureResource: rendRenderTextureResource;
}

public native struct CTextureArrayEntry {
  native let texture: ResourceRef; // rRef<CBitmapTexture>
}

public native class CTextureRegionSet extends CResource {
  native let regions: array<rendTextureRegion>;
}

public native class CurrentTargetPrereq extends IPrereq {}

public native class CurrentTargetPrereqState extends PrereqState {}

enum curveEInterpolationType {
  EIT_Constant = 0,
  EIT_Linear = 1,
  EIT_BezierQuadratic = 2,
  EIT_BezierCubic = 3,
  EIT_Hermite = 4,
}

enum curveESegmentsLinkType {
  ESLT_Normal = 0,
  ESLT_Smooth = 1,
  ESLT_SmoothSymmetric = 2,
}

public native class CurveResourceSet extends CResource {
  native let curveResources: array<CurveResourceSetEntry>;
}

public native struct CurveResourceSetEntry {
  native let name: CName;
  native let curveResRef: ResourceRef; // rRef<CurveSet>
}

public native class CurveSet extends CResource {
  native let curves: array<CurveSetEntry>;
}

public native struct CurveSetEntry {
  native let name: CName;
  native let curve: CurveDataFloat;
}

public native struct curveSingleChannelCurve {
  native let interpolationType: curveEInterpolationType;
  native let linkType: curveESegmentsLinkType;
}

public native class CustomLightAreaSettings extends IAreaSettings {
  native let characterLocalLightRoughnesBias: CurveDataFloat;
}

public native class CustomMoveEvent extends ActionEvent {
  native let test: Int32;
}

public native class CustomPositionMappin extends RuntimeMappin {}

public abstract native struct CustomRequestFilter {}

public native struct CutCone {
  native let positionAndRadius1: Vector4;
  native let normalAndRadius2: Vector4;
  native let height: Float;
}

public native struct CVariableStoragePtr {}

public native class CVisualDebug extends IScriptable {
  public final native func AddArrow()
  public final native func AddAxis()
  public final native func AddBar()
  public final native func AddBarColorAreas()
  public final native func AddBarColorSmooth()
  public final native func AddBox()
  public final native func AddLine()
  public final native func AddSphere()
  public final native func AddText()
  public final native func RemoveArrow()
  public final native func RemoveAxis()
  public final native func RemoveBar()
  public final native func RemoveBox()
  public final native func RemoveLine()
  public final native func RemoveSphere()
  public final native func RemoveText()
}

public native struct Cylinder {
  native let positionAndRadius: Vector4;
  native let normalAndHeight: Vector4;
}

public native class DamagePack extends IScriptable {
  native let damageList: array<ref<Damage>>;
  public final native func AddDamage()
  public final native func GetDamageList()
  public final native func HasValidDamage()
}

public native class dbgSpawner extends GameObject {
  native let objectRecordId: TweakDBID;
  native let appearance: CName;
  native let isActive: Bool;
  native let alwaysSpawned: gameAlwaysSpawnedState;
}

public native class debugRuntimeSystemSpeedSplinePreview extends worldIRuntimeSystem {}

public abstract native class DestructionPersistencySystem extends IGameSystem {}

public native class DetachEntity extends Event {
  native let entity: wref<Entity>;
}

public importonly native class DeviceCameraControlComponent extends GameComponent {}

public native class DeviceInteractionManager extends IDeviceInteractionManager {}

public native class DialogLineEvent extends Event {
  native let data: audioDialogLineEventData;
}

public native class DismemberedBodyPartEvent extends Event {}

public native class DistantFogAreaSettings extends IAreaSettings {
  native let range: CurveDataFloat;
  native let albedoNear: CurveDataHDRColor;
  native let albedoFar: CurveDataHDRColor;
  native let nearDistance: CurveDataFloat;
  native let farDistance: CurveDataFloat;
  native let density: CurveDataFloat;
  native let height: CurveDataFloat;
  native let heightFallof: CurveDataFloat;
  native let densitySecond: CurveDataFloat;
  native let heightSecond: CurveDataFloat;
  native let heightFallofSecond: CurveDataFloat;
  native let simpleColor: CurveDataHDRColor;
  native let simpleDensity: CurveDataFloat;
  native let envProbeColor: CurveDataHDRColor;
  native let envProbeDensity: CurveDataFloat;
  native let skyAltitudeBegin: CurveDataFloat;
  native let skyAltitudeEnd: CurveDataFloat;
  native let skyOpacity: CurveDataFloat;
}

public native class DistantIrradianceeSettings extends IAreaSettings {
  native let distantRange: CurveDataVector2;
  native let distantHeightRange: CurveDataVector3;
  native let distantLights: CurveDataFloat;
  native let distantLightsRange: CurveDataVector2;
  native let blendDistance: CurveDataFloat;
}

public native class DistantLightsAreaSettings extends IAreaSettings {
  native let distantLightStartDistance: Float;
  native let distantLightFadeDistance: Float;
}

public native class DistantProxiesSettings extends IAreaSettings {
  native let distantProxiesEmissive: Float;
  native let distantProxiesEmissiveHeight: Float;
  native let distantProxiesEmissivePower: Float;
  native let distantProxiesBboxzBlend: Float;
}

public importonly native class DoneActionEvent extends Event {}

public native class DrawClimbDebug extends Event {}

public native class DrawVaultDebug extends DrawClimbDebug {}

public native class DriverCombatMappinController extends BaseInteractionMappinController {}

public native class DynamicTexture extends ITexture {
  native let width: Uint32;
  native let height: Uint32;
  native let scaleToViewport: Bool;
  native let mipChain: Bool;
  native let samplesCount: Uint8;
  native let dataFormat: DynamicTextureDataFormat;
  native let generator: ref<IDynamicTextureGenerator>;
}

enum DynamicTextureDataFormat {
  R_Uint8 = 0,
  R_Float16 = 1,
  R_Float32 = 2,
  RG_Float16 = 3,
  RG_Float32 = 4,
  RGBA_Uint8 = 5,
  RGBA_Uint8_SRGB = 6,
  RGBA_Float16 = 7,
  RGBA_Float32 = 8,
}

enum EAnimationBufferDataAvailable {
  ABDA_None = 0,
  ABDA_Partial = 1,
  ABDA_All = 2,
}

enum EAreaLightShape {
  ALS_Sphere = 0,
  ALS_Capsule = 1,
}

public native struct EasingFunction {
  native let transitionType: ETransitionType;
  native let easingType: EEasingType;
}

enum EColorChannel {
  COLCHANNEL_Red = 0,
  COLCHANNEL_Green = 1,
  COLCHANNEL_Blue = 2,
  COLCHANNEL_Alpha = 3,
}

enum EColorMappingFunction {
  CMF_Linear = 0,
  CMF_sRGB = 1,
  CMF_ArriLogC = 2,
}

enum EColorPrimary {
  PRIM_REC709 = 0,
  PRIM_DCIP3 = 1,
  PRIM_BT2020 = 2,
}

enum ECookingPlatform {
  PLATFORM_None = 0,
  PLATFORM_PC = 1,
  PLATFORM_XboxOne = 2,
  PLATFORM_PS4 = 3,
  PLATFORM_PS5 = 4,
  PLATFORM_XSX = 5,
  PLATFORM_WindowsServer = 6,
  PLATFORM_LinuxServer = 7,
  PLATFORM_GGP = 8,
}

enum ECubeSourceTextureType {
  CST_CrossHorizontal = 0,
  CST_CrossVertical = 1,
  CST_Panorama = 2,
}

enum ECustomCameraTarget {
  ECCTV_All = 0,
  ECCTV_OnlyOffscreen = 1,
  ECCTV_OnlyOnscreen = 2,
}

enum ECustomMaterialParam {
  ECMP_CustomParam0 = 1,
  ECMP_CustomParam1 = 2,
  ECMP_CustomParam2 = 4,
  ECMP_CustomParam3 = 8,
  ECMP_CustomParam4 = 16,
  ECMP_CustomParam5 = 32,
  ECMP_CustomParam6 = 64,
}

enum EDecalRenderMode {
  DRM_AllStatic = 0,
  DRM_ObjectType = 1,
  DRM_AllDynamic = 2,
  DRM_All = 3,
}

enum EDepthCollisionEffect {
  DCE_Bounce = 1,
  DCE_Glide = 2,
  DCE_Kill = 4,
}

public native class EditorMeshComponent extends MeshComponent {}

enum EDynamicDecalSpawnPriority {
  RDDS_Normal = 0,
  RDDS_Highest = 1,
}

enum EEasingType {
  EET_In = 0,
  EET_Out = 1,
  EET_InOut = 2,
}

enum EEmitterGroup {
  EG_Default = 0,
  EG_Group0 = 1,
  EG_Group1 = 2,
  EG_Group2 = 3,
  EG_Group3 = 4,
  EG_Group4 = 5,
  EG_Group5 = 6,
  EG_Group6 = 7,
  EG_Group7 = 8,
  EG_Group8 = 9,
  EG_Group9 = 10,
  EG_Group10 = 11,
  EG_Group11 = 12,
  EG_Group12 = 13,
  EG_Group13 = 14,
  EG_Group14 = 15,
  EG_Group15 = 16,
}

enum EEntityHighlightType {
  EHE_None = 0,
  EHE_FillAndOutline = 1,
  EHE_FillOnly = 2,
  EHE_OutlineOnly = 3,
}

enum EEnvColorGroup {
  ECG_Default = 0,
  ECG_Sky = 1,
  ECG_Group0 = 2,
  ECG_Group1 = 3,
  ECG_Group2 = 4,
  ECG_Group3 = 5,
  ECG_Group4 = 6,
  ECG_Group5 = 7,
  ECG_Group6 = 8,
  ECG_Group7 = 9,
  ECG_Group8 = 10,
  ECG_Group9 = 11,
  ECG_Group10 = 12,
  ECG_Group11 = 13,
  ECG_Group12 = 14,
  ECG_Group13 = 15,
  ECG_Group14 = 16,
  ECG_Group15 = 17,
}

enum EEnvManagerModifier {
  EMM_None = 0,
  EMM_WireframeSolid = 1,
  EMM_WireframeSeethrough = 2,
  EMM_Overdraw = 3,
  EMM_OverdrawSeethrough = 4,
  EMM_ParticleOverdraw = 5,
  EMM_ParticleNumLights = 6,
  EMM_DecalOverdraw = 7,
  EMM_LightOverdraw = 8,
  EMM_SceneReferredColor = 9,
  EMM_DisplayReferredColor = 10,
  EMM_GlobalIllumination = 11,
  EMM_SurfaceMaterialID = 12,
  EMM_SurfaceObjectID = 13,
  EMM_SurfaceBaseColor = 14,
  EMM_SurfaceAlbedo = 15,
  EMM_SurfaceSpecularity = 16,
  EMM_SurfaceMetalness = 17,
  EMM_SurfaceRoughness = 18,
  EMM_SurfaceEmissive = 19,
  EMM_SurfaceTranslucency = 20,
  EMM_SurfaceNormalsWorldSpace = 21,
  EMM_SurfaceNormalsViewSpace = 22,
  EMM_SurfaceHairDirection = 23,
  EMM_SurfaceHairID = 24,
  EMM_SurfaceLightBlockerIntensity = 25,
  EMM_GBuffer0A = 26,
  EMM_GBuffer1RGB = 27,
  EMM_GBuffer1A = 28,
  EMM_ConeAODir = 29,
  EMM_ConeAOAngle = 30,
  EMM_VelocityBuffer = 31,
  EMM_Depth = 32,
  EMM_UvDensity = 33,
  EMM_ToneMappingLuminance = 34,
  EMM_ToneMappingThresholds = 35,
  EMM_LuminanceSpotMeter = 36,
  EMM_IlluminanceMeter = 37,
  EMM_DiffuseLight = 38,
  EMM_SpecularLight = 39,
  EMM_ClayView = 40,
  EMM_PureGreyscaleView = 41,
  EMM_PureWhiteView = 42,
  EMM_PureReflectionView = 43,
  EMM_PureGreyReflectionView = 44,
  EMM_Cascades = 45,
  EMM_MaskShadow = 46,
  EMM_MaskSSAO = 47,
  EMM_MaskTXAA = 48,
  EMM_MaskDistortion = 49,
  EMM_MaskInvalidation = 50,
  EMM_MaskReactivityFSR2 = 51,
  EMM_SurfaceCacheID = 52,
  EMM_SurfaceCacheResolution = 53,
  EMM_LightChannels = 54,
  EMM_DebugHitProxies = 55,
  EMM_DebugShadowsMode = 56,
  EMM_RayTracingDebug = 57,
  EMM_SSRResults = 58,
  EMM_SSRFade = 59,
  EMM_DepthOfFieldCoC = 60,
  EMM_MultilayeredMode = 61,
  EMM_MultilayeredProxy = 62,
  EMM_MultilayeredUniqueMasks = 63,
  EMM_MultilayeredMaskWeight = 64,
  EMM_LocalShadowsVariance = 65,
  EMM_LocalShadowsRangesOverlapDynamicsOnly = 66,
  EMM_LocalShadowsRangesOverlapStaticsOnly = 67,
  EMM_LODColoring = 68,
  EMM_TodvisRuntimePreview = 69,
  EMM_TodvisBakePreview = 70,
  EMM_RainMask = 71,
  EMM_VolFogDensity = 72,
  EMM_PBRValidationBaseColor = 73,
  EMM_PBRValidationMetalness = 74,
  EMM_GreyPlayMode = 75,
  EMM_RTXDIDiffuseRaw = 76,
  EMM_RTXDISpecularRaw = 77,
  EMM_RTXDIDiffuseDenoised = 78,
  EMM_RTXDISpecularDenoised = 79,
  EMM_RTXDIBRDFFactor = 80,
  EMM_IndirectDiffuseRaw = 81,
  EMM_IndirectSpecularRaw = 82,
  EMM_IndirectDiffuseDenoised = 83,
  EMM_IndirectSpecularDenoised = 84,
}

enum EFeatureFlag {
  FEATFLAG_Default = 0,
  FEATFLAG_Shadows = 1,
  FEATFLAG_HitProxies = 2,
  FEATFLAG_Selection = 3,
  FEATFLAG_Wireframe = 4,
  FEATFLAG_Overdraw = 10,
  FEATFLAG_VelocityBuffer = 5,
  FEATFLAG_DebugDraw_BlendOff = 6,
  FEATFLAG_DebugDraw_BlendOn = 7,
  FEATFLAG_DynamicDecals = 8,
  FEATFLAG_Highlights = 9,
  FEATFLAG_IndirectInstancedGrass = 11,
  FEATFLAG_DecalsOnStaticObjects = 12,
  FEATFLAG_DecalsOnDynamicObjects = 13,
  FEATFLAG_MaskParticlesInsideCar = 14,
  FEATFLAG_MaskParticlesInsideInterior = 15,
  FEATFLAG_MaskTXAA = 16,
  FEATFLAG_DistantShadows = 17,
  FEATFLAG_FloatTracks = 18,
  FEATFLAG_Rain = 19,
  FEATFLAG_NumLights = 20,
  FEATFLAG_DepthPrepass = 21,
  FEATFLAG_DecalsOnAllObjects = 22,
}

public abstract native class effectBaseItem extends ISerializable {}

public native class effectBloomPlayData extends effectPlacedTrackItemPlayData {}

public native class effectBoneEntries extends effectIPlacementEntries {
  native let inheritRotation: Bool;
  native let bones: array<effectBoneEntry>;
}

public native struct effectBoneEntry {
  native let boneName: CName;
  native let relativePosition: Vector3;
  native let relativeRotation: Quaternion;
}

public native class effectCameraComponentSpawner extends effectSpawner {}

public abstract native class effectCameraComponentTrackItemPlayData extends effectTrackItemPlayData {}

public native class effectChromaticAberrationPlayData extends effectPlacedTrackItemPlayData {}

public native class effectColorGradePlayData extends effectGenericTrackItemPlayData {}

public native class effectColorGradeV2PlayData extends effectPlacedTrackItemPlayData {}

public native class effectDataMoshPlayData extends effectPlacedTrackItemPlayData {}

public native class effectDecalPlayData extends effectPlacedTrackItemPlayData {}

public native class effectDynamicDecalPlayData extends effectPlacedTrackItemPlayData {}

public native struct effectEffectParameterEvaluator {
  native let evaluator: ref<IEvaluator>;
  native let inputParameterOverride: CName;
}

public native struct effectEffectParameterEvaluatorColor {
  native let evaluator: ref<IEvaluatorColor>;
  native let inputParameterOverride: CName;
}

public native struct effectEffectParameterEvaluatorFloat {
  native let evaluator: ref<IEvaluatorFloat>;
  native let inputParameterOverride: CName;
  native let inputParameterIsPostMultiplier: Bool;
}

public native struct effectEffectParameterEvaluatorVector {
  native let evaluator: ref<IEvaluatorVector>;
  native let inputParameterOverride: CName;
}

public native class effectEmissivePlayData extends effectPlacedTrackItemPlayData {}

public native class effectExposureScalePlayData extends effectPlacedTrackItemPlayData {}

public native class effectFilmGrainPlayData extends effectPlacedTrackItemPlayData {}

public native class effectFogVolumePlayData extends effectPlacedTrackItemPlayData {}

public native class effectForwardDecalPlayData extends effectPlacedTrackItemPlayData {}

public native class effectFOVPlayData extends effectPlacedTrackItemPlayData {}

public abstract native class effectGenericTrackItemPlayData extends effectTrackItemPlayData {}

public native class effectHudParameterPlayData extends effectVisualComponentTrackItemPlayData {}

public abstract native class effectIPlacementEntries extends ISerializable {}

public native class effectLightParameterPlayData extends effectVisualComponentTrackItemPlayData {}

public native struct effectLoopData {
  native let startTime: Float;
  native let endTime: Float;
}

public native class effectMaterialParameterPlayData extends effectVisualComponentTrackItemPlayData {}

public native class effectMotionBlurScalePlayData extends effectCameraComponentTrackItemPlayData {}

public importonly native class EffectorObject extends ISerializable {}

public native class effectParticlesPlayData extends effectPlacedTrackItemPlayData {}

public native class effectPlacedSpawner extends effectSpawner {
  native let placement: ref<effectIPlacementEntries>;
}

public abstract native class effectPlacedTrackItemPlayData extends effectTrackItemPlayData {}

public native class effectPointLightPlayData extends effectPlacedTrackItemPlayData {}

public native class effectRootEntries extends effectIPlacementEntries {
  native let inheritRotation: Bool;
  native let roots: array<effectRootEntry>;
}

public native struct effectRootEntry {
  native let relativePosition: Vector3;
  native let relativeRotation: Quaternion;
}

public native class effectSlotEntries extends effectIPlacementEntries {
  native let inheritRotation: Bool;
  native let slots: array<effectSlotEntry>;
}

public native struct effectSlotEntry {
  native let slotName: CName;
  native let relativePosition: Vector3;
  native let relativeRotation: Quaternion;
}

public native class effectSoundPlayData extends effectPlacedTrackItemPlayData {}

public native class effectSpawner extends ISerializable {}

public native class effectTonemappingPlayData extends effectPlacedTrackItemPlayData {}

public native class effectTrack extends effectTrackBase {
  native let items: array<ref<effectTrackItem>>;
}

public native class effectTrackBase extends effectBaseItem {}

public native class effectTrackGroup extends effectTrackBase {
  native let tracks: array<ref<effectTrackBase>>;
  native let componentName: CName;
}

public abstract native class effectTrackItem extends effectBaseItem {
  native let timeBegin: Float;
  native let timeDuration: Float;
  native let ruid: CRUID;
}

public native class effectTrackItemBloom extends effectTrackItem {
  native let override: Bool;
  native let sceneColorScale: effectEffectParameterEvaluatorFloat;
  native let bloomColorScale: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemChromaticAberration extends effectTrackItem {
  native let override: Bool;
  native let chromaticAberrationOffset: effectEffectParameterEvaluatorFloat;
  native let chromaticAberrationExp: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemColorGrade extends effectTrackItem {
  native let contrast: effectEffectParameterEvaluatorFloat;
  native let saturate: effectEffectParameterEvaluatorFloat;
  native let brightness: effectEffectParameterEvaluatorFloat;
  native let lutWeight: effectEffectParameterEvaluatorFloat;
  native let lutParams: ColorGradingLutParams;
  native let lutParamsHdr: ColorGradingLutParams;
  native let blendWithBaseLut: Bool;
  native let mask: array<ERenderObjectType>;
}

public native class effectTrackItemColorGradeV2 extends effectTrackItem {
  native let contrast: effectEffectParameterEvaluatorFloat;
  native let contrastPivot: effectEffectParameterEvaluatorFloat;
  native let saturation: effectEffectParameterEvaluatorFloat;
  native let hue: effectEffectParameterEvaluatorFloat;
  native let brightness: effectEffectParameterEvaluatorFloat;
  native let lowRange: effectEffectParameterEvaluatorFloat;
  native let highRange: effectEffectParameterEvaluatorFloat;
  native let lift: effectEffectParameterEvaluatorVector;
  native let gamma: effectEffectParameterEvaluatorVector;
  native let gain: effectEffectParameterEvaluatorVector;
  native let offset: effectEffectParameterEvaluatorVector;
  native let shadow: effectEffectParameterEvaluatorVector;
  native let midtone: effectEffectParameterEvaluatorVector;
  native let highlight: effectEffectParameterEvaluatorVector;
}

public native class effectTrackItemDataMosh extends effectTrackItem {
  native let override: Bool;
  native let intensity: effectEffectParameterEvaluatorFloat;
  native let useGlitch: Bool;
  native let glitchColor: effectEffectParameterEvaluatorVector;
  native let usePixelsort: Bool;
  native let pixelsortOverride: Bool;
  native let pixelsortIntensity: effectEffectParameterEvaluatorFloat;
  native let pixelsortStencil: Bool;
  native let pixelsortVfx: Bool;
}

public native class effectTrackItemDecal extends effectTrackItem {
  native let material: ResourceRef; // rRef<IMaterial>
  native let scale: ref<IEvaluatorVector>;
  native let emissiveScale: ref<IEvaluatorVector>;
  native let normalThreshold: Float;
  native let horizontalFlip: Bool;
  native let verticalFlip: Bool;
  native let fadeOutTime: Float;
  native let fadeInTime: Float;
  native let additionalRotation: Float;
  native let randomRotation: Bool;
  native let randomAtlasing: Bool;
  native let isStretchEnabled: Bool;
  native let isAttached: Bool;
  native let normalsBlendingMode: RenderDecalNormalsBlendingMode;
  native let atlasFrameStart: Int32;
  native let atlasFrameEnd: Int32;
  native let orderPriority: RenderDecalOrderPriority;
  native let surfaceType: ERenderObjectType;
  native let decalRenderMode: EDecalRenderMode;
}

public native class effectTrackItemDynamicDecal extends effectTrackItem {
  native let material: ResourceRef; // rRef<IMaterial>
  native let width: Float;
  native let height: Float;
  native let fadeInTime: Float;
  native let fadeOutTime: Float;
  native let additionalRotation: Float;
  native let randomRotation: Bool;
}

public native class effectTrackItemEmissive extends effectTrackItem {
  native let override: Bool;
  native let brigtness: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemExposureScale extends effectTrackItem {
  native let scale: effectEffectParameterEvaluatorFloat;
  native let useInitialCameraPosDirForFadeout: Bool;
  native let fullEffectRadius: Float;
  native let fadeOutRadius: Float;
  native let fullyVisibleAngle: Float;
  native let fadeOutAngle: Float;
}

public native class effectTrackItemFilmGrain extends effectTrackItem {
  native let override: Bool;
  native let luminanceBias: effectEffectParameterEvaluatorFloat;
  native let strength: effectEffectParameterEvaluatorVector;
  native let mask: array<ERenderObjectType>;
}

public native class effectTrackItemFogVolume extends effectTrackItem {
  native let priority: Uint8;
  native let densityFalloff: Float;
  native let blendFalloff: Float;
  native let density: ref<IEvaluatorFloat>;
  native let size: ref<IEvaluatorVector>;
  native let color: ref<IEvaluatorColor>;
}

public native class effectTrackItemForwardDecal extends effectTrackItem {
  native let mesh: ResourceRef; // rRef<CMesh>
  native let appearance: CName;
  native let scale: ref<IEvaluatorVector>;
  native let additionalRotation: Float;
  native let sizeThreshold: Float;
  native let randomRotation: Bool;
  native let randomAppearance: Bool;
  native let isAttached: Bool;
  native let subUVx: Uint32;
  native let subUVy: Uint32;
  native let frame: Uint32;
  native let fadeOutTime: Float;
  native let fadeInTime: Float;
}

public native class effectTrackItemFOV extends effectTrackItem {
  native let FOV: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemHudParameter extends effectTrackItem {
  native let scale: Float;
  native let glitchParameter: effectEffectParameterEvaluator;
  native let scale1: Float;
  native let glitchParameter1: effectEffectParameterEvaluator;
  native let blackwallScale: Float;
  native let blackwallParameter: effectEffectParameterEvaluator;
}

public native class effectTrackItemLightParameter extends effectTrackItem {
  native let scale: Float;
  native let intensityMultiplier: effectEffectParameterEvaluatorFloat;
  native let intensity: effectEffectParameterEvaluatorFloat;
  native let radius: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemLoopMarker extends effectTrackItemMetadata {}

public native class effectTrackItemMaterialParameter extends effectTrackItem {
  native let scale0: Float;
  native let customParameter0: effectEffectParameterEvaluator;
  native let scale1: Float;
  native let customParameter1: effectEffectParameterEvaluator;
  native let scale2: Float;
  native let customParameter2: effectEffectParameterEvaluator;
  native let scale3: Float;
  native let customParameter3: effectEffectParameterEvaluator;
}

public abstract native class effectTrackItemMetadata extends effectTrackItem {}

public native class effectTrackItemMotionBlurScale extends effectTrackItem {
  native let scale: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemParticles extends effectTrackItem {
  native let particleSystem: ResourceRef; // rRef<CParticleSystem>
  native let emissionScale: effectEffectParameterEvaluatorFloat;
  native let alpha: effectEffectParameterEvaluatorFloat;
  native let size: effectEffectParameterEvaluatorFloat;
  native let velocity: effectEffectParameterEvaluatorFloat;
  native let soundPositionName: CName;
  native let soundPositionOffset: Vector3;
}

public abstract native class effectTrackItemPlayData extends ISerializable {}

public native class effectTrackItemPointLight extends effectTrackItem {
  native let tint: effectEffectParameterEvaluatorColor;
  native let intensity: effectEffectParameterEvaluatorFloat;
  native let EV: Float;
  native let radius: effectEffectParameterEvaluatorFloat;
  native let offset: Vector3;
  native let color: Color;
  native let envColorGroup: EEnvColorGroup;
  native let colorGroupSaturation: Uint8;
  native let roughnessBias: Int8;
  native let useInGI: Bool;
  native let useInVolFog: Bool;
  native let useInTransparents: Bool;
  native let useInParticles: Bool;
  native let sceneDiffuse: Bool;
  native let sceneSpecular: Bool;
  native let clampAttenuation: Bool;
  native let flicker: rendSLightFlickering;
}

public native class effectTrackItemSound extends effectTrackItem {
  native let eventName: CName;
  native let switches: array<audioAudSwitch>;
  native let params: array<audioAudParameter>;
  native let positionName: CName;
  native let emitterMetadataName: CName;
  native let rtpcName: CName;
  native let rtpcValue: ref<IEvaluatorFloat>;
}

public native class effectTrackItemTonemapping extends effectTrackItem {
  native let override: Bool;
  native let maxStopsSDR: effectEffectParameterEvaluatorFloat;
  native let midGrayScaleSDR: effectEffectParameterEvaluatorFloat;
  native let maxStopsHDR: effectEffectParameterEvaluatorFloat;
  native let midGrayScaleHDR: effectEffectParameterEvaluatorFloat;
}

public native class effectTrackItemVignette extends effectTrackItem {
  native let overrideRadiusAndExp: Bool;
  native let overrideColor: Bool;
  native let vignetteRadius: effectEffectParameterEvaluatorFloat;
  native let vignetteExp: effectEffectParameterEvaluatorFloat;
  native let color: effectEffectParameterEvaluatorColor;
}

public native class effectTrackItemWeaponPlaneBlur extends effectTrackItem {
  native let farPlaneMultiplier: effectEffectParameterEvaluatorFloat;
  native let override: Bool;
}

public native class effectVignettePlayData extends effectPlacedTrackItemPlayData {}

public native class effectVisualComponentSpawner extends effectSpawner {
  native let componentName: array<CName>;
}

public abstract native class effectVisualComponentTrackItemPlayData extends effectTrackItemPlayData {}

public native class effectWeaponPlaneBlurPlayData extends effectPlacedTrackItemPlayData {}

enum EFreeVectorAxes {
  FVA_One = 1,
  FVA_Two = 2,
  FVA_Three = 3,
  FVA_Four = 4,
}

enum EInputAction {
  IACT_None = 0,
  IACT_Press = 1,
  IACT_Release = 2,
  IACT_Axis = 3,
}

enum ELightShadowCastingMode {
  LSCM_None = 0,
  LSCM_Normal = 1,
  LSCM_OnlyDynamic = 2,
  LSCM_OnlyStatic = 3,
  LSCM_NormalAndContact = 4,
  LSCM_OnlyContact = 5,
}

enum ELightShadowSoftnessMode {
  LSSM_ExtraSoft = 0,
  LSSM_Soft = 1,
  LSSM_Default = 2,
  LSSM_Sharp = 3,
  LSSM_ExtraSharp = 4,
}

enum ELightType {
  LT_Point = 0,
  LT_Spot = 1,
  LT_Area = 2,
}

enum ELightUnit {
  LU_Lumen = 0,
  LU_Watt = 1,
  LU_Lux = 2,
  LU_Nit = 3,
  LU_EV100 = 4,
}

enum EMaterialModifier {
  EMATMOD_HitProxy = 0,
  EMATMOD_WindData = 1,
  EMATMOD_ParticleParams = 2,
  EMATMOD_RemoteCamera = 3,
  EMATMOD_Mirror = 4,
  EMATMOD_CustomStructBuffer = 5,
  EMATMOD_MotionMatrix = 7,
  EMATMOD_ColorAndTexture = 8,
  EMATMOD_MaterialParams = 9,
  EMATMOD_Eye = 10,
  EMATMOD_Skin = 11,
  EMATMOD_Dismemberment = 13,
  EMATMOD_Garments = 14,
  EMATMOD_ShadowsDebugParams = 15,
  EMATMOD_MultilayeredDebug = 16,
  EMATMOD_ParallaxParams = 17,
  EMATMOD_HighlightsParams = 18,
  EMATMOD_DebugColoring = 19,
  EMATMOD_DrawBufferMask = 20,
  EMATMOD_AutoSpawnData = 21,
  EMATMOD_DestructionRegions = 22,
  EMATMOD_VehicleParams = 12,
  EMATMOD_EffectParams = 6,
  EMATMOD_FloatTracks = 23,
  EMATMOD_AutoHideDistance = 24,
  EMATMOD_Rain = 25,
  EMATMOD_PlanarReflections = 26,
  EMATMOD_WaterSim = 27,
  EMATMOD_TransparencyClipParams = 28,
  EMATMOD_FlatTireParams = 29,
  EMATMOD_MAX = 30,
}

enum EMaterialPriority {
  EMP_Normal = 0,
  EMP_Front = 1,
}

enum EMaterialShaderTarget {
  MSH_Invalid = 0,
  MSH_VertexShader = 1,
  MSH_PixelShader = 2,
  MSH_MAX = 3,
}

enum EMaterialShadingRateMode {
  MSRM_Default = 0,
  MSRM_Disable = 1,
  MSRM_Force2x2 = 2,
}

enum EMaterialVertexFactory {
  MVF_Terrain = 1,
  MVF_MeshStatic = 2,
  MVF_MeshSkinned = 3,
  MVF_MeshExtSkinned = 4,
  MVF_GarmentMeshSkinned = 5,
  MVF_GarmentMeshExtSkinned = 6,
  MVF_MeshSpeedTree = 7,
  MVF_ParticleBilboard = 8,
  MVF_ParticleParallel = 9,
  MVF_ParticleMotionBlur = 10,
  MVF_ParticleSphereAligned = 11,
  MVF_ParticleVerticalFixed = 12,
  MVF_ParticleTrail = 13,
  MVF_ParticleFacingTrail = 14,
  MVF_ParticleScreen = 15,
  MVF_ParticleBeam = 16,
  MVF_ParticleFacingBeam = 17,
  MVF_Decal = 18,
  MVF_Debug = 19,
  MVF_DrawBuffer = 20,
  MVF_Fullscreen = 21,
  MVF_MeshSkinnedVehicle = 22,
  MVF_MeshStaticVehicle = 23,
  MVF_MeshProcedural = 24,
  MVF_MeshDestructible = 25,
  MVF_MeshDestructibleSkinned = 26,
  MVF_MeshSkinnedLightBlockers = 27,
  MVF_MeshExtSkinnedLightBlockers = 28,
  MVF_GarmentMeshSkinnedLightBlockers = 29,
  MVF_GarmentMeshExtSkinnedLightBlockers = 30,
  MVF_MeshSkinnedSingleBone = 31,
  MVF_MeshProxy = 32,
  MVF_MeshWindowProxy = 33,
}

enum EMeshParticleOrientationMode {
  MPOM_Normal = 0,
  MPOM_MovementDirection = 1,
  MPOM_NoRotation = 2,
}

enum EMeshShadowImportanceBias {
  MSIB_EvenLessImportant = -2,
  MSIB_LessImportant = -1,
  MSIB_Default = 0,
  MSIB_MoreImportant = 1,
  MSIB_EvenMoreImportant = 2,
}

enum EMeshStreamType {
  MST_Position_3F = 1,
  MST_SkinningIndices_4U8 = 2,
  MST_SkinningWeights_4F = 4,
  MST_SkinningIndicesExt_4U8 = 262144,
  MST_SkinningWeightsExt_4F = 524288,
  MST_Color_U32 = 8,
  MST_TexCoord0_2F = 16,
  MST_TexCoord1_2F = 32,
  MST_Normal_3F = 64,
  MST_Tangent_3F = 128,
  MST_Binormal_3F = 256,
  MST_DestructionIndices_2U16 = 1048576,
  MST_Multilayer_1F = 2097152,
  MST_Index_U16 = 512,
  MST_GarmentFlags_U32 = 4194304,
  MST_MorphOffset_3F = 8388608,
  MST_VehicleDmgNormalFront_3F = 16777216,
  MST_VehicleDmgNormalSides_3F = 33554432,
  MST_VehicleDmgPosFront_3F = 67108864,
  MST_VehicleDmgPosSides_3F = 134217728,
  MST_WindBranchData_4F = 1024,
  MST_BranchData_7F = 16384,
  MST_MorphVertexData_3F = 268435456,
  MST_FoliageBoneId_I16 = 536870912,
  MST_LightBlockerIntensity_1F = 1073741824,
}

enum EMeshVertexType {
  MVT_StaticMesh = 0,
  MVT_ProceduralMesh = 1,
  MVT_SkinnedMesh = 2,
  MVT_ExtSkinnedMesh = 3,
  MVT_GarmentSkinnedMesh = 4,
  MVT_ExtGarmentSkinnedMesh = 5,
  MVT_SpeedTreeMesh = 6,
  MVT_StaticMeshVehicle = 7,
  MVT_SkinnedMeshVehicle = 8,
  MVT_Terrain = 9,
  MVT_DestructibleMesh = 10,
  MVT_DestructibleMeshSkinned = 11,
  MVT_SkinnedMeshLightBlocker = 12,
  MVT_ExtSkinnedMeshLightBlocker = 13,
  MVT_GarmentSkinnedMeshLightBlocker = 14,
  MVT_ExtGarmentSkinnedMeshLightBlocker = 15,
  MVT_SkinnedMeshSingleBone = 16,
  MVT_ProxyMesh = 17,
  MVT_ProxyWindowMesh = 18,
}

public native class EmissiveColorSettings extends IAreaSettings {
  native let tint: CurveDataHDRColor;
  native let saturation: CurveDataFloat;
  native let brigtness: CurveDataFloat;
  native let exposure: CurveDataVector2;
  native let cameraLuminance: CurveDataVector2;
  native let evBlend: CurveDataFloat;
  native let exposureIBL: CurveDataFloat;
  native let luminanceIBL: CurveDataFloat;
  native let curveRampIBL: Float;
  native let exposureScale: CurveDataFloat;
}

public native struct EmitterDelaySettings {
  native let emitterDelay: Float;
  native let emitterDelayLow: Float;
  native let useEmitterDelayRange: Bool;
  native let useEmitterDelayOnce: Bool;
}

public native struct EmitterDurationSettings {
  native let emitterDuration: Float;
  native let emitterDurationLow: Float;
  native let useEmitterDurationRange: Bool;
}

public native struct EmitterGroupAreaParams {
  native let group: EEmitterGroup;
  native let emissionScale: CurveDataFloat;
  native let opacityScale: CurveDataFloat;
}

public native class EmitterGroupAreaSettings extends IAreaSettings {
  native let emitterGroupParams: array<EmitterGroupParams>;
  native let EmitterGroupParams: array<EmitterGroupAreaParams>;
}

public native struct EmitterGroupParams {
  native let group: EEmitterGroup;
  native let emissionScale: Float;
  native let opacityScale: Float;
}

public importonly native class EnableClientSideInteractionEvent extends Event {}

public native class EnableStickerEditorEvent extends Event {}

public native class EngineTurnedOffEvent extends Event {}

public native class EngineTurnedOnEvent extends Event {}

enum ENoiseType {
  NT_Random = 0,
  NT_Simplex2D = 1,
  NT_Simplex3D = 2,
}

public native class entAllowVehicleCollisionRagdollInSceneEvent extends Event {
  native let allow: Bool;
}

public native class entAmbientSoundEmitterComponent extends IPlacedComponent {
  native let Settings: ref<audioAmbientAreaSettings>;
  native let usePhysicsObstruction: Bool;
  native let occlusionEnabled: Bool;
  native let repositionEnabled: Bool;
  native let obstructionChangeTime: Float;
}

public native class entAnimationControlAttachment extends entIAttachment {}

public native class entAnimationControlBinding extends entISourceBinding {}

public native class entAnimationExtensionAttachment extends entIAttachment {}

public abstract native class entAnimationFloatTrackAttachment extends entIAttachment {}

public native class entAnimationSetupExtensionComponent extends IComponent {
  native let animations: animAnimSetup;
  native let isOverrideContainer: Bool;
  native let controlBinding: ref<entAnimationControlBinding>;
}

public native class entAnimEntityToEntityAttachmentEvent extends Event {}

public native class entAnimGraphCustomDataEvent extends Event {}

public native class entAnimGraphResourceContainer extends IComponent {
  native let animGraphLookupTable: array<AnimGraphResourceContainerEntry>;
}

public native class entAnimOnStateChangedEvent extends Event {}

enum entAnimParamSlotFunction {
  RenderingPlane = 0,
  Visibility = 1,
}

public native class entAnimSoundEvent extends entSoundEvent {
  native let metadataContext: CName;
}

public native struct entAnimTrackParameter {
  native let animTrackName: CName;
  native let parameterName: CName;
  native let defaultValue: Float;
}

public native class entAppearanceDissolveFinishEvent extends Event {}

public native class entAppearanceLODsDistanceOverrideEvent extends Event {}

public native class entAppearanceMeshLoadedEvent extends Event {}

public native class entAppearanceProxyMeshComponent extends PhysicalMeshComponent {}

enum entAppearanceStatus {
  None = 0,
  Proxy = 1,
  Appearance = 2,
}

public native class entAppearanceStatusEvent extends Event {
  native let status: entAppearanceStatus;
}

public abstract native class entAttachEffectEvent extends Event {}

public native class entAttachEffectToComponentEvent extends entAttachEffectEvent {}

public native class entAttachEffectToSlotEvent extends entAttachEffectEvent {}

public native class entAttachGraphToSlotEvent extends Event {}

public native class entChangeVoicesetStateEvent extends Event {
  native let enableVoicesetLines: Bool;
  native let enableVoicesetGrunts: Bool;
  native let inputsToBlock: array<entVoicesetInputToBlock>;
}

public native class entCharacterCustomizationSkinnedMeshComponent extends entSkinnedMeshComponent {
  native let tags: redTagList;
}

public importonly native class entClothComponent extends IVisualComponent {
  native let mesh: ResourceRef; // rRef<CMesh>
  native let isEnabled: Bool;
}

public native class entCollisionPredictionPositionProvider extends IPositionProvider {}

public native class entComponentsStorage extends ISerializable {
  native let components: array<ref<IComponent>>;
}

public native class entCorpseParameter extends entEntityParameter {
  native let lod: Uint32;
  native let bakedPose: array<QsTransform>;
  native let bakedBoneNames: array<CName>;
  native let forceLOD0Components: array<CRUID>;
  native let baseRig: ResourceAsyncRef; // raRef<animRig>
}

public native class entDebug_MeshComponent extends MeshComponent {
  native let filterName: String;
}

public native class entDebug_ShapeComponent extends IVisualComponent {
  native let radius: Float;
  native let halfHeight: Float;
  native let color: Color;
  native let isEnabled: Bool;
}

enum entDebug_ShapeType {
  Sphere = 0,
  Box = 1,
  Capsule = 2,
  Cylinder = 3,
}

public native class entDebugPositionProvider extends IPositionProvider {}

public native class entDecalComponent extends IVisualComponent {
  native let material: ResourceRef; // rRef<IMaterial>
  native let verticalFlip: Bool;
  native let horizontalFlip: Bool;
  native let aspectRatio: Float;
  native let scale: Float;
  native let visualScale: Vector3;
  native let alpha: Float;
  native let normalThreshold: Float;
  native let roughnessScale: Float;
  native let orderNo: Uint16;
  native let surfaceType: ERenderObjectType;
  native let decalRenderMode: EDecalRenderMode;
  native let isStretchingEnabled: Bool;
  native let normalsBlendingMode: RenderDecalNormalsBlendingMode;
  native let shouldCollectWithRayTracing: Bool;
  native let isEnabled: Bool;
}

public native class entDestructionAudioEvent extends Event {}

public native class entDetachGraphFromSlotEvent extends Event {}

public native struct entdismembermentAppearanceMatch {
  native let Character: CName;
  native let Mesh: CName;
  native let SetByUser: Bool;
}

public native struct entdismembermentBodyMaterialConfig {}

public native struct entdismembermentCullObject {
  native let Plane: Plane;
  native let Plane1: Plane;
  native let CapsulePointA: Vector3;
  native let CapsulePointB: Vector3;
  native let CapsuleRadius: Float;
  native let NearestAnimBoneName: CName;
  native let NearestAnimIndex: Int16;
  native let RagdollBodyIndex: Uint16;
}

public native struct entdismembermentDangleInfo {
  native let DangleSegmentLenght: Float;
  native let DangleVelocityDamping: Float;
  native let DangleBendStiffness: Float;
  native let DangleSegmentStiffness: Float;
  native let DangleCollisionSphereRadius: Float;
}

public native class entdismembermentDebris extends CResource {
  native let items: array<entdismembermentDebrisResourceItem>;
}

public native struct entdismembermentDebrisResourceItem {
  native let rig: ResourceRef; // rRef<animRig>
  native let mesh: ResourceRef; // rRef<CMesh>
}

public native class entdismembermentEffectResource extends ISerializable {
  native let Name: CName;
  native let AppearanceNames: array<CName>;
  native let Offset: Transform;
  native let Effect: ResourceAsyncRef; // raRef<worldEffect>
  native let MatchToWoundByName: Bool;
}

public native struct entdismembermentMeshInfo {
  native let Mesh: ResourceAsyncRef; // raRef<CMesh>
  native let MeshAppearance: CName;
  native let AppearanceMap: array<entdismembermentAppearanceMatch>;
  native let ShouldReceiveDecal: Bool;
  native let Offset: Transform;
  native let Scale: Vector3;
  native let Physics: entdismembermentPhysicsInfo;
}

public native struct entdismembermentPhysicsInfo {
  native let DensityScale: Float;
}

enum entdismembermentResourceSetE {
  NONE = 16,
  BARE = 0,
  BARE1 = 1,
  BARE2 = 2,
  BARE3 = 3,
  GARMENT = 4,
  GARMENT1 = 5,
  GARMENT2 = 6,
  GARMENT3 = 7,
  CYBER = 8,
  CYBER1 = 9,
  CYBER2 = 10,
  CYBER3 = 11,
  MIXED = 12,
  MIXED1 = 13,
  MIXED2 = 14,
  MIXED3 = 15,
}

enum entdismembermentSimulationTypeE {
  NONE = 0,
  DANGLE = 128,
}

public native class entdismembermentWoundConfig extends ISerializable {
  native let WoundName: CName;
  native let ResourceSet: entdismembermentResourceSetE;
}

public native class entdismembermentWoundConfigContainer extends ISerializable {
  native let AppearanceName: CName;
  native let Wounds: array<entdismembermentWoundConfig>;
}

public native struct entdismembermentWoundDecal {
  native let OffsetA: Vector3;
  native let OffsetB: Vector3;
  native let Scale: Float;
  native let FadeOrigin: Float;
  native let FadePower: Float;
  native let Material: ResourceAsyncRef; // raRef<IMaterial>
}

public native struct entdismembermentWoundMeshes {
  native let ResourceSet: entdismembermentResourceSetE;
  native let Meshes: array<entdismembermentMeshInfo>;
  native let FillMeshes: array<entdismembermentFillMeshInfo>;
}

public native class entdismembermentWoundResource extends ISerializable {
  native let Name: CName;
  native let CullObject: entdismembermentCullObject;
  native let GarmentMorphStrength: Float;
  native let UseProceduralCut: Bool;
  native let UseSingleMeshForRagdoll: Bool;
  native let IsCritical: Bool;
  native let Resources: array<entdismembermentWoundMeshes>;
  native let Decals: array<entdismembermentWoundDecal>;
  native let CensoredPaths: array<Uint64>;
  native let CensoredCookedPaths: array<ResourceAsyncRef>;
  native let CensorshipValid: Bool;
}

public native struct entdismembermentWoundsConfigSet {
  native let Configs: array<ref<entdismembermentWoundConfigContainer>>;
}

public native class entDistanceLODsPresets extends ISerializable {
    native let definitions: [entLODDefinition; 4];
}

public native class entDynamicActorRepellingComponent extends IPlacedComponent {
  native let type: entRepellingType;
  native let shape: entRepellingShape;
  native let magnitude: Float;
  native let bendIntensity: Float;
  native let anchorPointVert: rendWindShapeAnchorPointVert;
  native let anchorPointHorz: rendWindShapeAnchorPointHorz;
  native let anchorPointDepth: rendWindShapeAnchorPointDepth;
  native let radius: Float;
  native let capsuleRadius: Float;
  native let capsuleHeight: Float;
}

enum entEBindingDirection {
  BindToSource = 0,
  BindToDestination = 1,
}

public native class entEffectAttachmentComponent extends IComponent {}

public native class entEffectDesc extends ISerializable {
  native let id: CRUID;
  native let effectName: CName;
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let compiledEffectInfo: worldCompiledEffectInfo;
  native let autoSpawnTag: CName;
  native let isAutoSpawn: Bool;
  native let randomWeight: Uint8;
}

public importonly native class entEffectSpawnerComponent extends IVisualComponent {
  native let effectDescs: array<ref<entEffectDesc>>;
}

public native class entEntityInstanceData extends ISerializable {}

public native class entEntityOrientationProvider extends IOrientationProvider {
  native let slotComponent: wref<SlotComponent>;
  native let slotId: Int32;
  native let entity: wref<Entity>;
  native let orientationEntitySpace: Quaternion;
}

public abstract importonly native class entEntityParameter extends ISerializable {}

public native struct entEntityParametersBuffer {}

public native class entEntityParametersStorage extends ISerializable {
  native let parameters: array<ref<entEntityParameter>>;
}

public native class entEntityPositionProvider extends IPositionProvider {}

public native class entEntityPreview extends Entity {}

enum entEntitySpawnPriority {
  Background = 0,
  Normal = 1,
  Immediate = 2,
  Paramount = 3,
  Critical = 4,
}

public abstract native class entEntitySpawnToken extends IScriptable {}

public native class entEntityTemplate extends resStreamedResource {
  native let includes: array<entTemplateInclude>;
  native let appearances: array<entTemplateAppearance>;
  native let defaultAppearance: CName;
  native let visualTagsSchema: ref<entVisualTagsSchema>;
  native let componentResolveSettings: array<entTemplateComponentResolveSettings>;
  native let bindingOverrides: array<entTemplateBindingOverride>;
  native let backendDataOverrides: array<entTemplateComponentBackendDataOverrideInfo>;
  native let resolvedDependencies: array<ResourceAsyncRef>;
  native let inplaceResources: array<ResourceRef>;
  native let compiledEntityLODFlags: Uint16;
}

public native struct entEntityUserComponentResolution {
  native let id: CRUID;
  native let include: ResourceAsyncRef; // raRef<entEntityTemplate>
  native let mode: entEntityUserComponentResolutionMode;
}

enum entEntityUserComponentResolutionMode {
  Select = 0,
  Suppress = 1,
}

public native class enteventsSetCustomCameraTarget extends Event {}

public native class enteventsSetDissolveVisibility extends Event {}

public native class enteventsSetPlaneSetting extends Event {}

public native class entExternalComponent extends IComponent {
  native let externalComponentName: CName;
}

public native class entFacialCustomizationComponent extends IComponent {
  native let debugIgnoreComponent: Bool;
  native let customizationSet: ResourceAsyncRef; // raRef<animFacialCustomizationSet>
  native let eyes: Uint32;
  native let nose: Uint32;
  native let mouth: Uint32;
  native let jaw: Uint32;
  native let ears: Uint32;
}

public abstract native class entFactory extends ISerializable {}

public native struct entFallbackSlot {
  native let slotName: CName;
  native let boneName: CName;
}

public native class entFogVolumeComponent extends IVisualComponent {
  native let densityFalloff: Float;
  native let blendFalloff: Float;
  native let densityFactor: Float;
  native let color: Color;
  native let absorption: Float;
  native let size: Vector3;
  native let isEnabled: Bool;
}

public native class entFoleyActionEvent extends Event {
  native let actionName: CName;
}

public native class entFootPhaseChangedEvent extends Event {
  native let footPhase: animEFootPhase;
}

public native class entFootPlantedEvent extends Event {
  native let customAction: CName;
  native let footSide: animEventSide;
}

enum entForcedLodDistance {
  Default = 0,
  Background = 1,
  Regular = 2,
  Cinematic = 3,
  Vehicle = 4,
  CinematicVehicle = 5,
  VehicleInterior = 6,
  VehicleDecoration = 7,
  ConsoleLOD = 8,
}

public native class entFuncOrientationProvider extends IOrientationProvider {}

public native class entFuncPositionProvider extends IPositionProvider {}

public native class entGarmentParameter extends entEntityParameter {
  native let componentsData: array<entGarmentParameterComponentData>;
  native let collarArea: garmentCollarAreaParams;
}

public native struct entGarmentParameterChunkData {
  native let morphOffsetScales: array<Uint8>;
  native let morphOffsetScalesHash: Uint64;
  native let visibleTriangleInds: array<Uint16>;
  native let vertexTbn: array<Uint32>;
}

public native struct entGarmentParameterComponentData {
  native let componentID: CRUID;
  native let meshGeometryHash: Uint64;
  native let visibleTrangleIndexBufferHash: Uint64;
  native let chunks: array<entGarmentParameterChunkData>;
  native let chunksCount: Uint32;
  native let hideComponent: Bool;
  native let bendPowerMultiplier: Float;
  native let bendPowerOffset: Float;
  native let smoothingStrength: Float;
  native let smoothingThreshold: Float;
  native let smoothingExponent: Float;
  native let smoothNormalsEnabled: Bool;
  native let smoothingNumNeighbours: Uint32;
  native let garmentBorderThreshold: Float;
  native let removeHiddenTriangles: Bool;
  native let disableGarment: Bool;
  native let mergeWithInnerLayer: Bool;
  native let numIndices: Uint32;
  native let numOffsets: Uint32;
}

public native class entGarmentSkinnedMeshComponent extends entSkinnedMeshComponent {}

public native class entGenericListFactory extends entFactory {}

public native class entHardAttachment extends entITransformAttachment {}

public native class entHardTransformBinding extends entITransformBinding {
  native let slotName: CName;
}

public native class entHistoryPositionProvider extends IPositionProvider {}

public native class entHitRepresentationDataParameter extends entEntityParameter {
  native let hitRepresentationOverrides: array<HitRepresentationOverride>;
}

public native class entIAttachment extends ISerializable {
  native let source: wref<IComponent>;
  native let destination: wref<IComponent>;
}

public abstract native class entIBinding extends ISerializable {
  native let enabled: Bool;
  native let enableMask: entTagMask;
  native let bindName: CName;
}

public abstract native class entIDestinationBinding extends entIBinding {}

public abstract importonly native class entIMoverComponent extends IComponent {}

public native class entInjectVoiceTagEvent extends Event {
  native let voiceTagName: CName;
  native let forceInjection: Bool;
}

public native class entInstancedAnimationComponent extends ISkinableComponent {
  native let animations: ResourceRef; // rRef<animAnimSet>
  native let animToSample: CName;
  native let variantAnimToSample: CName;
  native let variantTriggerTag: CName;
}

public abstract native class entISkinningAttachment extends entIAttachment {}

public abstract native class entISkinTargetComponent extends IVisualComponent {
  native let skinning: ref<entSkinningBinding>;
  native let useSkinningLOD: Bool;
}

public abstract native class entISourceBinding extends entIBinding {}

public native class EntitiesWithStatusEffectPrereq extends IPrereq {}

public native class EntitiesWithStatusEffectPrereqState extends PrereqState {}

public abstract native class entITransformAttachment extends entIAttachment {}

public abstract native class entITransformBinding extends entISourceBinding {}

public native class EntityIDArrayPrereq extends IPrereq {}

public native class EntityIDArrayPrereqState extends PrereqState {}

public native class EntityResizeEvent extends Event {
  native let extents: Vector3;
}

public importonly native class EntitySpawnerComponent extends GameComponent {
  native let slotDataArray: array<EntitySpawnerSlotData>;
}

public native struct EntitySpawnerSlotData {
  native let slotName: CName;
  native let spawnableObject: TweakDBID;
}

public native class EntityStubHandlerProviderSystem extends AIIEntityStubHandlerProviderSystem {}

public native class EntityTargetedEvent extends Event {
  native let targetingEntity: wref<Entity>;
}

public native class EntityUntargetedEvent extends Event {
  native let targetingEntity: wref<Entity>;
}

public native class entLightBlockingComponent extends IVisualComponent {
  native let radius: Float;
  native let lightBlockerComponentVersion: Uint8;
}

public native struct entLocalizationStringMapEntry {
  native let key: CName;
  native let string: LocalizationString;
}

public native class entLocomotionSlideEvent extends Event {}

public native struct entLODDefinition {
    native let backgroundDistanceLODs: [Float; 4];
    native let cinematicDistanceLODs: [Float; 4];
    native let cinematicVehicleDistanceLODs: [Float; 4];
    native let consoleDistanceLODs: [Float; 4];
    native let regularDistanceLODs: [Float; 4];
    native let vehicleDecorationDistanceLODs: [Float; 4];
    native let vehicleDistanceLODs: [Float; 4];
    native let vehicleInteriorDistanceLODs: [Float; 4];
}

public native struct entLookAtLimits {
  native let softLimitDegrees: Float;
  native let hardLimitDegrees: Float;
  native let hardLimitDistance: Float;
  native let backLimitDegrees: Float;
}

public native class entMarketingAnimationComponent extends IPlacedComponent {
  native let freezeAnimations: Bool;
  native let animations: array<entMarketingAnimationEntry>;
  native let enableLookAt: Bool;
  native let lookAtSettings: ref<animLookAtPreset_FullControl>;
  native let lookAtCamera: Bool;
  native let lookAtOrbitDistance: Float;
  native let lookAtTargetPitch: Float;
  native let lookAtTargetYaw: Float;
}

public native struct entMarketingAnimationEntry {
  native let animationName: CName;
  native let time: Float;
  native let frame: Float;
}

enum entMeshComponentLODMode {
  AlwaysVisible = 0,
  Appearance = 1,
  AppearanceProxy = 2,
}

public native class entMorphTargetManagerComponent extends entExternalComponent {}

public native class entMorphTargetSkinnedMeshComponent extends entISkinTargetComponent {
  native let morphResource: ResourceAsyncRef; // raRef<MorphTargetMesh>
  native let meshAppearance: CName;
  native let castShadows: shadowsShadowCastingMode;
  native let castLocalShadows: shadowsShadowCastingMode;
  native let acceptDismemberment: Bool;
  native let chunkMask: Uint64;
  native let renderingPlaneAnimationParam: CName;
  native let visibilityAnimationParam: CName;
  native let isEnabled: Bool;
  native let tags: redTagList;
  native let version: Uint8;
}

public native struct entMorphTargetWeightEntry {
  native let targetName: CName;
  native let regionName: CName;
  native let weight: Float;
}

public native class entParticlesComponent extends IVisualComponent {
  native let emissionRate: Float;
  native let particleSystem: ResourceRef; // rRef<CParticleSystem>
  native let autoHideRange: Float;
  native let isEnabled: Bool;
}

public importonly native class entPhysicalFractureFieldComponent extends PhysicalTriggerComponent {
  native let fractureFieldParams: physicsFractureFieldParams;
}

public importonly native class entPhysicalImpulseAreaComponent extends PhysicalTriggerComponent {
  native let impulse: Vector3;
  native let impulseRadius: Float;
}

public native class entPlacedComponentPositionProvider extends IPositionProvider {}

public native class entPlaceholderComponent extends IPlacedComponent {}

public importonly native class entPreloadAllEffectsEvent extends Event {}

public importonly native class entPreloadEffectEvent extends Event {
  native let effectName: CName;
}

public importonly native class entReleasePreloadedEffectEvent extends Event {
  native let effectName: CName;
}

public importonly native class entReleasePreloadedEffectsEvent extends Event {}

public importonly native class entRenderHighlightEvent extends Event {
  native let fillIndex: Uint8;
  native let outlineIndex: Uint8;
  native let seeThroughWalls: Bool;
  native let componentName: CName;
  native let opacity: Float;
}

public native class entRenderOverlayEvent extends Event {}

public importonly native class entRenderScanEvent extends Event {
  native let scanState: rendPostFx_ScanningState;
}

public native class entRenderToTextureCameraComponent extends entCameraComponent {
  native let isEnabled: Bool;
  native let virtualCameraName: CName;
  native let dynamicTextureRes: ResourceAsyncRef; // raRef<DynamicTexture>
  native let depthDynamicTextureRes: ResourceRef; // rRef<DynamicTexture>
  native let albedoDynamicTextureRes: ResourceRef; // rRef<DynamicTexture>
  native let normalsDynamicTextureRes: ResourceRef; // rRef<DynamicTexture>
  native let particlesDynamicTextureRes: ResourceRef; // rRef<DynamicTexture>
  native let resolutionWidth: Uint32;
  native let resolutionHeight: Uint32;
  native let aspectRatio: Float;
  native let env: ResourceRef; // rRef<worldEnvironmentAreaParameters>
  native let params: WorldRenderAreaSettings;
  native let renderingMode: entRenderToTextureMode;
  native let depthCutDistance: Float;
  native let backgroundColor: Color;
  native let overrideBackgroundColor: Bool;
  native let renderSceneLayer: RenderSceneLayer;
  native let features: entRenderToTextureFeatures;
  native let streamingDistance: Float;
}

public native struct entRenderToTextureFeatures {
  native let renderDecals: Bool;
  native let renderParticles: Bool;
  native let renderForwardNoTXAA: Bool;
  native let antiAliasing: entRenderToTextureFeaturesPlatform;
  native let contactShadows: Bool;
  native let localShadows: Bool;
  native let SSAO: entRenderToTextureFeaturesPlatform;
  native let reflections: entRenderToTextureFeaturesPlatform;
}

enum entRenderToTextureFeaturesPlatform {
  RTFP_All = 0,
  RTFP_PC = 1,
  RTFP_PC_PS5_XSX = 2,
  RTFP_Consoles = 3,
  RTFP_None = 4,
}

enum entRenderToTextureMode {
  Shaded = 0,
  GBufferOnly = 1,
}

enum entRepellingShape {
  Sphere = 0,
  Capsule = 1,
}

enum entRepellingType {
  Debris = 0,
  BigObjects = 1,
  WindImpulse = 2,
  WaterImpulse = 3,
}

public native struct entReplicatedAnimFeaturesState {
  native let items: array<entReplicatedAnimFeature>;
  native let lastAppliedActionsTime: netTime;
}

public native struct entReplicatedAnimWrapperVars {
  native let serverReplicatedTime: netTime;
  native let data: array<entReplicatedVariableValue>;
}

public native struct entReplicatedInputSetterBase {
  native let name: CName;
  native let applyServerTime: netTime;
}

public native struct entReplicatedInputSetters {
  native let serverReplicatedTime: netTime;
}

public native struct entReplicatedItem {
  native let entity: wref<Entity>;
  native let netTime: netTime;
}

public native struct entReplicatedLookAtData {
  native let creationNetTime: netTime;
}

public native struct entReplicatedVariableValue {
  native let name: CName;
  native let value: Float;
  native let applyServerTime: netTime;
}

public native class entRuntimeSystemEditorMeshes extends worldIRuntimeSystem {}

public native class entSceneAnimSetEvent extends Event {}

public native class entShadowMeshChangeEvent extends Event {
  native let requestedState: entAppearanceStatus;
}

public abstract native class entSimpleSkinningAttachment extends entISkinningAttachment {}

public importonly native class entSkinnedClothComponent extends entISkinTargetComponent {
  native let graphicsMesh: ResourceAsyncRef; // raRef<CMesh>
  native let physicalMesh: ResourceAsyncRef; // raRef<CMesh>
  native let isEnabled: Bool;
  native let LODMode: entMeshComponentLODMode;
  native let meshAppearance: CName;
  native let chunkMask: Uint64;
  native let compiledTopologyData: meshCookedClothMeshTopologyData;
}

public native class entSkinnedMeshComponent extends entISkinTargetComponent {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let meshAppearance: CName;
  native let castShadows: shadowsShadowCastingMode;
  native let castLocalShadows: shadowsShadowCastingMode;
  native let acceptDismemberment: Bool;
  native let chunkMask: Uint64;
  native let renderingPlaneAnimationParam: CName;
  native let visibilityAnimationParam: CName;
  native let order: Uint8;
  native let isEnabled: Bool;
  native let LODMode: entMeshComponentLODMode;
  native let useProxyMeshAsShadowMesh: Bool;
  native let forcedLodDistance: entForcedLodDistance;
  native let overrideMeshNavigationImpact: Bool;
  native let navigationImpact: NavGenNavigationSetting;
  native let version: Uint8;
}

public native class entSkinningBinding extends entISourceBinding {}

public native struct entSlot {
  native let slotName: CName;
  native let relativePosition: Vector3;
  native let relativeRotation: Quaternion;
  native let boneName: CName;
}

public native class entSlotAttachment extends entITransformAttachment {}

public native class entSlotPositionProvider extends IPositionProvider {}

public native class entSoundEvent extends Event {
  native let eventName: CName;
  native let switches: array<audioAudSwitch>;
  native let params: array<audioAudParameter>;
  native let dynamicParams: array<CName>;
}

public native class entSoundListenerComponent extends IPlacedComponent {}

public native class entSpawnersContainer extends ISerializable {}

public native class entStaticOccluderMeshComponent extends IPlacedComponent {
  native let mesh: ResourceRef; // rRef<CMesh>
  native let scale: Vector3;
  native let color: Color;
  native let occluderType: visWorldOccluderType;
  native let occluderAutohideDistanceScale: Uint8;
}

public native class entStaticOrientationProvider extends IOrientationProvider {
  native let staticOrientation: Quaternion;
}

public native class entStaticPositionProvider extends IPositionProvider {}

public native struct entTagMask {
  native let hardTags: redTagList;
  native let softTags: redTagList;
  native let excludedTags: redTagList;
}

public native struct entTemplateAppearance {
  native let name: CName;
  native let appearanceResource: ResourceAsyncRef; // raRef<appearanceAppearanceResource>
  native let appearanceName: CName;
}

public native struct entTemplateBindingOverride {
  native let componentName: CName;
  native let propertyName: CName;
  native let binding: ref<entIBinding>;
}

public native struct entTemplateComponentBackendDataOverrideInfo {
  native let componentName: CName;
  native let offset: Vector2;
}

enum entTemplateComponentResolveMode {
  AutoSelect = 0,
  Select = 1,
  Suppress = 2,
}

public native struct entTemplateComponentResolveSettings {
  native let componentName: CName;
  native let nameParam: CName;
  native let mode: entTemplateComponentResolveMode;
}

public native struct entTemplateInclude {
  native let name: CName;
  native let template: ResourceAsyncRef; // raRef<entEntityTemplate>
}

public native class entTransformComponent extends IPlacedComponent {}

public native class entTriggerActivatorComponent extends IPlacedComponent {
  native let radius: Float;
  native let height: Float;
  native let maxContinousDistance: Float;
  native let enableCCD: Bool;
  native let isEnabled: Bool;
}

public importonly native class entTriggerComponent extends PhysicalTriggerComponent {}

public native class entTriggerDestructionEvent extends Event {}

public native class entTriggerNotifier_Entity extends worldITriggerAreaNotifer {
  native let entityRef: NodeRef;
}

public native class entTriggerNotifier_EntityInstance extends worldITriggerAreaNotiferInstance {}

public native class entTriggerVOEvent extends Event {
  native let triggerBaseName: CName;
  native let triggerVariationIndex: Uint32;
  native let triggerVariationNumber: Uint32;
  native let debugInitialContext: CName;
  native let answeringEntityIDHash: Uint64;
  native let ignoreGlobalVoLimitCheck: Bool;
  native let overridingVoContext: locVoiceoverContext;
  native let overridingVoiceoverExpression: locVoiceoverExpression;
  native let overrideVoiceoverExpression: Bool;
  native let overridingVisualStyleValue: Uint8;
  native let overrideVisualStyle: Bool;
}

public native class entUpdateEffectPositionEvent extends Event {}

public native class entUpdateRenderProxyStateEvent extends Event {}

public native class entVectorFieldComponent extends IVisualComponent {
  native let direction: Vector3;
  native let isEnabled: Bool;
}

public native class entVertexAnimationBinding extends entISourceBinding {}

public native class entVertexAnimationComponent extends IComponent {
  native let vertexAnimationMapper: entVertexAnimationMapper;
  native let animatedComponent: ref<entISourceBinding>;
}

public native struct entVertexAnimationMapper {
  native let entries: array<entVertexAnimationMapperEntry>;
}

public native struct entVertexAnimationMapperDestination {
  native let vertexCustomSlotIndex: Uint32;
}

public native struct entVertexAnimationMapperEntry {
  native let destination: entVertexAnimationMapperDestination;
}

public native struct entVertexAnimationMapperSource {
  native let type: entVertexAnimationMapperSourceType;
  native let name: CName;
}

enum entVertexAnimationMapperSourceType {
  FloatTrack = 0,
  TranslationX = 1,
  TranslationY = 2,
  TranslationZ = 3,
  RotationQuatX = 4,
  RotationQuatY = 5,
  RotationQuatZ = 6,
  RotationQuatW = 7,
}

public native struct entVisualControllerDependency {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let appearanceName: CName;
  native let componentName: CName;
}

public native class entVisualOffsetTransformComponent extends entTransformComponent {}

public native class entVisualTagsSchema extends ISerializable {
  native let visualTags: redTagList;
  native let schema: CName;
}

public native struct entVoicesetInputToBlock {
  native let input: CName;
  native let blockSpecificVariation: Bool;
  native let variationNumber: Uint32;
}

public native class entWorkspotItemEvent extends Event {}

public native class EnvironmentColorGroupsSettings extends IAreaSettings {
  native let skyTint: CurveDataHDRColor;
  native let colorGroup: [CurveDataHDRColor; 16];
}

public native class EnvProbeComponent extends IVisualComponent {
  native let isEnabled: Bool;
  native let size: Vector3;
  native let edgeScale: Vector3;
  native let emissiveScale: Float;
  native let globalProbe: Bool;
  native let boxProjection: Bool;
  native let allInShadow: Bool;
  native let streamingDistance: Float;
  native let streamingHeight: Float;
  native let blendRange: Uint8;
  native let neighborMode: envUtilsNeighborMode;
  native let hideSkyColor: Bool;
  native let ambientMode: envUtilsReflectionProbeAmbientContributionMode;
  native let brightnessEVClamp: Uint8;
  native let probeDataRef: ResourceAsyncRef; // raRef<CReflectionProbeDataResource>
  native let priority: Uint8;
}

enum envUtilsNeighborMode {
  eCLOSEST = 0,
  eONLY_GLOBAL = 1,
  eONLY_SELF = 2,
  eFILL_SURROUNDING = 3,
}

enum envUtilsReflectionProbeAmbientContributionMode {
  eNO_AMBIENT_CONTRIBUTION = 0,
  eALLOW_AMBIENT_CONTRIBUTION = 1,
  eOVERRIDE_GI_AMBIENT = 2,
}

enum EParticleEventSpawnObject {
  PESO_Particle = 0,
  PESO_Decal = 1,
}

enum EParticleEventType {
  PET_Any = 5,
  PET_Death = 0,
  PET_OverLife = 1,
  PET_OverDistance = 2,
  PET_Collision = 3,
  PET_PlayOneShotSoundOnSpawn = 4,
}

public native class EquippedPrereq extends IPrereq {
  native let itemID: ItemID;
  native let slot: TweakDBID;
}

public native class EquippedPrereqState extends PrereqState {}

enum ERenderDynamicDecalAtlas {
  RDDA_1x1 = 0,
  RDDA_2x1 = 1,
  RDDA_2x2 = 2,
  RDDA_4x2 = 3,
  RDDA_4x4 = 4,
  RDDA_8x4 = 5,
}

enum ERenderDynamicDecalProjection {
  RDDP_Ortho = 0,
  RDDP_Sphere = 1,
}

enum ERenderingMode {
  RM_HitProxies = 2,
  RM_Shaded = 0,
  RM_Shaded_NoAmbient = 1,
  RM_GBufferOnly = 3,
  RM_SafeMode = 4,
  RM_OverlayOnly = 5,
}

enum ERenderMaterialType {
  RMT_Standard = 0,
  RMT_Subsurface = 1,
  RMT_Cloth = 2,
  RMT_Eye = 3,
  RMT_Hair = 4,
  RMT_Foliage = 5,
}

enum ERenderMeshStreams {
  RMS_PositionSkinning = 1,
  RMS_TexCoords = 2,
  RMS_TangentFrame = 4,
  RMS_Extended = 8,
  RMS_Custom0 = 16,
  RMS_BindAll = 255,
}

enum ERenderObjectType {
  ROT_Static = 0,
  ROT_Terrain = 1,
  ROT_Road = 2,
  ROT_Skinned = 20,
  ROT_Character = 21,
  ROT_Foliage = 22,
  ROT_Grass = 23,
  ROT_Vehicle = 24,
  ROT_Weapon = 25,
  ROT_Particle = 26,
  ROT_Enemy = 27,
  ROT_CustomCharacter1 = 12,
  ROT_CustomCharacter2 = 13,
  ROT_CustomCharacter3 = 14,
  ROT_Blackwall1 = 28,
  ROT_Blackwall2 = 29,
  ROT_MainPlayer = 15,
  ROT_NoAO = 16,
  ROT_NoLighting = 17,
  ROT_NoTXAA = 18,
}

enum ERenderProxyType {
  RPT_None = 0,
  RPT_Mesh = 1,
  RPT_PointLight = 2,
  RPT_SpotLight = 3,
  RPT_AreaLight = 4,
  RPT_Particles = 5,
  RPT_Foliage = 6,
  RPT_SSDecal = 7,
  RPT_VectorField = 8,
  RPT_FogVolume = 9,
  RPT_GI = 10,
  RPT_ReflectionProbe = 11,
  RPT_MorphTargetMesh = 12,
  RPT_LightVolume = 13,
  RPT_DynamicDecalSpawner = 14,
  RPT_AutoSpawner = 15,
  RPT_LightBlocker = 16,
}

enum ESaveFormat {
  SF_PNG = 2,
  SF_EXR = 32,
  SF_PNG_AND_EXR = 34,
}

enum ESSAOQualityLevel {
  SSAOQUALITY_VeryLow = 0,
  SSAOQUALITY_Low = 1,
  SSAOQUALITY_Medium = 2,
  SSAOQUALITY_High = 3,
  SSAOQUALITY_VeryHigh = 4,
}

enum ESystemNotificationTypes {
  DiscOperationIndicator = 0,
  GenericNotModal = 1,
  AchievmentDebug = 2,
  GenericMenuInfo = 3,
  GenericYesNo = 4,
  Generic = 5,
  ExitGame = 6,
  StartNewGame = 7,
  NoDiscSpace = 8,
  OverwriteSaveFile = 9,
  OverwriteSaveFileXbCompatWarning = 10,
  LoadSaveFileInGame = 11,
  LoadSaveFile = 12,
  DeleteSaveFile = 13,
  TransferSaveFile = 14,
  CorruptedSaveFile = 15,
  UnreachableCloudFile = 16,
  RegionMismatchSaveFile = 17,
  NoPlayerProfile = 18,
  GameSaved = 19,
  SaveFailed = 20,
  UnavailableForGuest = 21,
  EnableTelemetry = 22,
  PointOfNoReturn = 23,
  PointOfNoReturnWithReward = 24,
  PointOfNoReturnLootAdded = 25,
  GenericMenuError = 26,
  ControllerReconnected = 27,
  ControllerDisconnected = 28,
  TrialPeriodEnded = 29,
  TrialPeriodTimer = 30,
  FailedToRemoveTransferredSave = 31,
  LoadModdedSaveFile = 32,
  MAX = 33,
  FirstModalHighPriority = 27,
}

enum ETextureAddressing {
  TA_Wrap = 0,
  TA_Mirror = 1,
  TA_Clamp = 2,
  TA_MirrorOnce = 3,
  TA_Border = 4,
}

enum ETextureAnimationMode {
  TAM_Speed = 0,
  TAM_LifeTime = 1,
}

enum ETextureComparisonFunction {
  TCF_None = 0,
  TCF_Less = 1,
  TCF_Equal = 2,
  TCF_LessEqual = 3,
  TCF_Greater = 4,
  TCF_NotEqual = 5,
  TCF_GreaterEqual = 6,
  TCF_Always = 7,
}

enum ETextureCompression {
  TCM_None = 0,
  TCM_DXTNoAlpha = 1,
  TCM_DXTAlpha = 2,
  TCM_RGBE = 3,
  TCM_Normalmap = 4,
  TCM_Normals_DEPRECATED = 5,
  TCM_NormalsHigh_DEPRECATED = 6,
  TCM_NormalsGloss_DEPRECATED = 7,
  TCM_TileMap = 8,
  TCM_DXTAlphaLinear = 9,
  TCM_QualityR = 10,
  TCM_QualityRG = 11,
  TCM_QualityColor = 12,
  TCM_HalfHDR_Unsigned = 13,
  TCM_HalfHDR_Signed = 14,
  TCM_Max = 15,
  TCM_Normals = 5,
  TCM_NormalsHigh = 6,
  TCM_NormalsGloss = 7,
  TCM_HalfHDR = 13,
}

enum ETextureFilteringMag {
  TFMag_Point = 0,
  TFMag_Linear = 1,
}

enum ETextureFilteringMin {
  TFMin_Point = 0,
  TFMin_Linear = 1,
  TFMin_Anisotropic = 2,
  TFMin_AnisotropicLow = 3,
}

enum ETextureFilteringMip {
  TFMip_None = 0,
  TFMip_Point = 1,
  TFMip_Linear = 2,
}

enum ETextureRawFormat {
  TRF_Invalid = 0,
  TRF_TrueColor = 1,
  TRF_DeepColor = 2,
  TRF_Grayscale = 3,
  TRF_HDRFloat = 4,
  TRF_HDRHalf = 5,
  TRF_HDRFloatGrayscale = 6,
  TRF_Grayscale_Font = 7,
  TRF_R8G8 = 8,
  TRF_R32UI = 9,
  TRF_AlphaGrayscale = 0,
}

enum ETimeOfYearSeason {
  ETOYS_Spring = 0,
  ETOYS_Summer = 1,
  ETOYS_Autumn = 2,
  ETOYS_Winter = 3,
}

enum ETransitionType {
  EET_Linear = 0,
  EET_Sine = 1,
  EET_Cubic = 2,
  EET_Quad = 3,
  EET_Quart = 4,
  EET_Quint = 5,
  EET_Expo = 6,
  EET_Circ = 7,
  EET_Back = 8,
  EET_Bounce = 9,
  EET_Elastic = 10,
}

enum EVisualizerRuntimeFlags {
  None = 0,
  Locked = 1,
  Failsafe = 2,
  Dbg_Active = 4,
}

public native class ExposureAreaSettings extends IAreaSettings {
  native let exposureAdaptationSpeedUp: CurveDataFloat;
  native let exposureAdaptationSpeedDown: CurveDataFloat;
  native let exposurePercentageThresholdLow: CurveDataFloat;
  native let exposurePercentageThresholdHigh: CurveDataFloat;
  native let exposureCompensation: CurveDataFloat;
  native let exposureSkyImpact: CurveDataFloat;
  native let exposureMin: CurveDataFloat;
  native let exposureMax: CurveDataFloat;
  native let exposureCenterImportance: CurveDataFloat;
  native let cameraVelocityFaloff: Float;
}

public native class ExposureCompensationAreaSettings extends IAreaSettings {
  native let exposureCompensation: Float;
}

public abstract native class ExpressionTreeCAINodeDefinition extends ExpressionTreeCNodeDefinition {}

public native class ExpressionTreeCConstBoolNodeDefinition extends ExpressionTreeCGeneralNodeDefinition {
  native let value: Bool;
}

public native class ExpressionTreeCConstFloatNodeDefinition extends ExpressionTreeCGeneralNodeDefinition {
  native let value: Float;
}

public native class ExpressionTreeCGeneralAndNodeDefinition extends ExpressionTreeCGeneralCompositeNodeDefinition {}

public native class ExpressionTreeCGeneralCompositeNodeDefinition extends ExpressionTreeCGeneralNodeDefinition {
  native let children: array<ref<LibTreeINodeDefinition>>;
}

public native class ExpressionTreeCGeneralIfNodeDefinition extends ExpressionTreeCGeneralNodeDefinition {
  native let expressions: array<ref<LibTreeINodeDefinition>>;
  native let trueBranch: ref<LibTreeINodeDefinition>;
  native let falseBranch: ref<LibTreeINodeDefinition>;
}

public abstract native class ExpressionTreeCGeneralNodeDefinition extends ExpressionTreeCNodeDefinition {}

public native class ExpressionTreeCGeneralOrNodeDefinition extends ExpressionTreeCGeneralCompositeNodeDefinition {}

public abstract native class ExpressionTreeCNodeDefinition extends LibTreeINodeDefinition {}

public native class ExpressionTreeCParametrizationNodeDefinition extends ExpressionTreeCNodeDefinition {}

public native class ExpressionTreeCParametrizationNodeReadIntDefinition extends ExpressionTreeCParametrizationNodeDefinition {}

public native struct ExpressionTreeExecutionListenerRef {}

public native class ExternalMovementCameraDataEvent extends Event {}

public native class FearInPlaceEvent extends AIEvent {}

public native struct FeatureFlagsMask {
  native let flags: Uint64;
}

public native class FilmGrainAreaSettings extends IAreaSettings {
  native let strength: CurveDataVector4;
  native let luminanceBias: CurveDataFloat;
  native let grainSize: Vector3;
  native let applyAfterUpsampling: Bool;
}

public native struct FixedCapsule {
  native let PointRadius: Vector4;
  native let Height: Float;
}

public native struct FixedPoint {
  native let Bits: Int32;
}

public native struct FoliageShadowConfig {
  native let foliageShadowCascadeGradient: Float;
  native let foliageShadowCascadeFilterScale: Float;
  native let foliageShadowCascadeGradientDistanceRange: Float;
}

public native class FollowerSquad extends SquadBase {}

public native class FollowerSquadMember extends AISquadNPCMember {}

public native class FootstepComponent extends IComponent {
  native let tweakDBID: TweakDBID;
  native let leftFootSlot: CName;
  native let rightFootSlot: CName;
}

public native class FootstepSystem extends gameIFootstepSystem {}

public native class ForceAttributeValueEvent extends Event {}

public native class ForceStickerTransformEvent extends Event {}

public native class FreeCameraComponent extends CameraComponent {}

public importonly native class FriendlyFireSystem extends IFriendlyFireSystem {}

public importonly native struct FTResult {
  native let code: FunctionalTestsResultCode;
  native let msg: String;
  public final static native func IsValid()
  public final static native func Make()
  public final static native func MakeValid()
  public final static native func SetResult()
}

public native struct FunctionalTestQueryOverlapResult {
  native let entityID: EntityID;
  native let position: Vector3;
}

public native class FunctionalTestsDataMemoryPoolRuntimeData extends ISerializable {
  native let poolName: String;
  native let bytesAllocated: Int64;
  native let allocationCount: Int64;
}

public native class FunctionalTestsDataMemoryPoolStaticData extends ISerializable {
  native let poolName: String;
  native let budget: Int64;
  native let childrenBudget: Int64;
  native let children: array<String>;
  native let parent: String;
}

public native class FunctionalTestsDataMemoryStatsData extends ISerializable {
  native let totalPhysicalMemory: Uint64;
  native let availablePhysicalMemory: Uint64;
  native let runtimeTotalBytesAllocated: Uint64;
  native let cpuBytesAllocated: Uint64;
  native let gpuBytesAllocated: Uint64;
  native let totalAllocationCount: Uint32;
  native let cpuAllocationCount: Uint32;
  native let gpuAllocationCount: Uint32;
  native let engineTick: Uint64;
  native let lastTimeDelta: Float;
  native let engineTime: Double;
  native let rawLocalTime: Uint64;
  native let playerPosition: String;
  native let playerOrientation: String;
  native let poolsRuntimeInfo: array<FunctionalTestsDataMemoryPoolRuntimeData>;
  native let poolsCurrentInfo: array<FunctionalTestsDataMemoryPoolStaticData>;
}

public native class FunctionalTestsDataRenderingStatsData extends ISerializable {
  native let engineTick: Uint64;
  native let rawLocalTime: Uint64;
  native let meshChunkCount: Uint32;
  native let cameraTriangleCount: Uint32;
  native let shadowTriangleCount: Uint32;
  native let playerPosition: String;
  native let playerOrientation: String;
}

public native class FunctionalTestsDataTimeStatsData extends ISerializable {
  native let engineTick: Uint64;
  native let lastFps: Float;
  native let minFps: Float;
  native let lastTimeDelta: Float;
  native let engineTime: Double;
  native let cpuTime: Float;
  native let gpuTime: Float;
  native let rawLocalTime: Uint64;
  native let playerPosition: String;
  native let playerOrientation: String;
}

public native class FunctionalTestsGameSystem extends FunctionalTestsGameSystemInterface {
  public final static native func GetLocalizationStringByKey()
  public final native func ActivateSpawner()
  public final native func CheckCurrentAnimation()
  public final native func CheckCurrentAnimations()
  public final native func CheckSessionLoaded()
  public final native func ClearQuestArrays()
  public final native func ClearSingleQuest()
  public final native func DeactivateSpawner()
  public final native func DespawnEntityByID()
  public final native func DisableAutoMemoryDump()
  public final native func DumpMemoryReport()
  public final native func ExecuteDebugCommand()
  public final native func FakeInputAxisAction()
  public final native func FakeInputClickAction()
  public final native func FakeInputHoldAction()
  public final native func FakeInputMultitapAction()
  public final native func FakeInputPressAction()
  public final native func FakeInputReleaseAction()
  public final native func FakeInputReleaseAxisAction()
  public final native func FakePressButton()
  public final native func FakeReleaseButton()
  public final native func FakeSetAxis()
  public final native func GetAnyEntityFromSpawner()
  public final native func GetAxisDeadzoneInner()
  public final native func GetAxisDeadzoneOuter()
  public final native func GetBasicCrowdInfo()
  public final native func GetBoneWorldTransform()
  public final native func GetConfigVar()
  public final native func GetCrowdStubsEntitiesIDs()
  public final native func GetCurrentTargetPosition()
  public final native func GetDebugCameraWorldTransform()
  public final native func GetEntitiesFromSpawner()
  public final native func GetEntityByTag()
  public final native func GetEntityComponent()
  public final native func GetEntityIDsFromSpawner()
  public final native func GetLastSaveName()
  public final native func GetLastSpawnedEntityID()
  public final native func GetNodeEntityByGlobalName()
  public final native func GetPeerID()
  public final native func GetPlayerControlledObject()
  public final native func GetPlayerOrientation()
  public final native func GetPlayerPosition()
  public final native func GetSceneEntity()
  public final native func GetSceneEntityID()
  public final native func GetStaticMarkerWorldMatrix()
  public final native func IsQuestBlockFinished()
  public final native func IsQuestBlockStarted()
  public final native func IsSpawnerActive()
  public final native func IsStreaming()
  public final native func IsStreamingTestFinished()
  public final native func LookAtPosition()
  public final native func NavigateFlatTowards()
  public final native func NotifyReachedCurrentDestination()
  public final native func ReleaseAllInput()
  public final native func RequestAutoSave()
  public final native func SetConfigVar()
  public final native func SetCurrentTargetPosition()
  public final native func SpawnEntity()
  public final native func TakeOverInput()
  public final native func TeleportPlayer()
}

public abstract native class FunctionalTestsGameSystemInterface extends IGameSystem {}

public native struct FunctionalTestsInputManager {}

public abstract native class FunctionalTestsIRuntimeSystem extends worldIRuntimeSystem {}

public native class FunctionalTestsRuntimeSystem extends FunctionalTestsIRuntimeSystem {}

public native class FunctionalTestsState_FunctionalTests extends gsmState {}

public native class FunctionalTestsState_InternalFunctionalTests extends gsmState {}

public native struct fxCompositionShaderParams {
  native let glitchParam: Float;
  native let glitchParam1: Float;
  native let health: Float;
  native let visionActiveTime: Float;
  native let uiFactor: Float;
  native let uiPassthroughFactor: Float;
  native let mainRenderFactor: Float;
  native let blurredRenderFactor: Float;
  native let backgroundTextureFactor: Float;
  native let backgroundBlurRadius: Float;
  native let sphericalDistPower: Vector2;
  native let shadowDistance: Vector2;
  native let shadowIntensity: Float;
  native let shadowRadius: Float;
  native let glowIntensity: Float;
  native let glowTresholdStart: Float;
  native let glowTresholdEnd: Float;
  native let glowBlurRadius: Float;
  native let vignetteStart: Float;
  native let vignetteEnd: Float;
  native let vignetteIntensity: Float;
  native let blurredRenderSaturation: Float;
  native let uiSaturation: Float;
  native let chromaticAberrationStrength: Float;
  native let uiLayer2Scale: Vector2;
  native let uiLayer3Scale: Vector2;
  native let uiLayer4Scale: Vector2;
  native let uiLayer2Weight: Float;
  native let uiLayer3Weight: Float;
  native let uiLayer4Weight: Float;
}

public native struct gameActionReplicatedState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
}

public native struct gameActionsReplicationBuffer {}

enum gameAggregationType {
  AND = 0,
  OR = 1,
}

public native struct gameAIDirectorSpawner {}

public native class gameAIDirectorSystem extends gameIAIDirectorSystem {}

public native class gameAIDirectorTensionAnalyzeComponent extends IComponent {}

public native struct gameAIDirectorTensionAnalyzer {}

enum gameAIDirectorTensionEventType {
  Time = 0,
  Progress = 1,
  DealingDamage = 2,
  TakingDamage = 3,
  Kill = 4,
}

public native struct gameaimAssistAimAssist {}

public native struct gameaimAssistAimAssistRemotePlayer {}

enum gameAlwaysSpawnedState {
  default__false_ = 0,
  true = 1,
  false = 2,
}

public native struct gameAnimationExtractedData {
  native let animationName: CName;
  native let animsetsExtractedTransforms: array<gameAnimationTransforms>;
  native let smartObjectPointType: gameSmartObjectPointType;
}

public native struct gameAnimationOverrideDefinition {
  native let animset: ResourceAsyncRef; // raRef<animAnimSet>
  native let variables: array<CName>;
}

public native class gameAnimationPersistentDataSystem extends IGameSystem {}

public native struct gameAnimationTransforms {
  native let extractedMotion: array<Transform>;
  native let gatePosition: Transform;
  native let boneOffset: Transform;
  native let animsetHash: Uint64;
}

public native class gameAnimFeature_TPPRepresentation extends AnimFeature {
  native let IsActive: Bool;
}

public native struct gameAnimParamSlotsOption {
  native let slotID: TweakDBID;
  native let paramName: CName;
  native let function: entAnimParamSlotFunction;
}

public native struct gameAnimsetOverrideData {
  native let animsetHash: Uint64;
  native let variables: array<CName>;
}

public native class gameAppearanceNameVisualTagsPreset_AppearanceTags extends ISerializable {
  native let appearanceName: CName;
  native let visualTags: redTagList;
}

public native class gameAppearanceNameVisualTagsPreset_Entity extends ISerializable {
  native let entityPathHash: Uint64;
  native let debugEntityPath: CName;
  native let entityRigPathHash: Uint64;
  native let debugEntityRigPath: CName;
  native let commonVisualTags: redTagList;
  native let appearancesToTags: array<gameAppearanceNameVisualTagsPreset_AppearanceTags>;
}

public native class gameAppearanceNameVisualTagsPreset extends ISerializable {
  native let presets: array<gameAppearanceNameVisualTagsPreset_Entity>;
}

enum gameAppearanceSource {
  EntityResource = 0,
  PopulationSpawner = 1,
  CommunityEntry = 2,
  CommunityAppearancePicker = 3,
  TweakDBRecord = 4,
  VisualTag = 5,
  Invalid = 7,
}

public native struct gameAreaData {
  native let position: Vector4;
  native let size: Float;
  native let type: gameEAreaType;
  native let shape: gameEAreaShape;
  native let name: CName;
  native let priority: Uint32;
  native let lootID: TweakDBID;
}

public native class gameAreaManager extends gameIAreaManager {}

public native struct gameAreaProvider {}

public native class gameAreaResource extends CResource {
  native let cookedData: array<gameCookedAreaData>;
}

public native class gameAreaVolume extends GameObject {
  native let areaData: gameAreaData;
}

public native class gameAttachmentSlotEventsItemEquippedInSlot extends AttachmentSlotEvent {}

public native class gameAttachmentSlotEventsItemUnequippedFromSlot extends AttachmentSlotEvent {}

public native struct gameAttachmentSlotReplicatedState {
  native let slotID: TweakDBID;
  native let activeItemID: ItemID;
  native let hasItemObject: Bool;
}

public native class gameAttachmentSlots extends IComponent {
  native let animParams: array<gameAnimParamSlotsOption>;
}

public native class gameAttachmentSlotsFunctorListener extends AttachmentSlotsListener {}

public native struct gameAttachmentSlotsListenerData {}

public native class gameAttitudeAgentPS extends GameComponentPS {
  native persistent let currentAttitudeGroup: CName;
  native persistent let currentAttitudeGroupUnsavable: CName;
}

public native class gameaudioBreathingSubSystem extends gameaudioISoundComponentSubSystem {
  native let metadataName: CName;
}

public native class gameAudioClueObject extends GameObject {}

public native class gameaudioeventsDialogLineEnd extends Event {}

public native class gameaudioeventsDive extends Event {}

public native class gameaudioeventsEmerge extends Event {
  native let oxygen: Float;
}

public abstract native class gameaudioeventsEmitterEvent extends Event {
  native let emitterName: CName;
}

public native class gameaudioeventsHitEvent extends Event {
  native let attackType: gamedataAttackType;
  native let hitPosition: Vector4;
  native let physicsMaterial: CName;
  native let damage: Float;
  native let isTargetPuppet: Bool;
  native let targetPuppetMeleeMaterial: CName;
  native let isTargetPuppetHead: Bool;
}

public native class gameaudioeventsNotifyBreathingSubSystemStateChangeRequested extends Event {}

public native class gameaudioeventsNotifyFootstepSubSystemStateChangeRequested extends Event {}

public native class gameaudioeventsPlaySoundOnEmitter extends gameaudioeventsEmitterEvent {
  native let eventName: CName;
}

public native class gameaudioeventsSetParameterOnEmitter extends gameaudioeventsEmitterEvent {
  native let paramName: CName;
  native let paramValue: Float;
}

public native class gameaudioeventsStopDialogLine extends Event {
  native let stringId: CRUID;
  native let fadeOut: Float;
}

public native class gameaudioeventsStopSoundOnEmitter extends gameaudioeventsEmitterEvent {
  native let soundName: CName;
}

public native class gameaudioeventsStopTaggedSounds extends Event {
  native let audioTag: CName;
}

public native class gameaudioeventsSurface extends Event {}

public native class gameaudioeventsVehicleCollision extends Event {}

public native class gameaudioFlybySubSystem extends gameaudioISoundComponentSubSystem {}

public abstract native class gameaudioIAudioSubSystem extends IScriptable {}

public abstract native class gameaudioIScanningSystem extends IGameSystem {}

public abstract native class gameaudioISoundComponentSubSystem extends gameaudioIAudioSubSystem {}

public abstract native class gameaudioIWeaponAudioComponentSubSystem extends gameaudioIAudioSubSystem {}

public native class gameaudioMeleeAudioSubSystem extends gameaudioIWeaponAudioComponentSubSystem {}

public native class gameaudioMusicSyncComponent extends IComponent {
  native let notifyBeats: Bool;
  native let notifyBars: Bool;
  native let notifyGrid: Bool;
  native let notifyBarProgression: Bool;
  native let notifyBeatProgression: Bool;
  native let syncTrack: CName;
}

public native class gameaudioRagdollSubSystem extends gameaudioISoundComponentSubSystem {
  native let defaultMaterialMetadata: CName;
  native let customDismembermentSettings: CName;
  native let lookupMatrixName: CName;
}

public native class gameaudioScanningSystem extends gameaudioIScanningSystem {}

public native class gameaudioSoundComponentSubSystemWrapper extends ISerializable {
  native let type: ref<gameaudioISoundComponentSubSystem>;
}

public native struct gameAudioSyncs {
  native let switchEvents: array<audioAudSwitch>;
  native let playEvents: array<audioAudEventStruct>;
  native let stopEvents: array<audioAudEventStruct>;
  native let parameterEvents: array<audioAudParameter>;
}

public native class gameAugmentedRealitySign extends GameObject {}

public native struct gameAvailableAnimset {
  native let hash: Uint64;
  native let resourcePath: String;
}

public abstract native struct gameBaseGameSession {}

public abstract native class gameBaseTimer extends IScriptable {}

public native struct gamebbDynArrayBlackboardStorage {}

public native struct gamebbID {
  native let g: CName;
}

public native class gameBinkMeshTargetAttachment extends entIAttachment {}

public native class gameBinkMeshTargetBinding extends entISourceBinding {}

enum gameBinkVideoAction {
  Undefined = 0,
  Start = 1,
  Stop = 2,
}

public native class gameBinkVideoData extends ISerializable {
  native let data: array<gameBinkVideoRecord>;
}

public native class gameBinkVideoEvent extends Event {
  native let videoPath: String;
  native let action: gameBinkVideoAction;
}

public native class gameBinkVideoRecord extends ISerializable {
  native let resourceHash: Uint64;
  native let binkDuration: Float;
}

public native struct gameBlackboardPropertyBindingDefinition {
  native let serializableID: BlackboardSerializableID;
  native let propertyPath: array<CName>;
  native let propertyType: CName;
}

public native class gameBlueprintStackableItemData extends gameItemData {}

public native class gameBodyTriggerDestructionComponent extends gameITriggerDestructionComponent {
  native let colliderComponentName: CName;
  native let filterData: ref<physicsFilterData>;
  native let impulseForce: Float;
  native let impulseRadius: Float;
}

public native struct gameBodyTypeAnimationDefinition {
  native let rig: ResourceAsyncRef; // raRef<animRig>
  native let animsets: array<ResourceAsyncRef>;
  native let overrides: array<gameAnimationOverrideDefinition>;
}

public native struct gameBodyTypeData {
  native let rigHash: Uint64;
  native let animsetHashes: array<Uint64>;
  native let overrides: array<gameAnimsetOverrideData>;
}

enum gameBoolSignalAction {
  None = 0,
  TurnOn = 1,
  TurnOff = 2,
}

public native class gameBreachSystem extends gameIBreachSystem {}

public native struct gameCActionAIProxy {}

public native class gameCActionsFactory extends gameIActionsFactory {}

enum gameCameraCurve {
  CentricPitchOfSpeed = 0,
  CentricVerticalOffsetOfSpeed = 1,
  BoomLengthOfSpeed = 2,
  BoomLengthOfAcc = 3,
  BoomPitchOfSpeed = 4,
  BoomPitchOfGlobalVehiclePitch = 5,
  BoomYawOfTurnCoeff = 6,
  BoomYawRotateRateOfSpeed = 7,
  FOVOfSpeed = 8,
  PivotOffsetXOfTurnCoeff = 9,
  PivotOffsetZOfTurnCoeff = 10,
  COUNT = 11,
}

public native class gameCameraCurveSet extends CurveSet {}

public native class gameCameraCurvesLibrary extends Entity {
  native let cameraCurves: array<ResourceRef>;
}

public abstract native class gamecameraISettingManager extends IGameSystem {}

public native struct gameCameraLocation {
  native let position: Vector3;
  native let rotation: EulerAngles;
}

public native class gamecameraSettingManager extends gamecameraISettingManager {}

public native struct gameCategorySelectionProbability {
  native let probabilities: array<gameSpotSequenceCategory>;
}

public native class gameCDebugSystem extends gameIDebugSystem {}

public native struct gamecheatsystemObjCheats {
  native let object: wref<GameObject>;
  native let flags: Int32;
}

public native struct gameChildEffectsMovingInCone_State {}

public importonly native class gameClientEntitySpawnSystem extends IClientEntitySpawnSystem {}

public native class gameCollidableEntityId extends ISerializable {}

public native class gameCollisionQueriesSystem extends gameICollisionQueriesSystem {}

public native class gameCombatQueriesSystem extends gameICombatQueriesSystem {}

public native struct gameCommunityID {
  native persistent let entityId: EntityID;
}

public native struct gameCommunitySpawnSetNameToID {
  native let entries: array<gameCommunitySpawnSetNameToIDEntry>;
}

public native struct gameCommunitySpawnSetNameToIDEntry {
  native let communityId: gameCommunityID;
  native let nameReference: CName;
}

public native struct gameCommunityTrafficConnectionsEntry {}

enum gameComparisonType {
  EQUAL = 0,
  NOT_EQUAL = 1,
  LESS = 2,
  GREATER = 3,
  LESS_OR_EQUAL = 4,
  GREATER_OR_EQUAL = 5,
}

public native class gameCompiledCoverData extends gameCompiledSmartObjectData {}

public native class gameCompiledNodes extends ISerializable {
  native let compiledSmartObjects: array<gameCompiledSmartObjectNode>;
}

public native class gameCompiledShootingSpotData extends gameCompiledCoverData {}

public native class gameCompiledSmartObjectData extends ISerializable {}

public native struct gameCompiledSmartObjectNode {
  native let compiledData: ref<gameCompiledSmartObjectData>;
  native let worldTransform: WorldTransform;
}

public native class gameComponentsStateSaveComponent extends IComponent {}

public native class gameComponentsStateSystem extends gameIComponentsStateSystem {}

public native struct gameCompressedSmartObjectPointProperties {
  native let propertyId: Uint16;
}

public native struct gameCompressedSmartObjectPointTransform {
  native let transformId: Uint16;
}

public native class gameContainerInventoryListener extends InventoryListener {}

public native class gameContainerObjectAnimated extends gameContainerObjectBase {
  native let animFeatureName: CName;
}

public abstract native class gameController extends GameObject {}

public native struct gameCookedAreaData {
  native let entityID: EntityID;
  native let position: Vector3;
  native let radius: Float;
  native let volume: ref<gamemappinsIMappinVolume>;
}

public native struct gameCookedDeviceData {
  native let className: CName;
  native let parents: array<Uint64>;
  native let children: array<Uint64>;
  native let nodePosition: Vector3;
}

public native struct gameCookedGpsMappinData {
  native let journalPathHash: Uint32;
  native let positions: array<Vector3>;
}

public native class gameCookedLootData extends ISerializable {
  native let lootTables: array<TweakDBID>;
  native let contentAssignment: TweakDBID;
}

public native struct gameCookedMappinData {
  native let journalPathHash: Uint32;
  native let position: Vector3;
  native let volume: ref<gamemappinsIMappinVolume>;
}

public native struct gameCookedMultiMappinData {
  native let journalPathHash: Uint32;
  native let positions: array<Vector3>;
}

public native struct gameCookedPointOfInterestMappinData {
  native let journalPathHash: Uint32;
  native let entityID: EntityID;
  native let position: Vector3;
}

public native class gameCooldownFinishedEvent extends gameCooldownSystemEvent {}

public native class gameCooldownRemovedEvent extends gameCooldownSystemEvent {}

public native class gameCooldownSystem extends ICooldownSystem {}

public native class gameCooldownSystemEvent extends Event {}

public native class gameCoverDefinition extends gameSmartObjectWorkspotDefinition {
  native let overridenCoveringFOVDegrees: Float;
  native let overridenCoveringVerticalFOVDegrees: Float;
  native let fovExposureDegrees: Float;
  native let overridenHeight: gameCoverHeight;
  native let overrideGeneratedCoverAngles: Bool;
}

public native struct gameCoveringArc {
  native let leftAngle: Float;
  native let rightAngle: Float;
  native let verticalAngle: Float;
}

public native class gameCoverObject extends GameObject {
  native let coverType: animCoverState;
  native let slotRadius: Float;
  native let hpMax: Float;
  native let isDestructible: Bool;
  native let fovDegrees: Float;
  native let fovExposureDegrees: Float;
}

public native class gameCpoArmouryItem extends GameObject {
  native let armouryItemID: TweakDBID;
}

public native struct gameCrowdCreationData {
  native let timePeriods: [gameCrowdPhaseTimePeriod; 4];
}

enum gameCrowdCreationDataMergeMode {
  Average = 0,
  Override = 1,
}

public native class gameCrowdCreationDataRegistry extends ISerializable {
  native let creationData: array<gameCrowdCreationData>;
}

public native class gameCrowdEntityReuseEvent extends Event {}

enum gameCrowdEntryType {
  Pedestrian = 0,
  Vehicle = 1,
  AV = 2,
}

public native struct gameCrowdTemplateCharacterData {
  native let characterRecordId: TweakDBID;
  native let weight: Float;
}

public native struct gameCrowdTemplateEntry {
  native let entryName: CName;
  native let markings: array<CName>;
  native let phases: array<gameCrowdTemplateEntryPhase>;
  native let type: gameCrowdEntryType;
}

public native struct gameCrowdTemplateEntryPhase {
  native let phaseName: CName;
  native let timePeriods: array<gameCrowdPhaseTimePeriod>;
  native let density: Float;
  native let charactersData: array<gameCrowdTemplateCharacterData>;
  native let legacy: Bool;
  native let legacyDensityInTimePeriods: Bool;
  native let legacyCharactersData: Bool;
}

public native class gameCursorInterpolationOverrides extends inkUserData {
  native let minSpeed: Vector2;
  native let enterTime: Float;
}

public native class gameCyberspaceBoundaryNode extends worldTriggerAreaNode {
  native let marker1Ref: NodeRef;
  native let marker2Ref: NodeRef;
}

public native class gameCyberspaceBoundaryNodeInstance extends worldTriggerAreaNodeInstance {}

public native struct gameCyberspacePixelsortEffectParams {
  native let fullscreen: Bool;
  native let vfx: Bool;
  native let initialDatamosh: Float;
  native let targetDatamosh: Float;
  native let initialIntensity: Float;
  native let targetIntensity: Float;
  native let timeBlend: Float;
}

public native class gameDamageSystemSharedState extends gameIGameSystemReplicatedState {
  native let hitHistory: array<ref<ServerHitData>>;
  native let killHistory: array<ref<ServerKillData>>;
}

public native class gamedataComplexValueNode extends gamedataValueDataNode {
  native let data: array<String>;
}

public abstract native class gamedataDataNode extends ISerializable {
  native let nodeType: gamedataDataNodeType;
  native let fileName: String;
  native let parent: wref<gamedataDataNode>;
}

enum gamedataDataNodeType {
  File = 0,
  Group = 1,
  Variable = 2,
  Value = 3,
  SimpleValue = 4,
  ComplexValue = 5,
}

public native class gamedataFileNode extends gamedataDataNode {
  native let packageName: String;
  native let package: wref<gamedataPackageNode>;
  native let variables: array<ref<gamedataVariableNode>>;
  native let groups: array<ref<gamedataGroupNode>>;
}

public native class gamedataGroupNode extends gamedataDataNode {
  native let name: String;
  native let base: String;
  native let schema: String;
  native let isInline: Bool;
  native let baseGroup: wref<gamedataGroupNode>;
  native let schemaGroup: wref<gamedataGroupNode>;
  native let package: wref<gamedataPackageNode>;
  native let fileNode: ref<gamedataFileNode>;
  native let inlineGroupId: Uint32;
  native let inheritanceState: gamedataGroupNodeInheritanceState;
  native let serializedVariables: array<gamedataGroupNodeGroupVariable>;
  native let tags: array<CName>;
}

public native struct gamedataGroupNodeGroupVariable {
  native let node: ref<gamedataVariableNode>;
  native let deriveInfo: gamedataGroupNodeGroupVariableDeriveInfo;
  native let flattened: Bool;
  native let flatId: TweakDBID;
}

enum gamedataGroupNodeGroupVariableDeriveInfo {
  FullyDerived = 0,
  TypeDerived = 1,
  ValueChanged = 2,
  NotDerived = 3,
}

enum gamedataGroupNodeInheritanceState {
  Unresolved = 0,
  Resolving = 1,
  Resolved = 2,
}

public native class gamedataPackageNode extends ISerializable {
  native let name: String;
  native let serializedVariables: array<ref<gamedataVariableNode>>;
  native let serializedGroups: array<ref<gamedataGroupNode>>;
  native let files: array<ref<gamedataFileNode>>;
}

public native class gamedataSimpleValueNode extends gamedataValueDataNode {
  native let type: gamedataSimpleValueNodeValueType;
  native let data: String;
}

enum gamedataSimpleValueNodeValueType {
  String = 0,
  Number = 1,
  Bool = 2,
  Ident = 3,
}

enum gamedataStatType_1300DEPRECATED {
  Acceleration = 0,
  Accuracy = 1,
  Adrenaline = 2,
  AimFOV = 3,
  AimInTime = 4,
  AimOffset = 5,
  AimOutTime = 6,
  AllowMovementInput = 7,
  AllowRotation = 8,
  Armor = 9,
  Assault = 10,
  AssaultMastery = 11,
  AssaultTrait01Stat = 12,
  Athletics = 13,
  AthleticsMastery = 14,
  AthleticsTrait01Stat = 15,
  AttackPenetration = 16,
  AttackSpeed = 17,
  AttackSpeedPercent = 18,
  AttacksNumber = 19,
  AttacksPerSecond = 20,
  AttacksPerSecondBase = 21,
  AudioLocomotionStimRangeMultiplier = 22,
  AudioStimRangeMultiplier = 23,
  AutoReveal = 24,
  AutocraftDuration = 25,
  AutomaticReplenishment = 26,
  AutomaticUploadPerk = 27,
  BaseChargeTime = 28,
  BaseDamage = 29,
  BaseDamageMax = 30,
  BaseDamageMin = 31,
  BerserkArmorBonus = 32,
  BerserkCooldownBase = 33,
  BerserkCooldownReduction = 34,
  BerserkDurationBase = 35,
  BerserkHealthRegenBonus = 36,
  BerserkMeleeDamageBonus = 37,
  BerserkRecoilReduction = 38,
  BerserkResistancesBonus = 39,
  BerserkShockwaveDamage = 40,
  BerserkShockwaveRangeBonus = 41,
  BerserkSwayReduction = 42,
  BleedingApplicationRate = 43,
  BleedingImmunity = 44,
  BlindImmunity = 45,
  BlindResistance = 46,
  BlockFactor = 47,
  BlockLocomotionWhenLeaningOutOfCover = 48,
  BlockReduction = 49,
  BonusChargeDamage = 50,
  BonusDPS = 51,
  BonusDamageAgainstElites = 52,
  BonusDamageAgainstMechanicals = 53,
  BonusDamageAgainstRares = 54,
  BonusQuickHackDamage = 55,
  BonusRicochetDamage = 56,
  Brake = 57,
  BrakeDot = 58,
  Brawling = 59,
  BrawlingMastery = 60,
  BrawlingTrait01Stat = 61,
  BufferSize = 62,
  BulletMagnetismDefaultAngle = 63,
  BulletMagnetismHighVelocityAngle = 64,
  BulletPseudoPierceHitVFxChance = 65,
  BulletSurroundingHitVFxChance = 66,
  BurningApplicationRate = 67,
  BurningImmunity = 68,
  BurningRegenStamina = 69,
  CPUPower = 70,
  CallReinforcement = 71,
  CameraShutdownExtension = 72,
  CanAerialTakedown = 73,
  CanAimWhileDodging = 74,
  CanAskToFollowOrder = 75,
  CanAskToHolsterWeapon = 76,
  CanAutomaticallyDisassembleJunk = 77,
  CanAutomaticallyRestoreKnives = 78,
  CanBleedingCriticallyHit = 79,
  CanBleedingSlowTarget = 80,
  CanBlindQuickHack = 81,
  CanBlock = 82,
  CanBreatheUnderwater = 83,
  CanBuffCamoQuickHack = 84,
  CanBuffMechanicalsOnTakeControl = 85,
  CanBuffSturdinessQuickHack = 86,
  CanBurningCriticallyHit = 87,
  CanCallDrones = 88,
  CanCallReinforcements = 89,
  CanCatchUp = 90,
  CanCatchUpDistance = 91,
  CanCharge = 92,
  CanChargedShoot = 93,
  CanCloseCombat = 94,
  CanCommsCallInQuickHack = 95,
  CanCommsCallOutQuickHack = 96,
  CanCommsNoiseQuickHack = 97,
  CanControlFullyChargedWeapon = 98,
  CanCraftEpicItems = 99,
  CanCraftFromInventory = 100,
  CanCraftLegendaryItems = 101,
  CanCraftRareItems = 102,
  CanCraftTechAmmunition = 103,
  CanCrouch = 104,
  CanCyberwareMalfunctionQuickHack = 105,
  CanDash = 106,
  CanDataMineQuickHack = 107,
  CanDealFullDamageToArmored = 108,
  CanDeathQuickHack = 109,
  CanDisassemble = 110,
  CanDisassembleConsumables = 111,
  CanDisassembleGadgets = 112,
  CanDropWeapon = 113,
  CanElectrocuteNullifyStats = 114,
  CanElectrocuteRoot = 115,
  CanExitWSOnSoundStimuli = 116,
  CanExplodeQuickHack = 117,
  CanFastTravelWhileEncumbered = 118,
  CanFullyChargeWeapon = 119,
  CanGrab = 120,
  CanGrappleAndroids = 121,
  CanGrappleSilently = 122,
  CanGrenadeLaunch = 123,
  CanGrenadeQuickHack = 124,
  CanGrenadesCriticallyHit = 125,
  CanGrenadesDealExternalDamage = 126,
  CanGuardBreak = 127,
  CanHeartattackQuickHack = 128,
  CanIgnoreArmorDamageReduction = 129,
  CanIgnoreStamina = 130,
  CanInstallTechMods = 131,
  CanJamWeaponQuickHack = 132,
  CanJump = 133,
  CanLandSilently = 134,
  CanLegendaryCraftedWeaponsBeBoosted = 135,
  CanLocomotionMalfunctionQuickHack = 136,
  CanMadnessQuickHack = 137,
  CanMalfunctionQuickHack = 138,
  CanMeleeBerserk = 139,
  CanMeleeDash = 140,
  CanMeleeInfinitelyCombo = 141,
  CanMeleeLeap = 142,
  CanMeleeLeapTakedown = 143,
  CanOverchargeWeapon = 144,
  CanOverheatQuickHack = 145,
  CanOverloadQuickHack = 146,
  CanOverrideAttitudeQuickHack = 147,
  CanOverrideAuthorizationQuickHack = 148,
  CanParry = 149,
  CanPickUpBodyAfterTakedown = 150,
  CanPickUpWeapon = 151,
  CanPingQuickHack = 152,
  CanPlayerBoostConsumables = 153,
  CanPlayerBoostGrenades = 154,
  CanPoisonLowerArmor = 155,
  CanPoisonSlow = 156,
  CanPreciseShoot = 157,
  CanPushBack = 158,
  CanPushFromGrapple = 159,
  CanQuickHackCriticallyHit = 160,
  CanQuickMeleeStagger = 161,
  CanQuickhack = 162,
  CanQuickhackHealPuppet = 163,
  CanQuickhackTransferBetweenEnemies = 164,
  CanRegenInCombat = 165,
  CanRemoveModsFromClothing = 166,
  CanRemoveModsFromWeapons = 167,
  CanResurrectAllies = 168,
  CanRetrieveModsFromDisassemble = 169,
  CanRunSilently = 170,
  CanSandevistanSprintHarass = 171,
  CanScrapPartsFromMechanicals = 172,
  CanSeeGrenadeRadius = 173,
  CanSeeRicochetVisuals = 174,
  CanSeeThroughWalls = 175,
  CanShareThreatsWithPlayer = 176,
  CanShootWhileCarryingBody = 177,
  CanShootWhileDodging = 178,
  CanShootWhileGrappling = 179,
  CanShootWhileMoving = 180,
  CanShootWhileVaulting = 181,
  CanSilentKill = 182,
  CanSmartShoot = 183,
  CanSprint = 184,
  CanSprintHarass = 185,
  CanSprintWhileCarryingBody = 186,
  CanSuicideQuickHack = 187,
  CanSwitchWeapon = 188,
  CanTakeControlQuickHack = 189,
  CanTakedownLethally = 190,
  CanTakedownSilently = 191,
  CanTaunt = 192,
  CanThrowWeapon = 193,
  CanUpgradeFromInventory = 194,
  CanUpgradeToLegendaryQuality = 195,
  CanUseAntiStun = 196,
  CanUseBiohazardGrenades = 197,
  CanUseCloseRing = 198,
  CanUseCombatStims = 199,
  CanUseConsumables = 200,
  CanUseCoolingSystem = 201,
  CanUseCovers = 202,
  CanUseCuttingGrenades = 203,
  CanUseEMPGrenades = 204,
  CanUseExtremeRing = 205,
  CanUseFarRing = 206,
  CanUseFlashbangGrenades = 207,
  CanUseFragGrenades = 208,
  CanUseGrenades = 209,
  CanUseHolographicCamo = 210,
  CanUseIncendiaryGrenades = 211,
  CanUseLeftHand = 212,
  CanUseLegs = 213,
  CanUseMantisBlades = 214,
  CanUseMediumRing = 215,
  CanUseMeleeRing = 216,
  CanUseOpticalCamo = 217,
  CanUsePainInhibitors = 218,
  CanUsePersonalSoundSilencer = 219,
  CanUseProjectileLauncher = 220,
  CanUseReconGrenades = 221,
  CanUseRetractableShield = 222,
  CanUseRightHand = 223,
  CanUseShootingSpots = 224,
  CanUseStaticCamo = 225,
  CanUseStrongArms = 226,
  CanUseTakedowns = 227,
  CanUseTerrainCamo = 228,
  CanUseZoom = 229,
  CanWalkSilently = 230,
  CanWallStick = 231,
  CanWeaponBlock = 232,
  CanWeaponBlockAttack = 233,
  CanWeaponComboAttack = 234,
  CanWeaponCriticallyHit = 235,
  CanWeaponCrouchAttack = 236,
  CanWeaponDash = 237,
  CanWeaponDeflect = 238,
  CanWeaponIgnoreArmor = 239,
  CanWeaponInfinitlyCombo = 240,
  CanWeaponJumpAttack = 241,
  CanWeaponLeap = 242,
  CanWeaponMalfunctionQuickHack = 243,
  CanWeaponReload = 244,
  CanWeaponReloadWhileInactive = 245,
  CanWeaponReloadWhileSliding = 246,
  CanWeaponReloadWhileSprinting = 247,
  CanWeaponReloadWhileVaulting = 248,
  CanWeaponSafeAttack = 249,
  CanWeaponShoot = 250,
  CanWeaponShootWhileSliding = 251,
  CanWeaponShootWhileSprinting = 252,
  CanWeaponShootWhileVaulting = 253,
  CanWeaponSnapToLimbs = 254,
  CanWeaponSprintAttack = 255,
  CanWeaponStrongAttack = 256,
  CanWeaponTriggerHeadshot = 257,
  CannotBeDetectedWhileSubmerged = 258,
  CannotBeHealed = 259,
  CannotSprintHarass = 260,
  CarryCapacity = 261,
  CausingPanicReducesUltimateHacksCost = 262,
  Charge = 263,
  ChargeDischargeTime = 264,
  ChargeFullMultiplier = 265,
  ChargeMaxTimeInChargedState = 266,
  ChargeMultiplier = 267,
  ChargeReadyPercentage = 268,
  ChargeShouldFireWhenReady = 269,
  ChargeTime = 270,
  ChemicalDamage = 271,
  ChemicalDamageMax = 272,
  ChemicalDamageMin = 273,
  ChemicalDamagePercent = 274,
  ChemicalResistance = 275,
  ClimbSpeedModifier = 276,
  ClipTimesCycle = 277,
  ClipTimesCycleBase = 278,
  ClipTimesCyclePlusReload = 279,
  ClipTimesCyclePlusReloadBase = 280,
  CloudComputingTraps = 281,
  ColdBlood = 282,
  ColdBloodBuffBonus = 283,
  ColdBloodMastery = 284,
  ColdBloodMaxDuration = 285,
  ColdBloodMaxStacks = 286,
  ColdBloodTrait01 = 287,
  CombatHacking = 288,
  CombatHackingMastery = 289,
  CommsNoiseJamOnQuickhack = 290,
  Cool = 291,
  Crafting = 292,
  CraftingBonusArmorValue = 293,
  CraftingBonusConsumableDuration = 294,
  CraftingBonusGrenadeDamage = 295,
  CraftingBonusWeaponDamage = 296,
  CraftingCostReduction = 297,
  CraftingItemLevelBoost = 298,
  CraftingMastery = 299,
  CraftingMaterialDropChance = 300,
  CraftingMaterialRandomGrantChance = 301,
  CraftingMaterialRetrieveChance = 302,
  CraftingTrait01 = 303,
  CritChance = 304,
  CritChanceTimeCritDamage = 305,
  CritDPSBonus = 306,
  CritDamage = 307,
  CyberwareCooldownReduction = 308,
  CycleTime = 309,
  CycleTimeAimBlockDuration = 310,
  CycleTimeAimBlockStart = 311,
  CycleTimeBase = 312,
  CycleTimeBonus = 313,
  CycleTimeShootingMult = 314,
  CycleTimeShootingMultPeriod = 315,
  CycleTime_Burst = 316,
  CycleTime_BurstMaxCharge = 317,
  CycleTime_BurstSecondary = 318,
  CycleTriggerModeTime = 319,
  DPS = 320,
  DamageFalloffDisabled = 321,
  DamageHackSpread = 322,
  DamagePerHit = 323,
  DamageReductionDamageOverTime = 324,
  DamageReductionExplosion = 325,
  DashAttackStaminaCostReduction = 326,
  DataLeakTraps = 327,
  DealsChemicalDamage = 328,
  DealsElectricDamage = 329,
  DealsPhysicalDamage = 330,
  DealsThermalDamage = 331,
  Deceleration = 332,
  DefeatedHeadDamageThreshold = 333,
  DefeatedLArmDamageThreshold = 334,
  DefeatedLLegDamageThreshold = 335,
  DefeatedRArmDamageThreshold = 336,
  DefeatedRLegDamageThreshold = 337,
  DefeatingEnemiesReduceHacksCost = 338,
  Demolition = 339,
  DemolitionMastery = 340,
  DemolitionTrait01Stat = 341,
  Detection = 342,
  DeviceMemoryCostReduction = 343,
  DisableCyberwareOnBurning = 344,
  DisassemblingIngredientsDoubleBonus = 345,
  DisassemblingMaterialQualityObtainChance = 346,
  DismHeadDamageThreshold = 347,
  DismLArmDamageThreshold = 348,
  DismLLegDamageThreshold = 349,
  DismRArmDamageThreshold = 350,
  DismRLegDamageThreshold = 351,
  DoNotCheckFriendlyFireMadnessPassive = 352,
  DummyResistanceStat = 353,
  Durability = 354,
  DurationBonusBleeding = 355,
  DurationBonusBurning = 356,
  DurationBonusElectrified = 357,
  DurationBonusPoisoned = 358,
  DurationBonusQuickhack = 359,
  DurationBonusStun = 360,
  EMPImmunity = 361,
  EffectiveDPS = 362,
  EffectiveDamagePerHit = 363,
  EffectiveDamagePerHitMax = 364,
  EffectiveDamagePerHitMin = 365,
  EffectiveDamagePerHitTimesAttacksPerSecond = 366,
  EffectiveRange = 367,
  ElectricDamage = 368,
  ElectricDamageMax = 369,
  ElectricDamageMin = 370,
  ElectricDamagePercent = 371,
  ElectricResistance = 372,
  ElectrocuteImmunity = 373,
  ElectrocutedApplicationRate = 374,
  ElementalDamagePerHit = 375,
  ElementalResistanceMultiplier = 376,
  EmptyReloadTime = 377,
  Engineering = 378,
  EngineeringMastery = 379,
  EngineeringTrait01 = 380,
  EquipActionDuration_Corpo = 381,
  EquipActionDuration_Gang = 382,
  EquipAnimationDuration_Corpo = 383,
  EquipAnimationDuration_Gang = 384,
  EquipDuration = 385,
  EquipDuration_First = 386,
  EquipItemTime_Corpo = 387,
  EquipItemTime_Gang = 388,
  Evasion = 389,
  ExplosionKillsRecudeUltimateHacksCost = 390,
  FFInputLock = 391,
  FallDamageReduction = 392,
  FearOnQuickHackKill = 393,
  FullAutoOnFullCharge = 394,
  Gunslinger = 395,
  GunslingerMastery = 396,
  GunslingerTrait01Stat = 397,
  HackedEnemiesGetDamagedByFriendlyFire = 398,
  HackedEnemyArmorReduction = 399,
  Hacking = 400,
  HackingMastery = 401,
  HackingPenetration = 402,
  HackingResistance = 403,
  HackingResistanceUltimate = 404,
  HasAdditionalSplinterSlot = 405,
  HasAheadTargeting = 406,
  HasAirHover = 407,
  HasAirThrusters = 408,
  HasAutoReloader = 409,
  HasAutomaticReplenishment = 410,
  HasAutomaticTagging = 411,
  HasBerserk = 412,
  HasBleedImmunity = 413,
  HasBlindImmunity = 414,
  HasBoostedCortex = 415,
  HasBurningBuffs = 416,
  HasCameraLinking = 417,
  HasChargeJump = 418,
  HasCritImmunity = 419,
  HasCyberdeck = 420,
  HasCybereye = 421,
  HasDodge = 422,
  HasDodgeAir = 423,
  HasDoubleJump = 424,
  HasElectricCoating = 425,
  HasElectroPlating = 426,
  HasExtendedHitReactionImmunity = 427,
  HasFireproofSkin = 428,
  HasGPS = 429,
  HasGlowingTattoos = 430,
  HasGraphiteTissue = 431,
  HasHackingInteractions = 432,
  HasHealingReapplication = 433,
  HasHealthMonitorBomb = 434,
  HasHostileHackImmunity = 435,
  HasICELevelBooster = 436,
  HasInfravision = 437,
  HasJuiceInjector = 438,
  HasKerenzikov = 439,
  HasKerenzikovSlide = 440,
  HasKers = 441,
  HasLinkToBountySystem = 442,
  HasLoweringPerception = 443,
  HasMadnessLvl4Passive = 444,
  HasMajorQuickhackResistance = 445,
  HasMechanicalControl = 446,
  HasMeleeImmunity = 447,
  HasMeleeTargeting = 448,
  HasMetabolicEnhancer = 449,
  HasPoisonHeal = 450,
  HasPoisonImmunity = 451,
  HasPowerGrip = 452,
  HasQuickhackResistance = 453,
  HasRemoteBotAccessPointBreach = 454,
  HasSandevistan = 455,
  HasSandevistanTier1 = 456,
  HasSandevistanTier2 = 457,
  HasSandevistanTier3 = 458,
  HasSecondHeart = 459,
  HasSelfHealingSkin = 460,
  HasSmartLink = 461,
  HasSpiderBotControl = 462,
  HasStunImmunity = 463,
  HasSubdermalArmor = 464,
  HasSuperheroFall = 465,
  HasThermovision = 466,
  HasTimedImmunity = 467,
  HasToxicCleanser = 468,
  HasWallRunSkill = 469,
  HeadshotDamageMultiplier = 470,
  HeadshotImmunity = 471,
  Health = 472,
  HealthInCombatRegenDelayOnChange = 473,
  HealthInCombatRegenEnabled = 474,
  HealthInCombatRegenEndThreshold = 475,
  HealthInCombatRegenRate = 476,
  HealthInCombatRegenRateAdd = 477,
  HealthInCombatRegenRateBase = 478,
  HealthInCombatRegenRateMult = 479,
  HealthInCombatRegenStartThreshold = 480,
  HealthInCombatStartDelay = 481,
  HealthMonitorCooldownDuration = 482,
  HealthOutOfCombatRegenDelayOnChange = 483,
  HealthOutOfCombatRegenEnabled = 484,
  HealthOutOfCombatRegenEndThreshold = 485,
  HealthOutOfCombatRegenRate = 486,
  HealthOutOfCombatRegenRateAdd = 487,
  HealthOutOfCombatRegenRateBase = 488,
  HealthOutOfCombatRegenRateMult = 489,
  HealthOutOfCombatRegenStartThreshold = 490,
  Hearing = 491,
  HeavyAttacksNumber = 492,
  HighlightAccessPoint = 493,
  HitDismembermentFactor = 494,
  HitReactionDamageHealthFactor = 495,
  HitReactionFactor = 496,
  HitTimerAfterDefeated = 497,
  HitTimerAfterImpact = 498,
  HitTimerAfterImpactMelee = 499,
  HitTimerAfterKnockdown = 500,
  HitTimerAfterPain = 501,
  HitTimerAfterStagger = 502,
  HitTimerAfterStaggerMelee = 503,
  HitWoundsFactor = 504,
  HoldDuration = 505,
  HoldEnterDuration = 506,
  HoldTimeoutDuration = 507,
  HolographicSkinCooldownDuration = 508,
  HolographicSkinDuration = 509,
  IconicItemUpgraded = 510,
  ImpactDamageThreshold = 511,
  ImpactDamageThresholdImpulse = 512,
  ImpactDamageThresholdInCover = 513,
  Intelligence = 514,
  IsAggressive = 515,
  IsBalanced = 516,
  IsBlocking = 517,
  IsCautious = 518,
  IsDefensive = 519,
  IsDeflecting = 520,
  IsDodgeStaminaFree = 521,
  IsDodging = 522,
  IsFastMeleeArchetype = 523,
  IsFastRangedArchetype = 524,
  IsGenericMeleeArchetype = 525,
  IsGenericRangedArchetype = 526,
  IsHeavyRangedArchetype = 527,
  IsInvulnerable = 528,
  IsItemBroken = 529,
  IsItemCracked = 530,
  IsItemCrafted = 531,
  IsItemIconic = 532,
  IsItemUpgraded = 533,
  IsManBig = 534,
  IsManMassive = 535,
  IsMechanical = 536,
  IsNetrunnerArchetype = 537,
  IsNotSlowedDuringADS = 538,
  IsNotSlowedDuringBlock = 539,
  IsNotSlowedDuringReload = 540,
  IsReckless = 541,
  IsShotgunnerArchetype = 542,
  IsSniperArchetype = 543,
  IsSprintStaminaFree = 544,
  IsStrongMeleeArchetype = 545,
  IsTechieArchetype = 546,
  IsTier1Archetype = 547,
  IsTier2Archetype = 548,
  IsTier3Archetype = 549,
  IsTier4Archetype = 550,
  IsWeakspot = 551,
  IsWeaponLethal = 552,
  ItemArmor = 553,
  ItemLevel = 554,
  ItemRequiresElectroPlating = 555,
  ItemRequiresPowerGrip = 556,
  ItemRequiresSmartLink = 557,
  JumpHeight = 558,
  Kenjutsu = 559,
  KenjutsuMastery = 560,
  KenjutsuTrait01Stat = 561,
  KnockdownDamageThreshold = 562,
  KnockdownDamageThresholdImpulse = 563,
  KnockdownDamageThresholdInCover = 564,
  KnockdownImmunity = 565,
  KnockdownImpulse = 566,
  Level = 567,
  LimbHealth = 568,
  LinearDirectionUpdateMax = 569,
  LinearDirectionUpdateMaxADS = 570,
  LinearDirectionUpdateMin = 571,
  LinearDirectionUpdateMinADS = 572,
  LowerActiveCooldownOnDefeat = 573,
  LowerHackingResistanceOnHack = 574,
  MagazineCapacity = 575,
  MagazineCapacityBase = 576,
  MagazineCapacityBonus = 577,
  MaxDuration = 578,
  MaxPercentDamageTakenPerHit = 579,
  MaxSpeed = 580,
  MaxStacks = 581,
  MaxStacksBonusBleeding = 582,
  MaxStacksBonusBurning = 583,
  MaximumRange = 584,
  MechanicalsBuffDPSBonus = 585,
  MeleeAttackDuration = 586,
  Memory = 587,
  MemoryCostModifier = 588,
  MemoryCostReduction = 589,
  MemoryInCombatRegenDelayOnChange = 590,
  MemoryInCombatRegenEnabled = 591,
  MemoryInCombatRegenEndThreshold = 592,
  MemoryInCombatRegenRate = 593,
  MemoryInCombatRegenRateAdd = 594,
  MemoryInCombatRegenRateBase = 595,
  MemoryInCombatRegenRateMult = 596,
  MemoryInCombatRegenStartThreshold = 597,
  MemoryInCombatStartDelay = 598,
  MemoryOutOfCombatRegenDelayOnChange = 599,
  MemoryOutOfCombatRegenEnabled = 600,
  MemoryOutOfCombatRegenEndThreshold = 601,
  MemoryOutOfCombatRegenRate = 602,
  MemoryOutOfCombatRegenRateAdd = 603,
  MemoryOutOfCombatRegenRateBase = 604,
  MemoryOutOfCombatRegenRateMult = 605,
  MemoryOutOfCombatRegenStartThreshold = 606,
  MemoryOutOfCombatStartDelay = 607,
  MemoryTrackerCooldownDuration = 608,
  MemoryWipeImmunity = 609,
  MinSpeed = 610,
  MinigameBufferExtension = 611,
  MinigameMaterialsEarned = 612,
  MinigameMemoryRegenPerk = 613,
  MinigameMoneyMultiplier = 614,
  MinigameNextInstanceBufferExtensionPerk = 615,
  MinigameShardChanceMultiplier = 616,
  MinigameTimeLimitExtension = 617,
  MinigameTrapsPossibilityChance = 618,
  NPCAnimationTime = 619,
  NPCCorpoEquipItemDuration = 620,
  NPCCorpoUnequipItemDuration = 621,
  NPCDamage = 622,
  NPCEquipItemDuration = 623,
  NPCGangEquipItemDuration = 624,
  NPCGangUnequipItemDuration = 625,
  NPCLoopDuration = 626,
  NPCRecoverDuration = 627,
  NPCStartupDuration = 628,
  NPCUnequipItemDuration = 629,
  NPCUploadTime = 630,
  NoJam = 631,
  NumShotsInBurst = 632,
  NumShotsInBurstMaxCharge = 633,
  NumShotsInBurstSecondary = 634,
  NumShotsToFire = 635,
  NumberIgnoredTraps = 636,
  Overheat = 637,
  Oxygen = 638,
  PartArmor = 639,
  PenetrationHealth = 640,
  PersonalityAggressive = 641,
  PersonalityCuriosity = 642,
  PersonalityDisgust = 643,
  PersonalityFear = 644,
  PersonalityFunny = 645,
  PersonalityJoy = 646,
  PersonalitySad = 647,
  PersonalityShock = 648,
  PersonalitySurprise = 649,
  PhoneCallDuration = 650,
  PhysicalDamage = 651,
  PhysicalDamageMax = 652,
  PhysicalDamageMin = 653,
  PhysicalDamagePercent = 654,
  PhysicalImpulse = 655,
  PhysicalResistance = 656,
  PoisonImmunity = 657,
  PoisonRegenHealth = 658,
  PoisonedApplicationRate = 659,
  PowerLevel = 660,
  PreFireTime = 661,
  PrefersCovers = 662,
  PrefersShootingSpots = 663,
  Price = 664,
  ProjectilesPerShot = 665,
  ProjectilesPerShotBase = 666,
  ProjectilesPerShotBonus = 667,
  Quality = 668,
  Quantity = 669,
  QuickHackDuration = 670,
  QuickHackDurationExtension = 671,
  QuickHackImmunity = 672,
  QuickHackResistancesMod = 673,
  QuickHackSpreadDistance = 674,
  QuickHackSpreadNumber = 675,
  QuickHackSuddenDeathChance = 676,
  QuickHackUpload = 677,
  QuickhackExtraDamageMultiplier = 678,
  QuickhackShield = 679,
  QuickhacksCooldownReduction = 680,
  RandomCurveInput = 681,
  Range = 682,
  Recoil = 683,
  RecoilAllowSway = 684,
  RecoilAlternateDir = 685,
  RecoilAlternateDirADS = 686,
  RecoilAngle = 687,
  RecoilAngleADS = 688,
  RecoilAnimation = 689,
  RecoilChargeMult = 690,
  RecoilChargeMultADS = 691,
  RecoilCycleSize = 692,
  RecoilCycleSizeADS = 693,
  RecoilCycleTime = 694,
  RecoilCycleTimeADS = 695,
  RecoilDelay = 696,
  RecoilDir = 697,
  RecoilDirADS = 698,
  RecoilDirPlanCycleRandDir = 699,
  RecoilDirPlanCycleRandDirADS = 700,
  RecoilDirPlanCycleRandRangeDir = 701,
  RecoilDirPlanCycleRandRangeDirADS = 702,
  RecoilDirPlanSequence = 703,
  RecoilDirPlanSequenceADS = 704,
  RecoilDriftRandomRangeMax = 705,
  RecoilDriftRandomRangeMin = 706,
  RecoilEnableCycleX = 707,
  RecoilEnableCycleXADS = 708,
  RecoilEnableCycleY = 709,
  RecoilEnableCycleYADS = 710,
  RecoilEnableLinearX = 711,
  RecoilEnableLinearXADS = 712,
  RecoilEnableLinearY = 713,
  RecoilEnableLinearYADS = 714,
  RecoilEnableScaleX = 715,
  RecoilEnableScaleXADS = 716,
  RecoilEnableScaleY = 717,
  RecoilEnableScaleYADS = 718,
  RecoilFullChargeMult = 719,
  RecoilFullChargeMultADS = 720,
  RecoilHoldDuration = 721,
  RecoilHoldDurationADS = 722,
  RecoilKickMax = 723,
  RecoilKickMaxADS = 724,
  RecoilKickMin = 725,
  RecoilKickMinADS = 726,
  RecoilMagForFullDrift = 727,
  RecoilMaxLength = 728,
  RecoilMaxLengthADS = 729,
  RecoilRecoveryMinSpeed = 730,
  RecoilRecoveryMinSpeedADS = 731,
  RecoilRecoverySpeed = 732,
  RecoilRecoverySpeedADS = 733,
  RecoilRecoveryTime = 734,
  RecoilRecoveryTimeADS = 735,
  RecoilScaleMax = 736,
  RecoilScaleMaxADS = 737,
  RecoilScaleTime = 738,
  RecoilScaleTimeADS = 739,
  RecoilSpeed = 740,
  RecoilSpeedADS = 741,
  RecoilTime = 742,
  RecoilTimeADS = 743,
  RecoilUseDifferentStatsInADS = 744,
  Reflexes = 745,
  RefreshesPingOnQuickhack = 746,
  RegenerateHPMinigamePerk = 747,
  ReloadAmount = 748,
  ReloadEndTime = 749,
  ReloadTime = 750,
  ReloadTimeBase = 751,
  ReloadTimeBonus = 752,
  RemoveAllStacksWhenDurationEnds = 753,
  RemoveColdBloodStacksOneByOne = 754,
  RemoveSprintOnQuickhack = 755,
  ReprimandEscalation = 756,
  RestoreMemoryOnDefeat = 757,
  RevealNetrunnerWhenHacked = 758,
  RicochetChance = 759,
  RicochetCount = 760,
  RicochetMaxAngle = 761,
  RicochetMinAngle = 762,
  RicochetTargetSearchAngle = 763,
  SandevistanDashShoot = 764,
  ScanDepth = 765,
  ScanTimeReduction = 766,
  ScopeFOV = 767,
  ScopeOffset = 768,
  ScrapItemChance = 769,
  SharedCacheTraps = 770,
  ShootingOffsetAI = 771,
  ShortCircuitOnCriticalHit = 772,
  ShorterChains = 773,
  ShotDelay = 774,
  SlideWhenLeaningOutOfCover = 775,
  SmartGunAddSpiralTrajectory = 776,
  SmartGunAdsLockingAnglePitch = 777,
  SmartGunAdsLockingAngleYaw = 778,
  SmartGunAdsMaxLockedTargets = 779,
  SmartGunAdsTagLockAnglePitch = 780,
  SmartGunAdsTagLockAngleYaw = 781,
  SmartGunAdsTargetableAnglePitch = 782,
  SmartGunAdsTargetableAngleYaw = 783,
  SmartGunAdsTimeToLock = 784,
  SmartGunAdsTimeToUnlock = 785,
  SmartGunEvenDistributionPeriod = 786,
  SmartGunHipLockingAnglePitch = 787,
  SmartGunHipLockingAngleYaw = 788,
  SmartGunHipMaxLockedTargets = 789,
  SmartGunHipTagLockAnglePitch = 790,
  SmartGunHipTagLockAngleYaw = 791,
  SmartGunHipTargetableAnglePitch = 792,
  SmartGunHipTargetableAngleYaw = 793,
  SmartGunHipTimeToLock = 794,
  SmartGunHipTimeToUnlock = 795,
  SmartGunHitProbability = 796,
  SmartGunHitProbabilityMultiplier = 797,
  SmartGunMissDelay = 798,
  SmartGunMissRadius = 799,
  SmartGunNPCApplySpreadAtHitplane = 800,
  SmartGunNPCLockOnTime = 801,
  SmartGunNPCLockTimeout = 802,
  SmartGunNPCLockingAnglePitch = 803,
  SmartGunNPCLockingAngleYaw = 804,
  SmartGunNPCProjectileStartingOrientationAngleOffset = 805,
  SmartGunNPCProjectileVelocity = 806,
  SmartGunNPCShootProjectilesOnlyStraight = 807,
  SmartGunNPCSpreadMultiplier = 808,
  SmartGunNPCTrajectoryCurvatureMultiplier = 809,
  SmartGunPlayerProjectileVelocity = 810,
  SmartGunProjectileVelocityVariance = 811,
  SmartGunSpiralCycleTimeMax = 812,
  SmartGunSpiralCycleTimeMin = 813,
  SmartGunSpiralRadius = 814,
  SmartGunSpiralRampDistanceEnd = 815,
  SmartGunSpiralRampDistanceStart = 816,
  SmartGunSpiralRandomizeDirection = 817,
  SmartGunSpreadMultiplier = 818,
  SmartGunStartingAccuracy = 819,
  SmartGunTargetAcquisitionRange = 820,
  SmartGunTimeToMaxAccuracy = 821,
  SmartGunTimeToRemoveOccludedTarget = 822,
  SmartGunTrackAllBodyparts = 823,
  SmartGunTrackHeadComponents = 824,
  SmartGunTrackLegComponents = 825,
  SmartGunTrackMechanicalComponents = 826,
  SmartGunTrackMultipleEntitiesInADS = 827,
  SmartGunUseEvenDistributionTargeting = 828,
  SmartGunUseTagLockTargeting = 829,
  SmartGunUseTimeBasedAccuracy = 830,
  SmartTargetingDisruptionProbability = 831,
  SpecialDamage = 832,
  SpeedBoost = 833,
  SpeedBoostMaxSpeed = 834,
  Spread = 835,
  SpreadAdsChangePerShot = 836,
  SpreadAdsChargeMult = 837,
  SpreadAdsDefaultX = 838,
  SpreadAdsDefaultY = 839,
  SpreadAdsFastSpeedMax = 840,
  SpreadAdsFastSpeedMaxAdd = 841,
  SpreadAdsFastSpeedMin = 842,
  SpreadAdsFastSpeedMinAdd = 843,
  SpreadAdsFullChargeMult = 844,
  SpreadAdsMaxX = 845,
  SpreadAdsMaxY = 846,
  SpreadAdsMinX = 847,
  SpreadAdsMinY = 848,
  SpreadAnimation = 849,
  SpreadChangePerShot = 850,
  SpreadChargeMult = 851,
  SpreadCrouchDefaultMult = 852,
  SpreadCrouchMaxMult = 853,
  SpreadDefaultX = 854,
  SpreadDefaultY = 855,
  SpreadEvenDistributionJitterSize = 856,
  SpreadEvenDistributionRowCount = 857,
  SpreadFastSpeedMax = 858,
  SpreadFastSpeedMaxAdd = 859,
  SpreadFastSpeedMin = 860,
  SpreadFastSpeedMinAdd = 861,
  SpreadFullChargeMult = 862,
  SpreadMaxAI = 863,
  SpreadMaxX = 864,
  SpreadMaxY = 865,
  SpreadMinX = 866,
  SpreadMinY = 867,
  SpreadRandomizeOriginPoint = 868,
  SpreadResetSpeed = 869,
  SpreadResetTimeThreshold = 870,
  SpreadUseCircularSpread = 871,
  SpreadUseEvenDistribution = 872,
  SpreadUseInAds = 873,
  SpreadZeroOnFirstShot = 874,
  StaggerDamageThreshold = 875,
  StaggerDamageThresholdImpulse = 876,
  StaggerDamageThresholdInCover = 877,
  Stamina = 878,
  StaminaCostReduction = 879,
  StaminaCostToBlock = 880,
  StaminaDamage = 881,
  StaminaRegenDelayOnChange = 882,
  StaminaRegenEnabled = 883,
  StaminaRegenEndThrehold = 884,
  StaminaRegenRate = 885,
  StaminaRegenRateAdd = 886,
  StaminaRegenRateBase = 887,
  StaminaRegenRateMult = 888,
  StaminaRegenStartDelay = 889,
  StaminaRegenStartThreshold = 890,
  StaminaSprintDecayRate = 891,
  StatModifierGroupLimit = 892,
  Stealth = 893,
  StealthHacksCostReduction = 894,
  StealthHitDamageMultiplier = 895,
  StealthMastery = 896,
  StealthTrait01Stat = 897,
  StealthWeakspotDamageMultiplier = 898,
  StreetCred = 899,
  Strength = 900,
  StunImmunity = 901,
  Sway = 902,
  SwayCenterMaximumAngleOffset = 903,
  SwayCurvatureMaximumFactor = 904,
  SwayCurvatureMinimumFactor = 905,
  SwayInitialOffsetRandomFactor = 906,
  SwayResetOnAimStart = 907,
  SwaySideBottomAngleLimit = 908,
  SwaySideMaximumAngleDistance = 909,
  SwaySideMinimumAngleDistance = 910,
  SwaySideStepChangeMaximumFactor = 911,
  SwaySideStepChangeMinimumFactor = 912,
  SwaySideTopAngleLimit = 913,
  SwayStartBlendTime = 914,
  SwayStartDelay = 915,
  SwayTraversalTime = 916,
  SystemCollapseImmunity = 917,
  TBHsBaseCoefficient = 918,
  TBHsBaseSourceMultiplierCoefficient = 919,
  TBHsCoverTraceLoSIncreaseSpeed = 920,
  TBHsMinimumLineOfSightTime = 921,
  TBHsSensesTraceLoSIncreaseSpeed = 922,
  TBHsVisibilityCooldown = 923,
  TechBaseChargeThreshold = 924,
  TechMaxChargeThreshold = 925,
  TechOverChargeThreshold = 926,
  TechPierceChargeLevel = 927,
  TechPierceEnabled = 928,
  TechnicalAbility = 929,
  ThermalDamage = 930,
  ThermalDamageMax = 931,
  ThermalDamageMin = 932,
  ThermalDamagePercent = 933,
  ThermalResistance = 934,
  ThreeOrMoreProgramsCooldownRedPerk = 935,
  ThreeOrMoreProgramsMemoryRegPerk = 936,
  TimeDilationGenericDuration = 937,
  TimeDilationGenericTimeScale = 938,
  TimeDilationKerenzikovDuration = 939,
  TimeDilationKerenzikovPlayerTimeScale = 940,
  TimeDilationKerenzikovTimeScale = 941,
  TimeDilationOnDodgesCooldownDuration = 942,
  TimeDilationOnDodgesDuration = 943,
  TimeDilationOnDodgesTimeScale = 944,
  TimeDilationOnHealthDropCooldownDuration = 945,
  TimeDilationOnHealthDropDuration = 946,
  TimeDilationOnHealthDropTimeScale = 947,
  TimeDilationSandevistanCooldownBase = 948,
  TimeDilationSandevistanCooldownReduction = 949,
  TimeDilationSandevistanDuration = 950,
  TimeDilationSandevistanTimeScale = 951,
  TimeDilationWhenEnteringCombatCooldownDuration = 952,
  TimeDilationWhenEnteringCombatDuration = 953,
  TimeDilationWhenEnteringCombatTimeScale = 954,
  TranquilizerImmunity = 955,
  TriggerDismembermentChance = 956,
  TriggerWoundedChance = 957,
  TurretFriendlyExtension = 958,
  TurretShutdownExtension = 959,
  UltimateHackSpread = 960,
  UltimateHacksCostReduction = 961,
  UltimateMemoryCostReduction = 962,
  UnconsciousImmunity = 963,
  UnequipAnimationDuration_Corpo = 964,
  UnequipAnimationDuration_Gang = 965,
  UnequipDuration = 966,
  UnequipDuration_Corpo = 967,
  UnequipDuration_Gang = 968,
  UnequipItemTime_Corpo = 969,
  UnequipItemTime_Gang = 970,
  UnlockProgress = 971,
  UpgradingCostReduction = 972,
  UpgradingMaterialDropChance = 973,
  UpgradingMaterialRandomGrantChance = 974,
  UpgradingMaterialRetrieveChance = 975,
  UploadQuickHackMod = 976,
  Visibility = 977,
  VisualStimRangeMultiplier = 978,
  VulnerabilityExtension = 979,
  WallRunHorSpeedToEnterMin = 980,
  WallRunStrafeAngleMax = 981,
  WallRunTimeMax = 982,
  WallRunVertSpeedToEnterMax = 983,
  WasItemUpgraded = 984,
  WasQuickHacked = 985,
  WeakspotDamageMultiplier = 986,
  WeaponHasAutoloader = 987,
  WeaponNoise = 988,
  WeaponPosAdsX = 989,
  WeaponPosAdsY = 990,
  WeaponPosAdsZ = 991,
  WeaponPosX = 992,
  WeaponPosY = 993,
  WeaponPosZ = 994,
  WeaponRotAdsX = 995,
  WeaponRotAdsY = 996,
  WeaponRotAdsZ = 997,
  WeaponRotX = 998,
  WeaponRotY = 999,
  WeaponRotZ = 1000,
  Weight = 1001,
  WoundHeadDamageThreshold = 1002,
  WoundLArmDamageThreshold = 1003,
  WoundLLegDamageThreshold = 1004,
  WoundRArmDamageThreshold = 1005,
  WoundRLegDamageThreshold = 1006,
  ZoomLevel = 1007,
  CPO_Armor = 1008,
  CPO_NPC_Importance = 1009,
  Count = 1010,
  Invalid = 1011,
}

enum gamedataTweakDBType {
  Invalid = 0,
  ForeignKey = 1,
  Int = 2,
  Float = 3,
  Bool = 4,
  String = 5,
  CName = 6,
  ResRef = 7,
  LocKey = 8,
  Color = 9,
  Vector2 = 10,
  Vector3 = 11,
  EulerAngles = 12,
  Quaternion = 13,
}

public abstract native class gamedataValueDataNode extends gamedataDataNode {}

public native class gamedataValueNode extends gamedataDataNode {
  native let data: ref<gamedataValueDataNode>;
  native let group: ref<gamedataGroupNode>;
}

public native class gamedataVariableNode extends gamedataDataNode {
  native let hashedName: CName;
  native let type: String;
  native let name: String;
  native let isForeignKey: Bool;
  native let isArray: Bool;
  native let hasArrayValues: Bool;
  native let isAddition: Bool;
  native let typeEnum: gamedataTweakDBType;
  native let values: array<gamedataVariableNodeVariableValue>;
}

public native struct gamedataVariableNodeVariableValue {
  native let node: ref<gamedataValueNode>;
  native let deriveInfo: gamedataVariableNodeVariableValueDeriveInfo;
}

enum gamedataVariableNodeVariableValueDeriveInfo {
  NotDerived = 0,
  ArrayAddition = 1,
}

public native class gameDebugCheatsSharedState extends gameIGameSystemReplicatedState {
  native let activeCheats: array<gamecheatsystemObjCheats>;
  native let debugTimeDilationIndex: Uint32;
  native let debugTimeDilationPlayerIndex: Uint32;
}

public native struct gameDebugContextPtr {}

public native struct gameDebugContextUserData {}

public native class gameDebugDrawHistorySystem extends IDebugDrawHistorySystem {}

public native class gamedebugFailure extends ISerializable {
  native let id: gamedebugFailureId;
  native let time: Float;
  native let message: String;
  native let path: gameDebugPath;
  native let previous: ref<gamedebugFailure>;
  native let cause: ref<gamedebugFailure>;
}

public native struct gamedebugFailureId {
  native let threadId: Uint32;
  native let unsignedId: Uint32;
}

public native class gameDebugFreeCamera extends GameObject {}

public native struct gameDebugPath {
  native let str: String;
}

public native class gameDebugPerformanceSystem extends IGameSystem {}

public native class gameDebugTimeState extends gameITimeState {}

public native class gameDefaultAppearancePreset_Entity extends ISerializable {
  native let entityPathHash: Uint64;
  native let debugEntityPath: CName;
  native let defaultAppearanceName: CName;
}

enum gameDelayContext {
  Standard_TD = 1,
  Standard_ND = 2,
  Quest_TD = 4,
  SpawnManager_ND = 8,
}

public native class gameDelayedFunctionsScheduler extends ISerializable {
  native persistent let initialized: Bool;
  native persistent let currentTime: EngineTime;
  native persistent let nextCallId: Uint32;
}

public native class gameDelayedTimer extends gameBaseTimer {}

public abstract native class gameDelaySystemCallbackInfo extends gameDelaySystemDelayStruct {}

public abstract native class gameDelaySystemDelayStruct extends ISerializable {}

public abstract native class gameDelaySystemEventStruct extends gameDelaySystemDelayStruct {}

public abstract native class gameDelaySystemPSEventStruct extends gameDelaySystemDelayStruct {}

public abstract native class gameDelaySystemScriptableSysRequestStruct extends gameDelaySystemDelayStruct {}

public abstract native class gameDelaySystemTickOnEventStruct extends gameDelaySystemTickStruct {}

public abstract native class gameDelaySystemTickStruct extends ISerializable {}

public abstract native class gameDelaySystemTickWithCallbackStruct extends gameDelaySystemTickStruct {}

public native class gameDependentWorkspotData extends ISerializable {}

public native class gameDeprecated_GameplayEvent extends Event {}

public native class gameDestructibleObject extends GameObject {
  native let recordID: TweakDBID;
}

public native class gameDeviceLoaded extends Event {}

public native class gameDeviceResource extends CResource {
  native let data: ref<gameDeviceResourceData>;
}

public native class gameDeviceResourceData extends ISerializable {
  native let version: Uint32;
}

public native struct gameDynamicEntityHandler {}

public native class gameDynamicEntityIDSystem extends gameIDynamicEntityIDSystem {}

public native class gameDynamicEventNode extends worldAreaShapeNode {
  native let mappinRef: NodeRef;
  native let condition: ref<questIBaseCondition>;
}

public native class gameDynamicEventNodeInstance extends worldAreaShapeNodeInstance {}

enum gameEActionFlags {
  NONE = 0,
  USE_ANIMATION = 1,
  USE_MOVEMENT = 2,
}

enum gameEAreaShape {
  NONE = 0,
  SPHERE = 1,
  CUBE = 2,
  COUNT = 3,
}

enum gameEAreaType {
  NONE = 0,
  LOCATION = 1,
  AFFILIATION = 2,
  COUNT = 3,
}

enum gameECharacterStance {
  Stance_Stand = 0,
  Stance_Crouch = 1,
  Stance_Kneel = 2,
  Stance_Cover = 3,
  Stance_Standing_Cover = 4,
  Stance_Crouching_Cover = 5,
}

public native class gameEffectAction_ChildEffectsMovingInCone extends EffectPostAction {
  native let effectsCount: Uint32;
  native let effectTagInThisFile: CName;
  native let coneAngle: Float;
  native let minEffectDuration: Float;
  native let maxEffectDuration: Float;
  native let twoDimensional: Bool;
  native let smoothInterpolations: Bool;
}

public native class gameEffectAction_KillFX extends EffectAction {
  native let action: gameEffectAction_KillFXAction;
  native let effectTag: CName;
}

enum gameEffectAction_KillFXAction {
  Stop = 0,
  BreakLoop = 1,
}

public native class gameEffectAction_MissEvent extends EffectAction {
  native let npcMissEvents: Bool;
}

public native class gameEffectAction_NewEffect_ReverseFromLastHit extends EffectPostAction {
  native let tagInThisFile: CName;
  native let forwardOffset: Float;
  native let childEffect: Bool;
  native let childEffectTag: CName;
}

public native class gameEffectAction_NewEffect_Ricochet extends EffectPostAction {
  native let tagInThisFile: CName;
  native let forwardOffset: Float;
  native let childEffect: Bool;
  native let childEffectTag: CName;
}

public native class gameEffectAction_NewEffect_SpreadingEffect extends EffectPostAction {
  native let tagInThisFile: CName;
  native let forwardOffset: Float;
  native let childEffect: Bool;
  native let childEffectTag: CName;
}

public native class gameEffectAction_TerminateChildEffect extends EffectAction {
  native let effectTag: CName;
}

public native class gameEffectAttachment extends entIAttachment {}

public native class gameEffectComponentBinding extends entISourceBinding {}

public native struct gameEffectData_MeleeTireHit {}

public native struct gameEffectData_MeleeWaterFx {}

public native struct gameEffectData_Pierce {}

public native struct gameEffectData_PiercePreview {}

public native struct gameEffectData_Splatter {}

public native struct gameEffectData_SplatterList {}

public native struct gameEffectDebugSettings {
  native let overrideGlobalSettings: Bool;
  native let duration: Float;
  native let color: Color;
}

public native struct gameEffectDefinition {
  native let tag: CName;
  native let objectProviders: array<ref<EffectObjectProvider>>;
  native let objectFilters: array<ref<gameEffectObjectFilter>>;
  native let effectExecutors: array<ref<EffectExecutor>>;
  native let durationModifiers: array<ref<EffectDurationModifier>>;
  native let preActions: array<ref<EffectPreAction>>;
  native let postActions: array<ref<EffectPostAction>>;
  native let noTargetsActions: array<ref<EffectAction>>;
  native let settings: gameEffectSettings;
  native let debugSettings: gameEffectDebugSettings;
}

public native class gameEffectDuration_Duration_Blackboard extends EffectDurationModifier {}

public native class gameEffectDuration_Infinite extends EffectDurationModifier {}

public native class gameEffectDuration_Instant extends EffectDurationModifier {}

public native class gameEffectDuration_PredefinedTimeout extends EffectDurationModifier {
  native let timeToLive: Float;
}

public native class gameEffectExecutor_AnimFeature extends EffectExecutor {
  native let key: CName;
  native let animFeature: ref<AnimFeature>;
  native let applyTo: gameEffectExecutor_AnimFeatureApplyTo;
  native let ignoreWaterImpacts: Bool;
}

enum gameEffectExecutor_AnimFeatureApplyTo {
  Target = 0,
  Instigator = 1,
}

public native class gameEffectExecutor_DamageProjection extends EffectExecutor {}

public native class gameEffectExecutor_Finisher extends EffectExecutor {
  native let InfluencedByPlayerCostBlock: Bool;
  native let finisherScenarios: array<ref<gameIFinisherScenario>>;
  native let alwaysUseEntryAnims: Bool;
  native let allowCameraMovement: Bool;
}

public native class gameEffectExecutor_GroundSlamEffects extends EffectExecutor {
  native let groundEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let waterEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let earthquakeLevel1: ResourceAsyncRef; // raRef<worldEffect>
  native let earthquakeLevel2: ResourceAsyncRef; // raRef<worldEffect>
  native let earthquakeLevel1ChargeThreshold: Float;
  native let earthquakeLevel2ChargeThreshold: Float;
}

public native class gameEffectExecutor_HitReaction extends EffectExecutor {
  native let npcMissEvents: Bool;
}

public native struct gameEffectExecutor_KatanaBulletBendingEffectEntry {
  native let tag: CName;
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let attach: Bool;
}

public native class gameEffectExecutor_LandingFX extends EffectExecutor {}

public native class gameEffectExecutor_NewEffect_CopyData extends gameEffectExecutor_NewEffect {}

public native class gameEffectExecutor_NewEffect_ReflectedVector extends EffectExecutor {}

public native class gameEffectExecutor_NewEffect_RicochetScan extends gameEffectExecutor_NewEffect {
  native let box: Vector4;
  native let isPreview: Bool;
  native let onlyForPlayer: Bool;
}

public abstract native class gameEffectExecutor_NewEffect extends EffectExecutor {
  native let tagInThisFile: CName;
  native let forwardOffset: Float;
  native let childEffect: Bool;
  native let childEffectTag: CName;
}

public native class gameEffectExecutor_OverrideMaterial extends EffectExecutor {
  native let material: ResourceRef; // rRef<IMaterial>
}

public native class gameEffectExecutor_PhysicalFractureField extends EffectExecutor {
  native let fromHitPosition: Bool;
  native let fieldParams: physicsFractureFieldParams;
  native let fieldShape: physicsShapeType;
  native let fieldDimensions: Vector3;
}

public native class gameEffectExecutor_PhysicalImpulseFromInstigator_Value extends EffectExecutor {
  native let magnitude: Float;
  native let forceUseHitPosition: Bool;
}

public native class gameEffectExecutor_PhysicalImpulseFromInstigator extends EffectExecutor {}

public native class gameEffectExecutor_RevealObject extends EffectExecutor {
  native let reason: CName;
}

public native class gameEffectExecutor_SendStatusEffect extends EffectExecutor {}

public native class gameEffectExecutor_SendStimuli extends EffectExecutor {}

public native class gameEffectExecutor_TerminateGameEffect extends EffectExecutor {
  native let onlyWithPlayerInstigator: Bool;
}

public native class gameEffectExecutor_TriggerDestruction extends EffectExecutor {}

public native class gameEffectExecutor_UpdateMeleeTireHit extends EffectExecutor {}

public native class gameEffectExecutor_VisualEffect extends EffectExecutor {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let attached: Bool;
  native let breakLoopOnDetach: Bool;
  native let effectTag: CName;
  native let vectorEvaluator: ref<gameEffectVectorEvaluator>;
}

public native class gameEffectExecutor_VisualEffectAtInstigator extends EffectExecutor {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
}

public native class gameEffectFilter_NotObstructed extends EffectObjectSingleFilter {
  native let forwardOffset: Float;
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
  native let playerUseCameraPositionForCheck: Bool;
}

public native class gameEffectFilter_ReachableByAcousticGraph extends EffectObjectSingleFilter {
  native let maxPathLength: EffectInputParameter_Float;
}

public native class gameEffectFilter_ReachableByNavigation extends EffectObjectSingleFilter {
  native let maxPathLength: EffectInputParameter_Float;
}

enum gameEffectHitDataType {
  Entity = 0,
  Node = 1,
  Static = 2,
}

public native struct gameEffectNearlyHitAgentData {
  native let hitPosition: Vector4;
  native let hitDirection: Vector4;
  native let entity: wref<Entity>;
  native let isPlayer: Bool;
  native let wasHit: Bool;
}

public native class gameEffectObjectFilter_AxisRange extends EffectObjectSingleFilter {
  native let axis: gameEffectObjectFilter_AxisRangeAxis;
  native let position: EffectInputParameter_Vector;
  native let constraints: EffectInputParameter_Vector;
}

enum gameEffectObjectFilter_AxisRangeAxis {
  X = 0,
  Y = 1,
  Z = 2,
}

public native class gameEffectObjectFilter_BlockingGeometry extends gameEffectObjectGroupFilter {
  native let inclusive: Bool;
  native let sortQueryResultsByDistance: Bool;
}

public native class gameEffectObjectFilter_Cone extends EffectObjectSingleFilter {}

public native class gameEffectObjectFilter_DistanceFromRoot extends gameEffectObjectGroupFilter {
  native let rootZOffset: Float;
  native let bonusRange: Float;
}

public native class gameEffectObjectFilter_EntityType extends gameEffectObjectGroupFilter {
  native let typeFilter: gameEffectObjectFilter_EntityTypeEntityTypeFilter;
}

enum gameEffectObjectFilter_EntityTypeEntityTypeFilter {
  Puppet = 0,
  Device = 1,
}

public native class gameEffectObjectFilter_HitRepresentation_Capsule extends gameEffectObjectFilter_HitRepresentation {
  native let flattenCapsuleToHeight: Bool;
}

public native class gameEffectObjectFilter_HitRepresentation_Quickhack extends gameEffectObjectFilter_HitRepresentation {}

public native class gameEffectObjectFilter_HitRepresentation_Raycast extends gameEffectObjectFilter_HitRepresentation {
  native let isPreview: Bool;
  native let fillNearlyHitData: Bool;
}

public native class gameEffectObjectFilter_HitRepresentation_Sphere extends gameEffectObjectFilter_HitRepresentation {}

public native class gameEffectObjectFilter_HitRepresentation_Sweep_Box extends gameEffectObjectFilter_HitRepresentation {}

public native class gameEffectObjectFilter_HitRepresentation_SweepOverTime_Box extends gameEffectObjectFilter_HitRepresentation {}

public abstract native class gameEffectObjectFilter_HitRepresentation extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_HitType extends EffectObjectSingleFilter {
  native let action: gameEffectObjectFilter_HitTypeAction;
  native let hitType: gameEffectHitDataType;
}

enum gameEffectObjectFilter_HitTypeAction {
  Accept = 0,
  Reject = 1,
}

public native class gameEffectObjectFilter_IgnoreMountedVehicle extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NearestWeakspotIfAny extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NoDuplicates extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NoInstigator_MissEvent extends gameEffectObjectGroupFilter {
  native let npcMissEvents: Bool;
}

public native class gameEffectObjectFilter_NoInstigator extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NoInstigatorIfPlayerControlled extends EffectObjectSingleFilter {}

public native class gameEffectObjectFilter_NoPlayer extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NoPuppet extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NoSource extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NotAlive extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_NotObstructed extends gameEffectObjectGroupFilter {
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectFilter_NoWeapon extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_OnlyNearest_BB extends gameEffectObjectFilter_OnlyNearest {
  native let parameter: EffectInputParameter_Int;
}

public native class gameEffectObjectFilter_OnlyNearest_Pierce extends gameEffectObjectFilter_OnlyNearest {
  native let alwaysApplyFullWeaponCharge: Bool;
  native let includePierced: Bool;
}

public native class gameEffectObjectFilter_OnlyNearestMelee extends gameEffectObjectGroupFilter {
  native let count: Uint32;
}

public native class gameEffectObjectFilter_PlayerIgnoreFriendlyAndAlive extends gameEffectObjectGroupFilter {
  native let ignoreCharacterRecord: TweakDBID;
}

public native class gameEffectObjectFilter_RejectOnPrereq extends EffectObjectSingleFilter {
  native let prereq: ref<IPrereq>;
}

public native class gameEffectObjectFilter_TechPreview extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectFilter_Unique extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectGroupFilter_Cone extends gameEffectObjectGroupFilter {}

public native class gameEffectObjectProvider_Explosion extends EffectObjectProvider {
  native let puppets: Bool;
  native let gameObjects: Bool;
  native let destructibleAndDynamic: Bool;
}

public native class gameEffectObjectProvider_Laser extends gameEffectObjectProvider_PhysicalRay {
  native let inputTracesPerSecond: Uint32;
  native let inputRayOffset: Vector4;
}

public native class gameEffectObjectProvider_PhysicalRay extends EffectObjectProvider {
  native let inputPosition: EffectInputParameter_Vector;
  native let inputForward: EffectInputParameter_Vector;
  native let inputRange: EffectInputParameter_Float;
  native let outputRaycastEnd: EffectOutputParameter_Vector;
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_PhysicalRayFan extends gameEffectObjectProvider_PhysicalRay {
  native let inputMinRayAngleDiff: EffectInputParameter_Float;
}

public native class gameEffectObjectProvider_ProjectileHitEvent extends EffectObjectProvider {}

public native class gameEffectObjectProvider_QueryBox extends EffectObjectProvider {
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
  native let inputPosition: EffectInputParameter_Vector;
}

public native class gameEffectObjectProvider_QueryCapsule_GrowOverTime extends gameEffectObjectProvider_QueryCapsule {}

public native class gameEffectObjectProvider_QueryCapsule extends EffectObjectProvider {
  native let gatherOnlyPuppets: Bool;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_QueryShockwave extends gameEffectObjectProvider_QuerySphere {}

public native class gameEffectObjectProvider_QuerySphere_GrowOverTime extends gameEffectObjectProvider_QuerySphere {}

public native class gameEffectObjectProvider_QuerySphere_Value extends EffectObjectProvider {
  native let radius: Float;
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_QuerySphere extends EffectObjectProvider {
  native let gatherOnlyPuppets: Bool;
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_SingleEntity extends EffectObjectProvider {}

public native class gameEffectObjectProvider_SingleRicochetTarget extends EffectObjectProvider {
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_Stimuli_EntitiesInRange extends EffectObjectProvider {}

public native class gameEffectObjectProvider_Sweep_Box extends EffectObjectProvider {
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_SweepMelee_Box extends gameEffectObjectProvider_SweepOverTime {
  native let playerStaticDetectionConeDistance: Float;
  native let playerStaticDetectionConeStartAngle: Float;
  native let playerStaticDetectionConeEndAngle: Float;
  native let playerUseCameraForObstructionChecks: Bool;
  native let checkMeleeInvulnerability: Bool;
}

public native class gameEffectObjectProvider_SweepMelee_MantisBlades extends gameEffectObjectProvider_SweepMelee_Box {}

public native class gameEffectObjectProvider_SweepOverTime_Box extends gameEffectObjectProvider_SweepOverTime {}

public native class gameEffectObjectProvider_SweepOverTime_Capsule extends gameEffectObjectProvider_SweepOverTime {
  native let radius: Float;
  native let height: Float;
}

public native class gameEffectObjectProvider_SweepOverTime_Sphere extends gameEffectObjectProvider_SweepOverTime {
  native let radius: Float;
}

public abstract native class gameEffectObjectProvider_SweepOverTime extends EffectObjectProvider {
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
}

public native class gameEffectObjectProvider_TargetingObjectsInCone extends EffectObjectProvider {
  native let filterData: ref<physicsFilterData>;
  native let queryPreset: QueryPreset;
  native let searchQuery: TargetSearchQuery;
  native let maxTargets: Uint32;
  native let usePlayerPosAndForward: Bool;
}

public native class gameEffectObjectSingleFilter_BlackboardBoolCondition extends EffectObjectSingleFilter {
  native let parameter: EffectInputParameter_Bool;
  native let filter: ref<EffectObjectSingleFilter>;
}

public native class gameEffectParameter_BoolEvaluator_Blackboard extends gameIEffectParameter_BoolEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_BoolEvaluator_Value extends gameIEffectParameter_BoolEvaluator {
  native let value: Bool;
}

public native class gameEffectParameter_BoolEvaluator_ValueOrBlackboard extends gameIEffectParameter_BoolEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: Bool;
}

public native class gameEffectParameter_CNameEvaluator_Blackboard extends gameIEffectParameter_CNameEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_CNameEvaluator_Value extends gameIEffectParameter_CNameEvaluator {
  native let value: CName;
}

public native class gameEffectParameter_CNameEvaluator_ValueOrBlackboard extends gameIEffectParameter_CNameEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: CName;
}

public native class gameEffectParameter_FloatEvaluator_Blackboard extends gameIEffectParameter_FloatEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_FloatEvaluator_Value extends gameIEffectParameter_FloatEvaluator {
  native let value: Float;
}

public native class gameEffectParameter_FloatEvaluator_ValueOrBlackboard extends gameIEffectParameter_FloatEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: Float;
}

public native class gameEffectParameter_IntEvaluator_Blackboard extends gameIEffectParameter_IntEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_IntEvaluator_Value extends gameIEffectParameter_IntEvaluator {
  native let value: Uint32;
}

public native class gameEffectParameter_IntEvaluator_ValueOrBlackboard extends gameIEffectParameter_IntEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: Uint32;
}

public native class gameEffectParameter_QuatEvaluator_Blackboard extends gameIEffectParameter_QuatEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_QuatEvaluator_Value extends gameIEffectParameter_QuatEvaluator {
  native let value: Quaternion;
}

public native class gameEffectParameter_QuatEvaluator_ValueOrBlackboard extends gameIEffectParameter_QuatEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: Quaternion;
}

public native class gameEffectParameter_StringEvaluator_Blackboard extends gameIEffectParameter_StringEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_StringEvaluator_Value extends gameIEffectParameter_StringEvaluator {
  native let value: String;
}

public native class gameEffectParameter_StringEvaluator_ValueOrBlackboard extends gameIEffectParameter_StringEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: String;
}

public native class gameEffectParameter_VectorEvaluator_Blackboard extends gameIEffectParameter_VectorEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
}

public native class gameEffectParameter_VectorEvaluator_Value extends gameIEffectParameter_VectorEvaluator {
  native let value: Vector4;
}

public native class gameEffectParameter_VectorEvaluator_ValueOrBlackboard extends gameIEffectParameter_VectorEvaluator {
  native let blackboardProperty: gameBlackboardPropertyBindingDefinition;
  native let value: Vector4;
}

public native class gameEffectPostAction_Beam_RicochetPreview extends EffectPostAction {
  native let ricocheted: gameEffectPostAction_Beam_RicochetPreviewPreviewEffect;
  native let fromMuzzle: gameEffectPostAction_Beam_RicochetPreviewPreviewEffect;
}

public native struct gameEffectPostAction_Beam_RicochetPreviewPreviewEffect {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let effectTag: CName;
  native let effectSnap: ResourceAsyncRef; // raRef<worldEffect>
  native let effectSnapTag: CName;
  native let forwardOffset: Float;
}

public native class gameEffectPostAction_BeamVFX_Custom extends gameEffectPostAction_BeamVFX {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let attached: Bool;
  native let breakLoopOnDetach: Bool;
  native let invert: Bool;
  native let maxRange: Float;
  native let maxRangeTPP: Float;
  native let effectTag: CName;
}

public abstract native class gameEffectPostAction_BeamVFX extends EffectPostAction {}

public native class gameEffectPostAction_BulletExplode extends EffectPostAction {
  native let endRangeTolerance: Float;
  native let explosionDuration: Float;
}

public native class gameEffectPostAction_BulletTrace extends gameEffectPostAction_BeamVFX {}

public native class gameEffectPostAction_MeleeTireHit extends EffectPostAction {}

public native class gameEffectPostAction_MeleeWaterEffects extends EffectPostAction {}

public native class gameEffectPostAction_NewEffect_ChimeraMissileExplosion extends EffectPostAction {
  native let tagInThisFile: CName;
  native let overrideRadius: Float;
  native let executeOnNthHit: Int32;
}

public native class gameEffectPostAction_ProcessNearlyHitAgents extends EffectPostAction {}

public native class gameEffectPostAction_UpdateActiveVehicleUIData extends EffectPostAction {}

public native class gameEffectPostAction_WaterImpulse extends EffectPostAction {}

public native class gameEffectPreAction_SpreadingEffect extends EffectPreAction {}

public native class gameEffectPreAction_VisualEffectAtPosition extends EffectPreAction {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let attached: Bool;
  native let breakLoopOnDetach: Bool;
  native let vertical: Bool;
  native let effectTag: CName;
}

public native class gameEffectSet extends CResource {
  native let effects: array<gameEffectDefinition>;
}

public native struct gameEffectSettings {
  native let advancedTargetHandling: Bool;
  native let synchronousProcessingForPlayer: Bool;
  native let forceSynchronousProcessing: Bool;
  native let tempExecuteOnlyOnce: Bool;
  native let tickRate: Float;
  native let useSimTimeForTick: Bool;
}

public native class gameEffectSpawnerSaveSystem extends gameIEffectSpawnerSaveSystem {}

public native class gameEffectTriggerEffectDesc extends ISerializable {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let positionType: gameEffectTriggerPositioningType;
  native let rotationType: gameEffectTriggerRotationType;
  native let offset: Vector3;
  native let playFromHour: Uint32;
  native let playTillHour: Uint32;
}

public native class gameEffectTriggerNode extends worldAreaShapeNode {
  native let effectDescs: array<ref<gameEffectTriggerEffectDesc>>;
}

public native class gameEffectTriggerNodeInstance extends worldAreaShapeNodeInstance {}

enum gameEffectTriggerPositioningType {
  PlayerRoot = 0,
  CameraRoot = 1,
  AtSpawn = 2,
  XYCameraZPlayer = 3,
  XYPlayerZCamera = 4,
  XYCameraZTerrain = 5,
  XYPlayerZTerrain = 6,
}

enum gameEffectTriggerRotationType {
  None = 0,
  AtSpawn = 1,
  Continuous = 2,
}

public native class gameEffectTriggerSystem extends gameIEffectTriggerSystem {}

public native class gameEffectVectorEvaluator_HitDirection extends gameEffectVectorEvaluator {}

public native class gameEffectVectorEvaluator_HitNormal extends gameEffectVectorEvaluator {}

public abstract native class gameEffectVectorEvaluator extends ISerializable {
  native let modifier: Float;
}

enum gameEInventoryFlags {
  MustSave = 1,
}

enum gameELootGenerationType {
  DropChance = 0,
  NumberBased = 1,
  Weights = 2,
  Count = 3,
}

enum gameEMaterialZone {
  Zero = 0,
  One = 1,
  Two = 2,
  Three = 3,
}

public native class gameEnableScanningStatePropagationToParentEvent extends Event {
  native let isEnabled: Bool;
}

public native class gameEntityAppearanceColorVariantsArray extends ISerializable {
  native let appearanceName: CName;
  native let colorVariants: array<CName>;
}

public native struct gameEntityIDPool {}

enum gameEntityReferenceType {
  EntityRef = 0,
  Tag = 1,
  SlotID = 2,
  SceneActorContextName = 3,
}

enum gameEntityStubClass {
  Other = 0,
  Puppet = 1,
  Vehicle = 2,
}

public native class gameEntityStubComponent extends GameComponent {}

public native class gameEntityStubComponentPlacedProxy extends IPlacedComponent {}

public native class gameEntityStubSystem extends gameIEntityStubSystem {}

public native class gameEntityTemplateDefaultAppearancePreset extends ISerializable {
  native let defaultAppearancePresets: array<gameDefaultAppearancePreset_Entity>;
}

public native class gameEntityTemplateToAppearancesAndColorVariantsMap extends ISerializable {
  native let entries: array<gameEntityToAppearancesAndColorVariantsMapEntry>;
}

public native class gameEntityToAppearancesAndColorVariantsMapEntry extends ISerializable {
  native let entityPathHash: Uint64;
  native let debugEntityPath: String;
  native let appearancesAndTheirColorVariants: array<gameEntityAppearanceColorVariantsArray>;
}

public native class gameEnvironmentDamageReceiverBox extends gameEnvironmentDamageReceiverShape {
  native let dimensions: Vector3;
}

public native class gameEnvironmentDamageReceiverCapsule extends gameEnvironmentDamageReceiverShape {
  native let radius: Float;
  native let height: Float;
}

public abstract native class gameEnvironmentDamageReceiverShape extends ISerializable {
  native let transform: Transform;
}

public native class gameEnvironmentDamageSystem extends gameIEnvironmentDamageSystem {}

public native class gameEquippedPrereqListener extends AttachmentSlotsListener {}

public native struct gameEthnicityPicker {}

public native class gameeventsDeviceRegisterCameraControlOnPuppetEvent extends Event {
  native let component: ref<DeviceCameraControlComponent>;
  native let register: Bool;
}

public native class gameeventsMuppetUseLoadoutEvent extends Event {
  native let adout: ref<CPOLoadoutBase_Record>;
}

public native class gameeventsObjectMarkerVisibilityUpdated extends Event {
  native let canHaveObjectMarker: Bool;
  native let isVisible: Bool;
}

public native class gameeventsRefreshVisibility extends Event {}

public native class gameeventsReloadLootEvent extends Event {}

public native class gameeventsSquadStartedCombatEvent extends Event {
  native let started: Bool;
}

public native class gameeventsStealthMappinCheckLootEvent extends Event {}

public native class gameeventsToggleMinimapVisibilityEvent extends Event {
  native let show: Bool;
}

public native class gameeventsToggleStealthMappinVisibilityEvent extends Event {
  native let show: Bool;
}

public native class gameeventsUserEnteredCoverEvent extends Event {
  native let actionsPoints: array<WorldTransform>;
}

public native class gameeventsUserLeftCoverEvent extends Event {}

public native class gameExistingWorkspotFinisherScenario extends gameIFinisherScenario {
  native let playerWorkspot: ResourceAsyncRef; // raRef<workWorkspotResource>
  native let syncAnimSlotName: CName;
  native let playbackDelay: Float;
  native let blendTime: Float;
}

public native class gameExtraStatPoolDataModifierStatListener extends gameStatPoolDataModifierStatListener {}

public native class gameFinalTimeState extends gameITimeState {}

public native struct gameFinisherSyncData {
  native let syncAnimSlotName: CName;
  native let effector: TweakDBID;
}

public native struct gameFlattenedLootData {
  native let lootID: TweakDBID;
}

public native class gameFootstepEvent extends Event {}

public importonly native class gameForceVisionModuleQuestEvent extends Event {
  native let moduleName: CName;
  native let meshComponentNames: array<CName>;
}

public native struct gameFppRepDetachedObjectInfo {
  native let slotID: TweakDBID;
  native let itemTDBID: TweakDBID;
}

public native class gameFreeCamera extends GameObject {
  native let baseSpeed: Float;
  native let analogTurnRate: Float;
  native let mouseTurnRate: Float;
  native let activationBlendTime: Float;
  native let deactivationBlendTime: Float;
  native let usePhysicalCollision: Bool;
}

public native struct gameFreeCameraLightSettings {
  native let s: Vector3;
  native let dius: Float;
  native let tensity: Float;
  native let mperature: Float;
  native let lor: Vector4;
}

public native struct gameFreeCameraSettings {
  native let movPrecision: Float;
  native let rotPrecision: Float;
  native let roll: Float;
  native let fov: Float;
  native let dofIntensity: Float;
  native let dofNearBlur: Float;
  native let dofNearFocus: Float;
  native let dofFarBlur: Float;
  native let dofFarFocus: Float;
  native let iso: Int32;
  native let shutter: Float;
  native let aperture: Float;
  native let lights: array<gameFreeCameraLightSettings>;
}

public native class gameFuncCallEntry extends ISerializable {
  native persistent let callTime: EngineTime;
  native persistent let callId: Uint32;
}

enum gameGameplayEventFlag {
  Ai = 1,
  Trigger = 2,
  Component = 4,
  Script = 8,
}

public native class gameGameRulesSystem extends gameIGameRulesSystem {}

public native struct gameGameSessionDesc {}

public native struct gameGameTimeInterval {
  native let begin: GameTime;
  native let end: GameTime;
  native let ignoreDays: Bool;
}

public native class gameGarmentItemObject extends ItemObject {}

public native struct gameGlobalTierSaveData {
  native let subtype: gameGlobalTierSubtype;
  native let data: ref<SceneTierData>;
}

enum gameGlobalTierSubtype {
  Quest = 0,
  Supervisor = 1,
}

public native class gameGodModeSaveData extends ISerializable {
  native let gods: array<gameGodModeSaveEntityData>;
}

public native struct gameGodModeSaveEntityData {
  native let entityId: EntityID;
  native let data: GodModeEntityData;
}

public native class gameGodModeSharedState extends gameIGameSystemReplicatedState {
  native let datas: array<gameGodModeSharedStateData>;
}

public native struct gameGodModeSharedStateData {
  native let entity: wref<Entity>;
  native let flags: Int32;
}

public native class gameGOGRewardsSystem extends IOnlineSystem {}

public native class gamegraphCGraphResource extends CResource {}

public native class gamegraphCNode extends ISerializable {}

public native struct gameGrenadeThrowQuery {}

public native class gameHardcodedSignalPriorityDefinition extends gameSignalPriorityDefinition {
  native let signals: array<CName>;
}

public native struct gameHitDetectionDebugFrameData {
  native let t: Bool;
  native let mponent: wref<HitRepresentationComponent>;
  native let tTime: netTime;
  native let apes: array<gameHitDetectionDebugFrameDataShapeEntry>;
}

public native struct gameHitDetectionDebugFrameDataShapeEntry {
  native let ansformWS: WorldTransform;
}

public native struct gameHitRepresentationResult {
  native let sult: HitRepresentationQueryResult;
  native let tityID: EntityID;
}

public native struct gameHitRepresentationResults {
  native let sults: array<gameHitRepresentationResult>;
}

public native class gameHitRepresentationSystem extends IHitRepresentationSystem {}

public native struct gameHitShapeBVH {
  native let nodeName: CName;
  native let childrenNodes: array<gameHitShapeBVH>;
  native let childrenShapeNames: array<CName>;
}

public native class gameHumanoidBody extends IComponent {
  native let basePersonalSpace: Float;
  native let baseHeight: Float;
  native let baseEyesHeightRatio: Float;
  native let stanceAnimFeatureName: CName;
  native let aimAnimFeatureName: CName;
}

public abstract native class gameIActionsFactory extends IGameSystem {}

public abstract native class gameIAIDirectorSystem extends IGameSystem {}

public abstract native class gameIAreaManager extends IGameSystem {}

public abstract native class gameIBreachSystem extends IGameSystem {}

public abstract native class gameICollisionQueriesSystem extends IGameSystem {}

public abstract native class gameIComponentsStateSystem extends IGameSystem {}

public abstract native class gameIDebugSystem extends IGameSystem {}

public abstract native class gameIDynamicEntityIDSystem extends IGameSystem {}

public abstract native struct gameIEffectInputParameter {}

public abstract native struct gameIEffectOutputParameter {}

public abstract native class gameIEffectParameter_BoolEvaluator extends ISerializable {}

public abstract native class gameIEffectParameter_CNameEvaluator extends ISerializable {}

public abstract native class gameIEffectParameter_FloatEvaluator extends ISerializable {}

public abstract native class gameIEffectParameter_IntEvaluator extends ISerializable {}

public abstract native class gameIEffectParameter_QuatEvaluator extends ISerializable {}

public abstract native class gameIEffectParameter_StringEvaluator extends ISerializable {}

public abstract native class gameIEffectParameter_VectorEvaluator extends ISerializable {}

public abstract importonly native class gameIEffectSpawnerSaveSystem extends IGameSystem {}

public abstract native class gameIEffectTriggerSystem extends IGameSystem {}

public abstract native class gameIEntityStubSystem extends IGameSystem {}

public abstract native class gameIEnvironmentDamageSystem extends IGameSystem {}

public abstract native class gameIFinisherScenario extends ISerializable {}

public abstract native class gameIFootstepSystem extends IGameSystem {}

public abstract native class gameIGameSystemReplicatedState extends ISerializable {}

public abstract native class gameIItemFactorySystem extends IGameSystem {}

public native struct gameIMovingPlatformMovementInitData {
  native let initType: gameMovingPlatformMovementInitializationType;
  native let initValue: Float;
}

public native class gameImpostorComponent extends IComponent {
  native let isCharacterReplica: Bool;
  native let addHead: Bool;
  native let ignorePlayerHeadSlot: Bool;
  native let slotIDsToOmit: array<TweakDBID>;
}

public native class gameImpostorComponentAttachEvent extends Event {}

public native class gameImpostorComponentSlotListener extends AttachmentSlotsListener {}

public abstract native struct gameIMuppetInputAction {}

enum gameinfluenceEBoundingBoxType {
  Colider = 0,
  Custom = 1,
}

public native class gameinteractionsAlwaysSamePredicate extends gameinteractionsIPredicateType {
  native let priority: Float;
}

enum gameinteractionsBumpType {
  Workspot = 0,
  Crowd = 1,
}

public native class gameinteractionsCAabbDefinition extends gameinteractionsIShapeDefinition {
  native let min: Vector4;
  native let max: Vector4;
}

public native class gameinteractionsCFunctorDefinition extends gameinteractionsIFunctorDefinition {
  native let predicate: gameinteractionsCPredicateDefinition;
  native let unaryOperator: gameinteractionsEUnaryOperator;
}

public native struct gameinteractionsChoiceLookAtDescriptor {
  native let type: gameinteractionsChoiceLookAtType;
  native let slotName: CName;
  native let offset: Vector3;
  native let orbId: gameinteractionsOrbID;
}

enum gameinteractionsChoiceLookAtType {
  Root = 0,
  Slot = 1,
  Orb = 2,
}

public native class gameinteractionsCHotSpotAreaFilterDefinition extends gameinteractionsNodeDefinition {
  native let slotName: CName;
  native let transform: Transform;
  native let functor: ref<gameinteractionsCFunctorDefinition>;
  native let shapes: array<ref<gameinteractionsIShapeDefinition>>;
  native let negativeShapes: array<ref<gameinteractionsIShapeDefinition>>;
}

public native struct gameinteractionsCHotSpotDefinition {
  native let suppressor: Bool;
  native let layersDefinition: array<ref<gameinteractionsCLinkedLayersDefinition>>;
}

public native class gameinteractionsCHotSpotGameLogicFilterDefinition extends ISerializable {
  native let hotSpotPrereq: ref<IPrereq>;
  native let activatorPrereq: ref<IPrereq>;
  native let scriptedConditionClass: ref<InteractionScriptedCondition>;
}

public native class gameinteractionsCLinkedLayersDefinition extends gameinteractionsNodeDefinition {
  native let layersDefinitions: array<ref<HotSpotLayerDefinition>>;
  native let visualizerDefinition: ref<gameinteractionsvisIVisualizerDefinition>;
  native let tag: CName;
}

public native class gameinteractionsConeDefinition extends gameinteractionsIShapeDefinition {
  native let pos1: Vector4;
  native let pos2: Vector4;
  native let radius1: Float;
  native let radius2: Float;
}

public native class gameinteractionsContainedInShapesPredicate extends gameinteractionsIPredicateType {
  native let useCameraPosition: Bool;
}

public native class gameinteractionsCOrientedBoxDefinition extends gameinteractionsIShapeDefinition {
  native let position: Vector4;
  native let forward: Vector4;
  native let right: Vector4;
  native let up: Vector4;
}

public native struct gameinteractionsCPredicateDefinition {
  native let predicateType: ref<gameinteractionsIPredicateType>;
  native let binaryOperator: gameinteractionsEBinaryOperator;
  native let functor1DataDefinition: ref<gameinteractionsCFunctorDefinition>;
  native let functor2DataDefinition: ref<gameinteractionsCFunctorDefinition>;
}

public native struct gameinteractionsCSharedDataDefinition {
  native let defaultChoices: array<String>;
  native let visualizer: ref<gameuiIChoiceVisualizer>;
}

public native class gameinteractionsCSphereDefinition extends gameinteractionsIShapeDefinition {
  native let position: Vector4;
  native let radius: Float;
}

public native class gameinteractionsDistanceFromScreenCenterPredicate extends gameinteractionsIPredicateType {
  native let height: Float;
  native let width: Float;
  native let curvature: Float;
  native let maxPriorityBoundsFactor: Float;
}

enum gameinteractionsEBinaryOperator {
  EBinaryOperator_and = 0,
  EBinaryOperator_or = 1,
}

enum gameinteractionsEGroupType {
  EGT_default = 0,
  EGT_noInput = 1,
  EGT_hint = 2,
}

enum gameinteractionsELookAtTarget {
  Entity = 0,
  Component = 1,
}

enum gameinteractionsELookAtTest {
  Targeting = 0,
  Interaction = 1,
}

enum gameinteractionsEPredicateType {
  EPredicateFunction_true = 0,
  EPredicateFunction_distanceFromScreenCentre = 1,
  EPredicateFunction_containedInShapes = 2,
  EPredicateFunction_onScreenTest = 3,
  EPredicateFunction_visibleTarget = 4,
  EPredicateFunction_lookAt = 5,
  EPredicateFunction_lookAtComponent = 6,
  EPredicateFunction_logicalLookAt = 7,
  EPredicateFunction_obstructedLookAt = 8,
  EPredicateFunction_lineOfSight = 4,
}

enum gameinteractionsEUnaryOperator {
  EUnaryOperator_empty = 0,
  EUnaryOperator_not = 1,
}

public native struct gameinteractionsHotSpotActivationResult {
  native let priority: Float;
}

public abstract native class gameinteractionsIFunctorDefinition extends ISerializable {}

public native struct gameinteractionsInteractionDefinitionOverrider {
  native let tag: CName;
  native let shapes: array<ref<gameinteractionsIShapeDefinition>>;
  native let negativeShapes: array<ref<gameinteractionsIShapeDefinition>>;
  native let priorityMultiplier: Float;
}

public native class gameinteractionsInteractionDescriptorResource extends CResource {
  native let definition: gameinteractionsCHotSpotDefinition;
}

public abstract native class gameinteractionsIPredicateType extends ISerializable {}

public abstract native class gameinteractionsIShapeDefinition extends ISerializable {}

public native class gameinteractionsLayerActivatedPredicate extends gameinteractionsIPredicateType {
  native let linkedLayersName: CName;
  native let layerName: CName;
}

public native class gameinteractionsLookAtPredicate extends gameinteractionsIPredicateType {
  native let testTarget: gameinteractionsELookAtTarget;
  native let testType: gameinteractionsELookAtTest;
  native let stopOnTransparent: Bool;
}

public native class gameinteractionsOnScreenTestPredicate extends gameinteractionsIPredicateType {}

public native class gameinteractionsOrbActivationPredicate extends gameinteractionsIPredicateType {}

public native struct gameinteractionsOrbID {
  native let id: Uint32;
}

public native class gameinteractionsPieDefinition extends gameinteractionsIShapeDefinition {
  native let center: Vector4;
  native let baseLength: Float;
  native let halfExtentZ: Float;
  native let radius: Float;
  native let angle: Float;
}

public abstract native struct gameinteractionsPublisherBaseEvent {}

public native class gameinteractionsSuppressedPredicate extends gameinteractionsIPredicateType {}

public native class gameinteractionsvisDeviceVisualizerDefinition extends gameinteractionsvisIVisualizerDefinition {
  native let interactionType: gameinteractionsvisInteractionType;
  native let displayNameOverride: String;
  native let useDefaultActionMapping: Bool;
  native let createMappin: Bool;
  native let isDynamic: Bool;
  native let timeProvider: ref<IVisualizerTimeProvider>;
}

public native class gameinteractionsvisDeviceVisualizerLogic extends gameinteractionsvisIGroupedVisualizerLogic {}

public native class gameinteractionsvisDialogVisualizerDefinition extends gameinteractionsvisIVisualizerDefinition {
  native let displayNameOverride: String;
  native let useLookAt: Bool;
  native let disableAfterSelectingChoice: Bool;
  native let timeProvider: ref<IVisualizerTimeProvider>;
  native let hubPriority: Uint8;
}

public native class gameinteractionsvisDialogVisualizerLogic extends gameinteractionsvisIGroupedVisualizerLogic {}

public abstract native struct gameinteractionsvisFamilyBase {}

public native class gameinteractionsVisibleTargetPredicate extends gameinteractionsIPredicateType {
  native let stopOnTransparent: Bool;
}

public abstract native class gameinteractionsvisIGroupedVisualizerLogic extends gameinteractionsvisIVisualizerLogicInterface {}

public native struct gameinteractionsvisInteractionDisplayData {
  native let putAction: CName;
  native let wInputKey: EInputKey;
  native let HoldAction: Bool;
  native let calizedName: String;
  native let pe: ChoiceTypeWrapper;
  native let oice: InteractionChoice;
}

enum gameinteractionsvisInteractionType {
  LookAt = 0,
  Proximity = 1,
}

public abstract native class gameinteractionsvisIVisualizerDefinition extends ISerializable {
  native let flags: EVisualizerDefinitionFlags;
}

public abstract native class gameinteractionsvisIVisualizerLogicInterface extends ISerializable {}

public native class gameinteractionsvisLootVisualizerDefinition extends gameinteractionsvisIVisualizerDefinition {}

public native class gameinteractionsvisLootVisualizerLogic extends gameinteractionsvisIVisualizerLogicInterface {}

public native class gameIntervalTimer extends gameBaseTimer {}

public native struct gameInventoryListenerData_Base {}

public abstract native class gameIPhantomEntitySystem extends IGameSystem {}

public abstract native class gameIPopulationSystem extends IGameSystem {}

public abstract native class gameIPuppetUpdaterSystem extends IGameSystem {}

public abstract native class gameIRealTimeEventSystem extends IGameSystem {}

public abstract native class gameIRenderGameplayEffectsManagerSystem extends IGameSystem {}

public abstract native class gameISaveSanitizationForbiddenAreaSystem extends IGameSystem {}

public abstract native class gameISchematicSystem extends IGameSystem {}

public native class gameIShootingAccuracySystem extends IGameSystem {}

public abstract native class gameIStatusComboSystem extends IGameSystem {}

public abstract native class gameIStreamingMonitorSystem extends IGameSystem {}

public native struct gameItemDropStorageInventoryListener {}

public native struct gameItemDropStorageManager {}

public importonly native class gameItemEventsEquippedToObject extends Event {}

public native class gameItemEventsPropagateRenderingPlane extends Event {}

public native class gameItemEventsRemoveActiveItem extends Event {}

public importonly native class gameItemEventsUnequippedFromObject extends Event {}

public native class gameItemEventsUnequipStarted extends Event {}

public native class gameItemFactorySystem extends gameIItemFactorySystem {}

public native struct gameItemFactorySystemPool {}

public native class gameItemsMeshesLoaded extends Event {}

public abstract native class gameITimeState extends ISerializable {}

public abstract native class gameITransformAnimatorSaveSystem extends IGameSystem {}

public abstract native class gameITransformsHistorySystem extends IGameSystem {}

public abstract native class gameITriggerDestructionComponent extends IComponent {
  native let startActive: Bool;
}

public abstract native class gameIWorldBoundarySystem extends IGameSystem {}

public native class gameJoinTrafficSettings extends ISerializable {}

public abstract native class gameJournalBaseResource extends CResource {}

public native struct gameJournalChoiceEntryData {
  native let entryPath: ref<gameJournalPath>;
}

public native class gameJournalDescriptorResource extends gameJournalBaseResource {
  native let entriesActivatedAtStart: array<String>;
}

public native struct gameJournalEntryStateChangeDelayData {
  native let entryPath: ref<gameJournalPath>;
  native let entryType: CName;
  native let oldState: gameJournalEntryState;
  native let newState: gameJournalEntryState;
  native let notifyOption: JournalNotifyOption;
  native let changeType: JournalChangeType;
  native let delay: Float;
}

enum gameJournalEntryUserState {
  Undefined = 0,
  Inactive = 1,
  Active = 2,
  Succeeded = 3,
  Failed = 4,
  Read = 5,
  Open = 6,
}

public native struct gameJournalEntryVisitedStatusData {
  native let entryPath: ref<gameJournalPath>;
  native let entryType: CName;
  native let isVisited: Bool;
}

public native class gameJournalFolderEntry extends JournalContainerEntry {}

public native class gameJournalManagerSharedState extends gameIGameSystemReplicatedState {
  native let entryData: array<gameJournalSharedStateData>;
  native let trackedQuestPath: Uint32;
}

public native class gameJournalPrimaryFolderEntry extends gameJournalFolderEntry {}

public native struct gameJournalQuestObjectiveCounterData {
  native let entryPath: ref<gameJournalPath>;
  native let oldValue: Int32;
  native let newValue: Int32;
}

public native class gameJournalResource extends gameJournalBaseResource {
  native let entry: ref<JournalEntry>;
}

public native class gameJournalRootFolderEntry extends gameJournalFolderEntry {
  native let descriptor: ResourceAsyncRef; // raRef<gameJournalDescriptorResource>
}

public native struct gameJournalSharedStateData {
  native let pathHash: Uint32;
  native let entryState: gameJournalEntryState;
}

public native class gameJournalTree extends ISerializable {
  native let rootEntries: array<ref<gameJournalRootFolderEntry>>;
}

public native class gameKillTriggerNode extends worldAreaShapeNode {}

public native class gameKillTriggerNodeInstance extends worldAreaShapeNodeInstance {}

public native class gameLadderComponent extends IComponent {
  native let heightOfBottomPart: Float;
  native let exitStepTop: Float;
  native let verticalStepTop: Float;
  native let exitStepBottom: Float;
  native let verticalStepBottom: Float;
  native let exitStepJump: Float;
  native let verticalStepJump: Float;
  native let enterOffset: Float;
}

public native class gameLadderObject extends GameObject {
  native let heightOfBottomPart: Float;
  native let exitStepTop: Float;
  native let verticalStepTop: Float;
  native let exitStepBottom: Float;
  native let verticalStepBottom: Float;
  native let exitStepJump: Float;
  native let verticalStepJump: Float;
  native let enterOffset: Float;
}

public native struct gameLastHitData {
  native let targetEntityId: EntityID;
  native let hitType: Uint32;
  native let hitShapes: array<CName>;
}

public native class gameLocationPrefabMetadata extends worldPrefabMetadata {
  native let tags: array<CName>;
  native let ignoreParentPrefabs: Bool;
}

public native class gameLocationResource extends CResource {}

public native class gameLootBagInventoryListener extends InventoryListener {}

public native class gameLootPrefabMetadata extends worldPrefabMetadata {
  native let lootTableTDBIDs: array<TweakDBID>;
  native let ignoreParentPrefabs: Bool;
  native let contentAssignment: TweakDBID;
}

public native class gameLootResource extends CResource {
  native let data: ref<gameLootResourceData>;
}

public native class gameLootResourceData extends ISerializable {
  native let version: Uint32;
}

public native class gameLootSlot extends gameLootContainerBase {
  native let immovableAfterDrop: Bool;
  native let dropChance: Float;
}

public native class gameLootSlotSingleAppearance extends gameLootSlotSingleItem {
  native let lootAppearance: CName;
}

public native class gameLootSlotSingleItem extends gameLootSlot {
  native let itemTDBID: TweakDBID;
}

public native class gameLootSlotSingleItemLongStreaming extends gameLootSlotSingleItem {}

public native class gameLootSlotSingleQuery extends gameLootSlot {
  native let queryTDBID: TweakDBID;
}

public native class gameMappinResource extends CResource {
  native let cookedData: array<gameCookedMappinData>;
  native let cookedMultiData: array<gameCookedMultiMappinData>;
  native let cookedGpsData: array<gameCookedGpsMappinData>;
}

public native class gamemappinsCommonVariant extends gamemappinsIPointOfInterestVariant {
  native let variant: gamedataMappinVariant;
}

public native struct gamemappinsDynamicQuestMappinRepInfo {
  native let journalPathHash: Uint32;
  native let entity: wref<Entity>;
}

public abstract native struct gamemappinsIMappinUpdateData {}

public abstract native class gamemappinsIMappinVolume extends ISerializable {}

public abstract native class gamemappinsIPointOfInterestVariant extends ISerializable {}

public abstract native struct gamemappinsIRuntimeMappinData {}

public native class gamemappinsMappinSystemReplicatedState extends gameIGameSystemReplicatedState {
  native let mappinState: array<NewMappinID>;
  native let mappinWithJournalState: array<Uint32>;
}

public native class gamemappinsOutlineMappinVolume extends gamemappinsIMappinVolume {
  native let height: Float;
  native let outlinePoints: array<Vector2>;
}

public native class gamemappinsPhaseVariant extends gamemappinsIPointOfInterestVariant {
  native let phase: gamedataMappinPhase;
  native let variant: gamedataMappinVariant;
}

public native struct gamemappinsQuestMappinManagerReplicatedState {
  native let dynamicQuestMappinRepInfo: array<gamemappinsDynamicQuestMappinRepInfo>;
}

public native class gamemappinsStealthMappinStatsListener extends IStatsListener {}

public native struct gameMountDescriptor {
  native let parentId: EntityID;
  native let slotName: CName;
  native let initialTransform: Transform;
  native let state: PuppetVehicleState;
  native let mountType: MountDescriptor_MountingType;
}

public abstract native class gamemountingIMountingPublisher extends IGameSystem {}

public native class gamemountingMountingFacility extends IMountingFacility {}

public native class gamemountingMountingFacilitySharedState extends ISerializable {
  native let children: array<wref<Entity>>;
  native let parents: array<wref<Entity>>;
  native let slotIds: array<MountingSlotId>;
  native let parentTypes: array<gameMountingObjectType>;
  native let childTypes: array<gameMountingObjectType>;
}

public native class gamemountingMountingPublisher extends gamemountingIMountingPublisher {}

public native class gameMovingPlatformMountableComponent extends MountableComponent {}

public native class gameMovingPlatformRestoreMoveTo extends MoveTo {}

public native struct gameMovingPlatformSavedData {
  native let currentLocalPosition: Vector4;
  native let movement: ref<IMovingPlatformMovement>;
  native let destinationName: CName;
  native let destinationData: Int32;
  native let time: Float;
  native let maxTime: Float;
  native let mountedPlayerEntityID: Uint32;
  native let isPaused: Bool;
}

public native class gameMovingPlatformsSavedState extends ISerializable {
  native let mapping: array<EntityID>;
  native let data: array<gameMovingPlatformSavedData>;
}

public native struct gameMuppetAbilities {
  native let canLook: gameMuppetAbility;
  native let canMove: gameMuppetAbility;
  native let canCrouch: gameMuppetAbility;
  native let canSprint: gameMuppetAbility;
  native let canSwitchWeapon: gameMuppetAbility;
  native let canHoldWeapon: gameMuppetAbility;
  native let canShoot: gameMuppetAbility;
  native let canAimDownSight: gameMuppetAbility;
}

public native struct gameMuppetAbility {
  native let value: Int32;
  native let blocks: Int32;
}

public native struct gameMuppetComparisonReportItem {
  native let type: gameMuppetComparisonReportItemType;
  native let propertyName: String;
  native let serverValue: String;
  native let clientValue: String;
}

enum gameMuppetComparisonReportItemType {
  Different = 0,
  WithinTolerance = 1,
  Equal = 2,
}

public native struct gameMuppetCompressedInputStates {
  native let usesCompression: Bool;
  native let compressedInputStates: array<Uint8>;
  native let firstFrameId: Uint32;
  native let replicationTime: netTime;
}

public native struct gameMuppetControllerSnapshot {
  native let controllerId: CName;
  native let isActive: Bool;
}

public native struct gameMuppetControllersSnapshot {
  native let controllers: array<gameMuppetControllerSnapshot>;
}

enum gameMuppetDebugCommand {
  None = 0,
  Kill = 1,
  KillAll = 2,
}

public native class gameMuppetDebugState extends ISerializable {
  native let comparisonReports: array<gameMuppetStateComparisonReport>;
  native let comparisonReportIndex: Uint32;
  native let subStepsData: array<gameMuppetSubStepData>;
}

public native struct gameMuppetHealthState {
  native let health: Float;
}

public native struct gameMuppetHighLevelState {
  native let isDead: Bool;
  native let deathFrameId: Uint32;
}

enum gameMuppetInputActionType {
  Unknown = 0,
  Impulse = 1,
  Press = 2,
}

public native struct gameMuppetInputState {
  native let frameId: Uint32;
}

public native class gameMuppetInventoryGameController extends inkHUDGameController {}

public native struct gameMuppetInventorySlotInfo {
  native let itemCategory: TweakDBID;
  native let itemId: ItemID;
  native let quantity: Uint32;
}

public native struct gameMuppetInventoryState {
  native let slots: array<gameMuppetInventorySlotInfo>;
  native let activeSlot: Int32;
}

public native class gameMuppetLoadoutsGameController extends inkHUDGameController {}

public native struct gameMuppetLookState {
  native let lookDir: EulerAngles;
}

public native struct gameMuppetMoveState {
  native let desiredSpeed: Float;
  native let isJumping: Bool;
  native let isFalling: Bool;
  native let isDoubleJumped: Bool;
  native let moveStyle: gameMuppetMoveStyle;
  native let jumpStartFrameId: Uint32;
  native let landFrameId: Uint32;
}

enum gameMuppetMoveStyle {
  Invalid = 0,
  Walk = 1,
  Sprint = 2,
  Crouch = 3,
  WalkAim = 4,
  GravityOnly = 5,
}

public native struct gameMuppetPhysicalState {
  native let position: Vector4;
  native let worldYaw: Float;
  native let velocity: Vector4;
  native let isOnGround: Bool;
  native let groundNormal: Vector4;
}

public native struct gameMuppetScanningState {
  native let isScanning: Bool;
}

public native struct gameMuppetState {
  native let frameId: Uint32;
  native let highLevelState: gameMuppetHighLevelState;
  native let healthState: gameMuppetHealthState;
  native let physicalMoveState: gameMuppetPhysicalState;
  native let lookState: gameMuppetLookState;
  native let moveState: gameMuppetMoveState;
  native let upperBodyState: gameMuppetUpperBodyState;
  native let scanningState: gameMuppetScanningState;
  native let inventoryState: gameMuppetInventoryState;
  native let abilities: gameMuppetAbilities;
  native let stateMachinesSnapshot: gameMuppetStateMachinesSnapshot;
  native let controllersSnapshot: gameMuppetControllersSnapshot;
  native let snapFrameId: Uint32;
}

public native struct gameMuppetStateComparisonReport {
  native let frameID: Uint32;
  native let items: array<gameMuppetComparisonReportItem>;
}

public native struct gameMuppetStateMachineSnapshot {
  native let stateMachineId: CName;
  native let stateId: CName;
}

public native struct gameMuppetStateMachinesSnapshot {
  native let stateMachines: array<gameMuppetStateMachineSnapshot>;
}

public native struct gameMuppetStates {}

public native struct gameMuppetSubStepData {
  native let frameId: Uint32;
  native let parentFrameId: Uint32;
  native let parentFramePrimaryColor: Bool;
  native let inputState: gameMuppetInputState;
  native let state: gameMuppetState;
  native let resimulationSubsteps: array<gameMuppetSubStepData>;
}

public native struct gameMuppetUpperBodyState {
  native let currentWeapon: ItemID;
  native let wantedWeapon: ItemID;
  native let inProgressWeapon: ItemID;
  native let logicWantedWeapon: ItemID;
  native let equippingTransitionTime: Float;
  native let remainingShotTime: Float;
  native let timeTillNextShootSeconds: Float;
  native let isAimingDownSight: Bool;
  native let currentWeaponAmmo: Int32;
  native let currentWeaponAmmoCapacity: Int32;
  native let isShooting: Bool;
  native let weaponZoomLevel: Float;
  native let weaponAimFOV: Float;
  native let remainingReloadTime: Float;
  native let remainingReloadCooldownTime: Float;
  native let shotsMade: Uint32;
  native let isMeleeAttackInProgress: Bool;
  native let meleeAttacksMade: Uint32;
  native let meleeAttackIndex: Int32;
  native let remainingMeleeAttackDuration: Float;
  native let selectedConsumable: ItemID;
  native let consumableInUse: Bool;
  native let consumableEffectApplied: Bool;
  native let consumableUseTimeStartup: Float;
  native let consumableUseTimeRecovery: Float;
  native let remainingQuickMeleeTime: Float;
  native let remainingQuickMeleeCooldownTime: Float;
}

public native class gameNarrationPlateBlackboardUpdater extends ISerializable {}

public native struct gameNetAIState {
  native let value: Int32;
  native let prevValue: Int32;
  native let time: Float;
}

public native struct gameNetrunnerPrototypeStruct {
  native let key: CName;
  native let entityTemplate: ResourceAsyncRef; // raRef<entEntityTemplate>
}

public native class gameNPCHealthStatPoolsListener extends gamePuppetStatPoolsListener {}

public native class gameNPCQuickHackUploadStatPoolsListener extends gamePuppetStatPoolsListener {}

public native class gameNPCStatsListener extends gamePuppetStatsListener {}

public native class gameObjectDeathListener extends IStatPoolsListener {}

public native class gameObjectMountableComponent extends MountableComponent {}

public abstract native class gameObjectSpawnParameter extends ISerializable {}

public native class gameObjectSpawnParametersList extends gameObjectSpawnParameter {
  native let parameterList: array<ref<gameObjectSpawnParameter>>;
}

public native class gameOccupantSlotComponent extends SlotComponent {
  native let slotData: array<gameOccupantSlotData>;
}

public importonly native struct gameOccupantSlotData {
  native let slotName: CName;
  native let syncAnimationTag: CName;
  native let workSpotResource: ResourceRef; // rRef<workWorkspotResource>
  native let exitOffsetFromSlot: Vector4;
  native let role: gameMountingSlotRole;
}

public abstract importonly native struct gameOnExecutionContext {}

public native struct gamePatrolSplineControlPoint {}

public native class gamePersistentStateDataResource extends CResource {}

public native class gamePhantomEntityComponent extends IComponent {
  native let params: gamePhantomEntityParameters;
  native let effectBinding: ref<gameEffectComponentBinding>;
}

public native struct gamePhantomEntityParameters {
  native let teleportStartEffect: CName;
  native let teleportEndEffect: CName;
  native let spawnEffect: CName;
  native let glitchEffect: CName;
  native let phantomVisibleStates: array<gamePhantomEntityState>;
  native let blendableAppearanceMatches: array<gamePhantomEntityParametersBlendableAppearanceMatch>;
}

public native struct gamePhantomEntityParametersBlendableAppearanceMatch {
  native let blendable: CName;
  native let notBlendable: CName;
}

enum gamePhantomEntityState {
  RootMotion = 0,
  Workspot = 1,
  MoveOnSpline = 2,
}

public native class gamePhantomEntitySystem extends gameIPhantomEntitySystem {}

public native class gamePhotoModeAttachmentSlotsListener extends AttachmentSlotsListener {}

public native class gamePhotoModeAutoFocusPositionProvider extends IPositionProvider {}

public native class gamePhotoModeBackgroundCameraComponent extends entCameraComponent {
  native let isEnabled: Bool;
  native let virtualCameraName: CName;
  native let dynamicTextureRes: ResourceAsyncRef; // raRef<DynamicTexture>
  native let env: ResourceRef; // rRef<worldEnvironmentAreaParameters>
  native let params: WorldRenderAreaSettings;
  native let depthCutDistance: Float;
  native let backgroundColor: Color;
  native let overrideBackgroundColor: Bool;
  native let renderSceneLayer: RenderSceneLayer;
  native let streamingDistance: Float;
}

public native class gamePhotoModeCameraObject extends GameObject {}

public native class gamePhotoModeObjectPositionProvider extends IPositionProvider {}

public native struct gamePhotoModeUtils {}

public native class gamePhysicalDestructionListenerComponent extends IComponent {
  native let physicalDestructionComponentName: CName;
  native let thresholdLevels: array<Float>;
}

public native class gamePickupObject extends GameObject {
  native let interactionTag: CName;
}

public native struct gamePingEntry {
  native let owner: wref<GameObject>;
  native let worldPosition: Vector4;
  native let time: netTime;
  native let pingType: gamedataPingType;
  native let hitObject: wref<Entity>;
}

public native class gamePingSystemReplicatedState extends gameIGameSystemReplicatedState {
  native let replicatedPingEntries: array<gamePingEntry>;
}

public abstract native struct gamePlayer {
  native let peerID: netPeerID;
  native let nickname: String;
}

public native class gameplayeractionsAttachSlotListener extends AttachmentSlotsListener {}

public native class gamePlayerArmorStatPoolsListener extends gamePuppetStatPoolsListener {}

public native class gamePlayerCommandConsumerComponent extends IComponent {}

public native class gamePlayerCoverInfo extends IScriptable {}

public native class gamePlayerHealthStatPoolsListener extends gamePuppetStatPoolsListener {}

public native class gamePlayerManager extends gameIPlayerManager {}

public native class gamePlayerReleaseControlAsChild extends Event {}

public native class gamePlayerReleaseControlAsParent extends Event {}

public native struct gamePlayerSocket {}

public native struct gamePlayerSpawnParams {
  native let isSpectator: Bool;
  native let spawnPoint: Transform;
  native let recordId: TweakDBID;
  native let gender: CName;
  native let useSpecifiedStartPoint: Bool;
  native let spawnTags: redTagList;
  native let nickname: String;
}

public native class gamePlayerStatsListener extends gamePuppetStatsListener {}

public native class gamePlayerTakeControlAsChild extends Event {}

public native class gamePlayerTakeControlAsParent extends Event {}

public native class gamePlayerTierComponent extends IComponent {}

public native struct GameplayFunctionalTestReturnValue {
  native let value: String;
  native let errorInfo: String;
}

public native class gamePointOfInterestMappinResource extends CResource {
  native let cookedData: array<gameCookedPointOfInterestMappinData>;
}

enum gamePopulationEntityPriority {
  Quest = 0,
  Community = 1,
  Crowd = 2,
}

public native class gamePopulationSystem extends gameIPopulationSystem {}

public native class gamePrepareTPPRepresentationEvent extends Event {}

public native struct gamePrereqDefinition {
  native let prereqName: CName;
  native let prereq: ref<IPrereq>;
}

public native class gamePrereqsResource extends CResource {
  native let prereqs: array<gamePrereqDefinition>;
}

public native class gamePreventionSpawnSystemSavedState extends ISerializable {
  native let areaIds: array<Uint64>;
}

public native class gamePreviewItemData extends gameUniqueItemData {}

enum gameprojectileParabolicUnknownVariable {
  TargetPoint = 0,
  VelocityValue = 1,
  Accel = 2,
}

public importonly native class gameprojectileSpawnerAttachEvent extends Event {
  native let owner: wref<GameObject>;
}

public importonly native class gameprojectileSpawnerAttachExistingEvent extends Event {
  native let projectile: wref<GameObject>;
  native let owner: wref<GameObject>;
}

public native struct gameprojectileVelocityParams {
  native let xFactor: Float;
  native let yFactor: Float;
  native let zFactor: Float;
}

enum gamePSMCover {
  Any = -1,
  Default = 0,
  InCover = 1,
  Peek = 2,
  Lean = 3,
  OutOfCover = 4,
}

public abstract native class gamePuppetStatPoolsListener extends IStatPoolsListener {}

public abstract native class gamePuppetStatsListener extends IStatsListener {}

public native class gamePuppetStatusEffectListener extends IStatusEffectListener {}

public native class gamePuppetTriggerDestructionComponent extends gameITriggerDestructionComponent {
  native let projectionDist: Float;
}

public native class gamePuppetUpdaterSystem extends gameIPuppetUpdaterSystem {}

enum gameQuestGuidanceMarkerPathfindingType {
  Auto = 0,
  Navmesh = 1,
  Traffic = 2,
}

public native class gameQuestOrSceneSetVehiclePhysicsActive extends Event {}

public native class gameRandomStatModifierData extends gameStatModifierData {
  native persistent let value: Float;
}

public native struct gameRazerChromaAnimation {
  native let id: Int32;
  native let name: CName;
}

public native class gameRazerChromaAnimationDatabase extends CResource {
  native let setsSerialized: array<gameRazerChromaAnimationSet>;
}

public native struct gameRazerChromaAnimationSet {
  native let name: CName;
  native let animations: array<gameRazerChromaAnimation>;
}

public native class gameRealTimeEventSystem extends gameIRealTimeEventSystem {}

public native class gameRecordIdSpawnModifier extends populationModifier {}

public native class gameRegular1v1FinisherScenario extends gameIFinisherScenario {
  native let attackerWorkspot: ResourceAsyncRef; // raRef<workWorkspotResource>
  native let targetWorkspot: ResourceAsyncRef; // raRef<workWorkspotResource>
  native let syncData: array<gameFinisherSyncData>;
  native let targetPlaybackDelay: Float;
  native let targetBlendTime: Float;
  native let attackerPlaybackDelay: Float;
  native let attackerBlendTime: Float;
  native let pivotSettings: gameRegular1v1FinisherScenarioPivotSetting;
  native let attackerIsMaster: Bool;
  native let targetSlotNameToAttachAttackerWeaponLeft: CName;
}

enum gameRegular1v1FinisherScenarioPivotSetting {
  AttackerSlidesAndRotates_TargetStandsStill = 0,
  AttackerStandsStill_TargetSlidesAndRotates = 1,
}

public native class gameRemains extends GameObject {}

public native class gameRemoveCooldownEvent extends gameCooldownSystemEvent {}

public native class gameRenderGameplayEffectsManagerSaveData extends ISerializable {
  native let cyberspacePixelsortParams: gameCyberspacePixelsortEffectParams;
  native let cyberspacePixelsortEnabled: Bool;
  native let enforceScreenSpaceReflectionsUberQuality: Bool;
}

public native class gameRenderGameplayEffectsManagerSystem extends gameIRenderGameplayEffectsManagerSystem {}

public native struct gameReplAnimTransformRequestBase {
  native let applyServerTime: netTime;
}

public native struct gameReplAnimTransformSyncElem {
  native let definitionId: Int32;
  native let currentTime: Float;
  native let timeScale: Float;
  native let duration: Float;
  native let timesToPlay: Int32;
  native let playing: Bool;
}

public native struct gameReplicatedAnimControllerEventsState {
  native let items: array<gameReplicatedAnimEvent>;
  native let lastAppliedActionsTime: netTime;
}

public native struct gameReplicatedContinuousAttack {
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let attackId: TweakDBID;
}

public native struct gameReplicatedEntityEventsState {
  native let items: array<gameReplicatedEntityEvent>;
  native let lastAppliedActionsTime: netTime;
}

public native struct gameReplicatedShotData {
  native let timeStamp: netTime;
  native let attackId: TweakDBID;
  native let target: wref<GameObject>;
  native let targetLocalOffset: Vector3;
}

public native class gameRootTransformAnimatorComponent extends entIMoverComponent {
  native let animations: array<gameTransformAnimationDefinition>;
}

public native class gameRuntimeSystemLights extends worldIRuntimeSystem {}

public native class gameSavedPatrolProgressState extends ISerializable {
  native persistent let entrySplineParam: Float;
  native persistent let entrySectionIndex: Uint32;
  native persistent let controlPointIndex: Uint32;
  native persistent let splineEntryPosition: Vector3;
  native persistent let splineEntryTangent: Vector3;
  native persistent let isSplineReversed: Bool;
  native persistent let currentDestinationPosition: Vector3;
  native persistent let currentDestinationTangent: Vector3;
}

public importonly native struct gameSavedStatsData {
  native let statModifiers: array<ref<gameStatModifierData>>;
  native let inactiveStats: array<gamedataStatType>;
  native let recordID: TweakDBID;
  native let seed: Uint32;
}

public native class gameScanningControllerReplicatedState extends ISerializable {
  native let taggedObjectIDs: array<EntityID>;
}

public native class gameScanningControllerSaveData extends ISerializable {
  native let taggedObjectIDs: array<EntityID>;
}

public native class gameScanningInternalEvent extends Event {}

enum gameSceneAnimationMotionActionParamsEasingType {
  Linear = 0,
  SinusoidalEaseInOut = 1,
  QuadraticEaseIn = 2,
  QuadraticEaseOut = 3,
  CubicEaseInOut = 4,
  CubicEaseIn = 5,
  CubicEaseOut = 6,
}

enum gameSceneAnimationMotionActionParamsMotionType {
  Rid = 0,
  Anim = 1,
}

public native struct gameScenePlayerAnimationParams {}

public native class gameScreenshot360CameraComponent extends CameraComponent {}

public native class gameSetDestinationActionEvent extends ActionEvent {
  native let position: Vector3;
}

public native class gameSetupControlledByStoryEvent extends AIEvent {}

public native class gameShootingAccuracySystem extends gameIShootingAccuracySystem {}

public native class gameShootingSpotDefinition extends gameCoverDefinition {}

public native struct gameSignalId {
  native let value: Uint16;
}

public abstract native class gameSignalPriorityDefinition extends ISerializable {
  native let defaultPriority: Uint16;
}

public native class gameSimpleOccupantSlotSpawner extends IComponent {}

public native class gameSimpleSpecificStatListener extends ISerializable {}

public native class gameSimpleStatPoolDataModifierStatListener extends gameStatPoolDataModifierStatListener {}

public native class gameSmartObjectAnimationDatabase extends ISerializable {
  native let animationData: array<gameAnimationExtractedData>;
  native let bodyTypesData: array<gameBodyTypeData>;
}

public native class gameSmartObjectDefinition extends ISerializable {
  native let resource: ResourceRef; // rRef<gameSmartObjectResource>
  native let actions: array<CName>;
  native let motionActionDatabase: ResourceRef; // rRef<animActionAnimDatabase>
  native let enabled: Bool;
  native let overrideGeneratedParameters: Bool;
}

public native struct gameSmartObjectGate {
  native let animationName: CName;
  native let movementType: moveMovementType;
  native let movementOrientationType: moveMovementOrientationType;
}

public abstract native struct gameSmartObjectInstance {}

enum gameSmartObjectInstanceEntryType {
  UseEntryAnimation = 0,
  UseLocomotion = 1,
}

public native class gameSmartObjectMembership extends ISerializable {
  native let members: array<gameSmartObjectMembershipMemberShip>;
}

public native struct gameSmartObjectMembershipMemberShip {
  native let hash: Uint64;
  native let index: Uint32;
}

public native struct gameSmartObjectPoint {
  native let isReachable: Bool;
}

enum gameSmartObjectPointType {
  Entry = 0,
  Exit = 1,
  Action = 2,
}

public native class gameSmartObjectPropertyDictionary extends ISerializable {
  native let properties: array<gameSmartObjectPropertyDictionaryPropertyEntry>;
}

public native struct gameSmartObjectPropertyDictionaryPropertyEntry {
  native let id: Uint16;
  native let usage: Uint32;
  native let animationName: CName;
  native let sourceAnimset: Uint64;
  native let type: gameSmartObjectPointType;
  native let movementType: moveMovementType;
  native let movementOrientation: moveMovementOrientationType;
  native let isOnNavmesh: Bool;
  native let isReachable: Bool;
  native let overObstacle: Bool;
}

public native class gameSmartObjectResource extends CResource {
  native let entryPoints: array<gameSmartObjectGate>;
  native let exitPoints: array<gameSmartObjectGate>;
  native let bodyTypes: array<gameBodyTypeAnimationDefinition>;
  native let loopAnimations: array<gameSmartObjectGate>;
  native let type: gameSmartObjectType;
}

public native class gameSmartObjectsCompiledResource extends resStreamedResource {
  native let animationDatabase: ref<gameSmartObjectAnimationDatabase>;
  native let compiledNodesData: ref<gameCompiledNodes>;
  native let transformDictionary: ref<gameSmartObjectTransformDictionary>;
  native let propertyDictionary: ref<gameSmartObjectPropertyDictionary>;
  native let transformSequenceDictionary: ref<gameSmartObjectTransformSequenceDictionary>;
  native let soMembership: ref<gameSmartObjectMembership>;
  native let localBoundingBox: Box;
}

public native class gameSmartObjectTransformDictionary extends ISerializable {
  native let transforms: array<gameSmartObjectTransformDictionaryTransformEntry>;
}

public native struct gameSmartObjectTransformDictionaryTransformEntry {
  native let transform: Transform;
  native let usage: Uint32;
  native let id: Uint16;
}

public native class gameSmartObjectTransformSequenceDictionary extends ISerializable {
  native let sequences: array<gameSmartObjectTransformSequenceDictionaryEntry>;
}

public native struct gameSmartObjectTransformSequenceDictionaryEntry {
  native let sequence: array<Uint16>;
  native let id: Uint8;
}

enum gameSmartObjectType {
  Default = 0,
  LadderUp = 1,
  LadderDown = 2,
  JumpOnSameLevel = 3,
  Jump3mUp = 4,
  Jump3mDown = 5,
  Climb110cmUp = 6,
  Climb110cmDown = 7,
  Climb200cmUp = 8,
  Climb200cmDown = 9,
  Climb300cmUp = 10,
  Climb300cmDown = 11,
  Vault10cm = 12,
  Vault40cm = 13,
  Vault100cm = 14,
  ChargedJump400cmUp = 15,
  ChargedJump400cmDown = 16,
  ChargedJump600cmUp = 17,
  ChargedJump600cmDown = 18,
  ChargedJump800cmUp = 19,
  ChargedJump800cmDown = 20,
  ThrusterJumpUp = 21,
  ThrusterJumpDown = 22,
  Climb400cmDown = 23,
  Jump4mDown = 24,
  VaultJump7mDown = 25,
}

public native struct gameSmartObjectVisualData {}

public native class gameSmartObjectWorkspotDefinition extends gameSmartObjectDefinition {
  native let workspotTemplate: ResourceRef; // rRef<workWorkspotResource>
}

public native struct gameSmartObjectWorkspotInstance {}

public native class gameSourceData extends ISerializable {
  native persistent let name: CName;
  native persistent let savable: Bool;
}

enum gameSpawnInViewState {
  default__true_ = 0,
  true = 1,
  false = 2,
}

public native class gameSpawnOccupantsEvent extends Event {}

public native struct gameSpotSequenceCategory {
  native let type: gamedataWorkspotCategory;
  native let probability: Float;
}

public native class gameSquadMemberComponentPS extends GameComponentPS {
  native persistent let entries: array<gameSquadMemberDataEntry>;
}

public native struct gameSquadMemberDataEntry {
  native persistent let squadName: CName;
  native persistent let squadType: AISquadType;
}

public native class gameStackedItemData extends gameItemData {}

public native struct gameStatData {
  native let modifiers: array<gameStatModifierHandle>;
  native let statType: gamedataStatType;
}

public abstract native class gamestateMachineIStateActionDefinition extends ISerializable {}

public abstract native class gamestateMachineIStateMachineBody extends ISerializable {}

public native class gamestateMachineparameterTypeInteractionDescription extends IScriptable {
  native let interactionEntity: wref<Entity>;
  native let interactionType: CName;
}

public native class gamestateMachineplayeractionsActionCharge extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionChargeMax extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionChargeReady extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionCycleTriggerMode extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionDischarge extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionProjectileAttach extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsActionProjectileDetach extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsActionProjectileShowPreview extends gamestateMachineplayeractionsActionCharge {}

public native class gamestateMachineplayeractionsActionReady extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionReload extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionShoot extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsActionWindup extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineplayeractionsClimb extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsEquipItem extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsHighLevelAiControlled extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsLocomotionAir extends gamestateMachineplayeractionsLocomotionSimple {}

public native class gamestateMachineplayeractionsLocomotionBase extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsLocomotionBraindance extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionForceFreeze extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionForceIdle extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionLadder extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionSimple extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionStart extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsLocomotionSwimmingDiving extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionSwimmingStart extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsLocomotionSwimmingSurface extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsLocomotionWallRun extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsUpperBodyBase extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsVault extends gamestateMachineplayeractionsLocomotionBase {}

public native class gamestateMachineplayeractionsVehicleDrive extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsVehicleExiting extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsWeaponActionBase extends gamestateMachineStateActionDefinition {}

public native class gamestateMachineplayeractionsWeaponStart extends gamestateMachineplayeractionsWeaponActionBase {}

public native class gamestateMachineState extends graphGraphNodeDefinition {}

public native class gamestateMachineStateActionDefinition extends gamestateMachineIStateActionDefinition {}

public native struct gamestateMachineStateContext {
  native let snapshot: StateSnapshotsContainer;
  native let permanentParameters: gamestateMachineStateContextParameters;
}

public native struct gamestateMachineStateContextConsumableParameters {}

public native struct gamestateMachineStateContextParameters {}

public native class gamestateMachineStateDefinition extends graphGraphNodeDefinition {}

public native class gamestateMachineStateDefinitionSocketDefinition extends graphGraphSocketDefinition {}

public native class gamestateMachineStateMachine extends graphGraphDefinition {}

public native class gamestateMachineStateMachineBody extends gamestateMachineIStateMachineBody {}

public native class gamestateMachineStateMachineBodyLocomotionTier1 extends gamestateMachineStateMachineBody {}

public native class gamestateMachineStateMachineDefinition extends graphGraphDefinition {}

public native class gamestateMachineStateMachineListDefinition extends IScriptable {
  native let stateMachinesStorage: array<ref<gamestateMachineStateMachineDefinition>>;
}

public native class gamestateMachineStateMachineResource extends graphGraphResource {}

public native class gamestateMachineStateSocketDefinition extends graphGraphSocketDefinition {}

public native class gamestateMachineTransition extends graphGraphConnectionDefinition {
  native let transitionCondition: ref<StateFunctor>;
}

public native class gamestateMachineTransitionDefinition extends graphGraphConnectionDefinition {
  native let priority: Float;
}

enum gameStatIDType {
  EntityID = 0,
  ItemID = 1,
  Invalid = 2,
}

public abstract native struct gameStatModifierBase {}

public native struct gameStatModifierGroup {
  native let statModifierArray: array<gameStatModifierHandle>;
  native let statModifiersLimit: Int32;
  native let statModifiersLimitModifier: TweakDBID;
  native let relatedModifierGroups: array<TweakDBID>;
  native let statModifierGroupRecordID: TweakDBID;
  native let stackCount: Uint16;
  native let drawBasedOnStatType: Bool;
  native let saveBasedOnStatType: Bool;
  native let optimiseCombinedModifiers: Bool;
}

public native struct gameStatModifierHandle {}

public importonly native struct gameStatModifierSave {
  native let statModifierUnions: array<ref<gameStatModifierData>>;
  native let statsObjectID: StatsObjectID;
  native let recordID: TweakDBID;
  native let seed: Uint32;
}

public native struct gameStatPoolData {
  native let ownerID: StatsObjectID;
  native let recordID: TweakDBID;
  native let type: gamedataStatPoolType;
  native let modifiers: [StatPoolModifier; 2];
  native let alternativeModifierRecords: [TweakDBID; 2];
  native let stat: gamedataStatType;
  native let maxValue: Float;
  native let customLimitValue: Float;
  native let changeMode: gameStatPoolDataValueChangeMode;
  native let bonus: Float;
  native let bonusType: gameStatPoolDataBonusType;
  native let currentValue: Float;
  native let modificationDelay: Float;
  native let modificationStatus: gameStatPoolDataStatPoolModificationStatus;
}

enum gameStatPoolDataBonusType {
  None = 0,
  Persistent = 1,
  NonPersistent = 2,
}

public abstract importonly native class gameStatPoolDataModifierStatListener extends IStatsListener {}

enum gameStatPoolDataStatPoolModificationStatus {
  Regeneration = 0,
  Decay = 1,
  NoModification = 2,
}

enum gameStatPoolDataValueChangeMode {
  Normal = 0,
  IncreasingOnly = 1,
  DecreasingOnly = 2,
  NonZero = 3,
}

enum gameStatPoolModifierProperty {
  RangeBegin = 0,
  RangeEnd = 1,
  StartDelay = 2,
  ValuePerSec = 3,
  Enabled = 4,
  DelayOnChange = 5,
  Count = 6,
}

public native struct gameStatPoolModifierRuntimeData {
  native let modifier: StatPoolModifier;
  native let modificationDelay: Float;
  native let inRange: Bool;
  native let recordID: TweakDBID;
}

public native class gameStatPoolsSystemSave extends ISerializable {
  native let mapping: array<StatsObjectID>;
  native let statPools: array<gameStatPoolData>;
}

enum gameStatsBundleOwnerType {
  None = 0,
  Cleared = 1,
  UniqueItem = 2,
  StackableItem = 3,
  InnerItem = 4,
  Entity = 5,
  Stub = 6,
  Reinitialized = 7,
  Count = 8,
  Invalid = 9,
}

public native class gameStatsComponentPS extends GameComponentPS {}

public importonly native struct gameStatsSeedKey {
  native let entityID: EntityID;
  native let recordID: TweakDBID;
  native let seed: Uint32;
}

public importonly native struct gameStatsStateMapStructure {
  native let keys: array<StatsObjectID>;
  native let values: array<gameSavedStatsData>;
}

public importonly native class gameStatsSystemSave extends ISerializable {
  native let statsObjectsData: array<gameStatsSeedKey>;
  native let statModifiersData: array<gameStatModifierSave>;
}

public native class gameStatsUnit extends ISerializable {
  native let recordID: TweakDBID;
}

public native class gameStatusComboSystem extends gameIStatusComboSystem {}

public native class gameStatusEffectComponentPS extends GameComponentPS {
  native persistent let statusEffectArray: array<StatusEffect>;
  native persistent let delayedFunctions: ref<gameDelayedFunctionsScheduler>;
  native persistent let delayedFunctionsNoTd: ref<gameDelayedFunctionsScheduler>;
  native persistent let isPlayerControlled: Bool;
  native persistent let tickComponent: Bool;
}

public native struct gameStatusEffectReplicatedInfo {
  native let statusEffectRecordID: TweakDBID;
  native let stackCount: Uint32;
  native let source: CName;
}

public native class gameStreamingMonitorSystem extends gameIStreamingMonitorSystem {}

public native class gameSubStatModifierData extends gameStatModifierData {
  native persistent let refStatType: gamedataStatType;
}

public native class gameTagSpawParameter extends gameObjectSpawnParameter {
  native let tags: array<CName>;
}

public native class gameTargetingActivatorComponent extends IComponent {}

public native struct gameTargetingComponentData {}

public native class gameTargetingLocalizedEffectComponent extends IComponent {
  native let streamingDistance: Float;
  native let visibleTargetRange: Float;
}

enum gameTelemetryMilestoneType {
  StartFact = 0,
  ImportantFact = 1,
  Reward = 2,
  EndFact = 4,
  EndReward = 3,
  Invalid = 5,
}

public native struct gameTelemetryPostMortem {
  native let crashVisitId: String;
  native let playthroughId: String;
  native let crashVersion: String;
  native let crashPatch: String;
  native let timeCrash: String;
  native let district: String;
  native let zoneType: String;
  native let trackedQuest: gameTelemetryTrackedQuest;
  native let location: Vector3;
  native let sessionLength: Float;
  native let isOom: Bool;
}

public native class gameTelemetryPostMortemContainer extends ISerializable {
  native let postMortem: gameTelemetryPostMortem;
}

public native struct gameTelemetryTrackedQuest {
  native let name: String;
  native let objectiveName: String;
  native let type: String;
  native let distance: Float;
  native let questName: String;
  native let questType: String;
}

public native class gameTierPrereq extends IComparisonPrereq {
  native let tier: GameplayTier;
}

public native class gameTierPrereqState extends PrereqState {}

public native class gameTierSaveData extends ISerializable {
  native let globalTiers: array<gameGlobalTierSaveData>;
}

public native class gameTierSystem extends ITierSystem {}

public native class gameTimeDilationEvent extends Event {}

public native class gameTimeSystemReplicatedState extends gameIGameSystemReplicatedState {
  native let paused: Bool;
  native let gameTime: GameTime;
}

public native struct GameTimeWrapper {
  native let gameTime: GameTime;
}

public native class gameTPPCustomizableAppearanceChangeFinishedEvent extends Event {}

public native struct gameTppRepAttachedObjectInfo {
  native let slotID: TweakDBID;
  native let itemID: TweakDBID;
}

public native class gameTPPRepresentationComponent extends IComponent {
  native let detachedObjectInfo: array<gameFppRepDetachedObjectInfo>;
  native let attachedObjectInfo: array<gameTppRepAttachedObjectInfo>;
  native let affectedAppearanceSlots: array<TweakDBID>;
}

public native class gameTPPRepresentationCustomizationStateUpdater extends gameuiICustomizationStateUpdater {}

public native class gameTPPRepresentationPositionProvider extends IPositionProvider {}

public native class gameTPPRepresentationSlotListener extends AttachmentSlotsListener {}

public native struct gameTrafficLaneSpanInfo {
  native let laneId: worldTrafficLaneUID;
  native let laneX1: Float;
  native let laneX2: Float;
}

public native class gameTrafficWorkspotTransitionData extends ISerializable {
  native let workspotData: ref<SetupWorkspotActionEvent>;
  native let returnPosition: ref<worldTrafficGlobalPathPosition>;
  native let workspotExitTangent: Vector3;
  native let trafficLaneReturnTangent: Vector3;
}

public native class gameTransformAnimation_BreakEffectLoop extends gameTransformAnimation_Effects {
  native let effectTag: CName;
}

public abstract native class gameTransformAnimation_Effects extends gameTransformAnimationTrackItemImpl {}

public native class gameTransformAnimation_KillEffect extends gameTransformAnimation_Effects {
  native let effectTag: CName;
}

public native class gameTransformAnimation_Move extends gameTransformAnimationTrackItemImpl {
  native let startPositionEvaluator: ref<gameTransformAnimation_Position>;
  native let targetPositionEvaluator: ref<gameTransformAnimation_Position>;
  native let movement: ref<gameTransformAnimation_Movement>;
}

public native class gameTransformAnimation_Movement_CurveSet extends gameTransformAnimation_Movement {}

public native class gameTransformAnimation_Movement_CustomCurve extends gameTransformAnimation_Movement {
  native let curve: CurveDataFloat;
}

public native class gameTransformAnimation_Movement_PredefinedFunction extends gameTransformAnimation_Movement {
  native let function: EasingFunction;
}

public abstract native class gameTransformAnimation_Movement extends ISerializable {}

public native class gameTransformAnimation_MoveOnSpline extends gameTransformAnimationTrackItemImpl {
  native let splineNode: NodeRef;
  native let from: Float;
  native let to: Float;
  native let rotationMode: gameTransformAnimation_MoveOnSplineRotationMode;
  native let movement: ref<gameTransformAnimation_Movement>;
}

enum gameTransformAnimation_MoveOnSplineRotationMode {
  Disabled = 0,
  Yaw = 1,
  PitchAndYaw = 2,
}

public native class gameTransformAnimation_PlaySound extends gameTransformAnimationTrackItemImpl {
  native let soundName: CName;
  native let unique: Bool;
}

public native class gameTransformAnimation_Position_InitialPosition extends gameTransformAnimation_Position {
  native let offset: Vector3;
  native let offsetInWorldSpace: Bool;
}

public native class gameTransformAnimation_Position_LocalPosition extends gameTransformAnimation_Position {
  native let position: Vector3;
}

public native class gameTransformAnimation_Position_MarkerPosition extends gameTransformAnimation_Position {
  native let markerNode: NodeRef;
  native let offset: Vector3;
}

public abstract native class gameTransformAnimation_Position extends ISerializable {}

public native class gameTransformAnimation_RotateFromTo extends gameTransformAnimationTrackItemImpl {
  native let startRotationEvaluator: ref<gameTransformAnimation_Rotation>;
  native let targetRotationEvaluator: ref<gameTransformAnimation_Rotation>;
  native let movement: ref<gameTransformAnimation_Movement>;
}

public native class gameTransformAnimation_RotateOnAxis extends gameTransformAnimationTrackItemImpl {
  native let axis: gameTransformAnimation_RotateOnAxisAxis;
  native let numberOfFullRotations: Float;
  native let startAngle: Float;
  native let reverseDirection: Bool;
  native let movement: ref<gameTransformAnimation_Movement>;
}

enum gameTransformAnimation_RotateOnAxisAxis {
  X = 0,
  Y = 1,
  Z = 2,
}

public native class gameTransformAnimation_Rotation_CurrentRotation extends gameTransformAnimation_Rotation {
  native let offset: Quaternion;
}

public native class gameTransformAnimation_Rotation_InitialRotation extends gameTransformAnimation_Rotation {}

public native class gameTransformAnimation_Rotation_LocalRotation extends gameTransformAnimation_Rotation {
  native let rotation: Quaternion;
}

public native class gameTransformAnimation_Rotation_MarkerRotation extends gameTransformAnimation_Rotation {
  native let markerNode: NodeRef;
  native let offset: Vector3;
}

public abstract native class gameTransformAnimation_Rotation extends ISerializable {}

public native class gameTransformAnimation_SpawnEffect extends gameTransformAnimation_Effects {
  native let effectName: CName;
  native let effectTag: CName;
  native let persistOnDetach: Bool;
}

public native struct gameTransformAnimationDefinition {
  native let name: CName;
  native let autoStart: Bool;
  native let autoStartDelay: Float;
  native let timesToPlay: Uint32;
  native let looping: Bool;
  native let timeScale: Float;
  native let reverse: Bool;
  native let timeline: gameTransformAnimationTimeline;
}

public native struct gameTransformAnimationTimeline {
  native let items: array<gameTransformAnimationTrackItem>;
}

public native class gameTransformAnimationTrackItem extends ISerializable {
  native let impl: ref<gameTransformAnimationTrackItemImpl>;
  native let startTime: Float;
  native let duration: Float;
}

public abstract native class gameTransformAnimationTrackItemImpl extends ISerializable {}

public native class gameTransformAnimatorComponent extends IPlacedComponent {
  native let animations: array<gameTransformAnimationDefinition>;
}

public native class gameTransformAnimatorSaveSystem extends gameITransformAnimatorSaveSystem {}

public native class gameTransformsHistorySystem extends gameITransformsHistorySystem {}

enum gameTStatModifier {
  Constant = 0,
  Random = 1,
  Curve = 2,
  Combined = 3,
  Count = 4,
  Invalid = 5,
}

public native class gameuiAdvertLightColorPickerController extends inkLogicController {
  native let lightColor: Color;
}

public native class gameuiarcadeArcadeBackgroundController extends inkLogicController {
  native let backgroundLayerList: array<inkWidgetRef>;
}

public native struct gameuiarcadeArcadeColliderData {
  native let type: gameuiarcadeArcadeColliderType;
  native let shape: ref<gameuiarcadeBoundingShape>;
}

enum gameuiarcadeArcadeColliderType {
  Body = 0,
  Up = 1,
  Right = 2,
  Bottom = 3,
  Left = 4,
}

public native class gameuiarcadeArcadeGameController extends inkGameController {
  native let minigame: gameuiarcadeArcadeMinigame;
  native let defaultScreenTransitionTotalTime: Float;
  native let screenTransitionWidget: inkImageRef;
  native let menu: inkWidgetRef;
  native let gameplay: inkWidgetRef;
  native let scoreboard: inkWidgetRef;
}

public abstract native class gameuiarcadeArcadeGameplayController extends gameuiarcadeIArcadeScreenController {
  native let score: inkWidgetRef;
  native let pauseText: inkWidgetRef;
}

public abstract native class gameuiarcadeArcadeHealthController extends inkLogicController {
  native let widget: wref<inkWidget>;
}

public native class gameuiarcadeArcadeMenuController extends gameuiarcadeIArcadeScreenController {
  native let startArrow: inkWidgetRef;
  native let scoreboardArrow: inkWidgetRef;
}

enum gameuiarcadeArcadeMinigame {
  RoachRace = 0,
  Shooter = 1,
  Tank = 2,
}

public native class gameuiarcadeArcadeObjectController extends inkLogicController {
  native let image: inkWidgetRef;
  native let colliderList: array<gameuiarcadeArcadeColliderData>;
}

public native class gameuiarcadeArcadeParallaxPlaneController extends inkLogicController {
  native let displacementAxis: gameuiarcadeArcadeParallaxPlaneControllerDisplacementAxis;
  native let loopType: gameuiarcadeArcadeParallaxPlaneControllerLoopType;
  native let segmentList: array<inkWidgetRef>;
}

enum gameuiarcadeArcadeParallaxPlaneControllerDisplacementAxis {
  Horizontal = 0,
  Vertical = 1,
}

enum gameuiarcadeArcadeParallaxPlaneControllerLoopType {
  None = 0,
  Repeat = 1,
}

public native class gameuiarcadeArcadePermanentResourceManager extends ISerializable {}

public abstract native class gameuiarcadeArcadePlayerController extends inkLogicController {
  native let colliderList: array<gameuiarcadeArcadeColliderData>;
}

public native class gameuiarcadeArcadeScoreboardController extends gameuiarcadeIArcadeScreenController {
  native let endingPanel: inkWidgetRef;
  native let playerCurrentScore: inkTextRef;
  native let playerHighestScore: inkTextRef;
  native let playerHighestScoreAlert: inkTextRef;
  native let pressToPlayAgainText: inkWidgetRef;
  native let scoreboardNameList: array<inkTextRef>;
  native let scoreboardScoreList: array<inkTextRef>;
}

public native class gameuiarcadeArcadeScoreController extends inkLogicController {
  native let scoreText: inkWidgetRef;
}

public native class gameuiarcadeArcadeSpawnerController extends inkLogicController {
  native let objectLibraryID: CName;
  native let initialObjectsCount: Uint32;
}

public importonly native class gameuiarcadeArcadeSystem extends IGameSystem {}

public native class gameuiarcadeBoundingCircle extends gameuiarcadeBoundingShape {}

public native class gameuiarcadeBoundingRect extends gameuiarcadeBoundingShape {}

public abstract native class gameuiarcadeBoundingShape extends IScriptable {
  native let boundingShape: inkWidgetRef;
}

public abstract native class gameuiarcadeIArcadeScreenController extends inkLogicController {}

public native class gameuiarcadeRoachRaceBackgroundController extends gameuiarcadeArcadeBackgroundController {
  native let parallaxPlaneRelativeVelocityList: array<Float>;
  native let daynightWidget: inkWidgetRef;
  native let backgroundObjectSpawner: inkWidgetRef;
  native let cloudSpawner: inkWidgetRef;
}

public native class gameuiarcadeRoachRaceCloudSpawnerController extends gameuiarcadeArcadeSpawnerController {
  native let minCloudRelativeVelocity: Float;
  native let maxCloudRelativeVelocity: Float;
  native let cloudSpawnTime: Float;
}

public native class gameuiarcadeRoachRaceCollisionSystem extends IScriptable {}

public native class gameuiarcadeRoachRaceGameplayController extends gameuiarcadeArcadeGameplayController {
  native let defaultWorldVelocity: Float;
  native let cycleWorldVelocityMultiplier: Float;
  native let carrotPowerupPointsPerSecond: Float;
  native let carrotPowerupTime: Float;
  native let carrotPowerupWorldVelocityMultiplier: Float;
  native let collisionSFX: CName;
  native let powerupPickupSFX: CName;
  native let player: inkWidgetRef;
  native let obstacleSpawner: inkWidgetRef;
  native let background: inkWidgetRef;
  native let currentLevelAndCycleText: inkTextRef;
  native let pointsBoostPickupText: inkTextRef;
  native let dummy: inkWidgetRef;
  native let invincibilityCooldownIndicator: inkWidgetRef;
}

enum gameuiarcadeRoachRaceObjectType {
  BoostObject_Apple = 0,
  BoostObject_Carrot = 1,
  Obstacle = 2,
}

public native class gameuiarcadeRoachRaceObstacleController extends gameuiarcadeArcadeObjectController {}

public native class gameuiarcadeRoachRaceObstacleSpawnerController extends gameuiarcadeArcadeSpawnerController {
  native let initialMinimumSpawnTime: Float;
  native let initialDoubleSpawnChance: Float;
  native let spawnRateIncreasePerCycle: Float;
  native let doubleSpawnChanceIncreasePerLevel: Float;
  native let doubleSpawnDelay: Float;
  native let powerupSpawnTimeDelayMultiplier: Float;
  native let appleSpawnTime: Float;
  native let carrotSpawnTime: Float;
}

public native class gameuiarcadeRoachRacePlayerController extends inkLogicController {
  native let singleJumpBoost: Vector2;
  native let doubleJumpBoost: Vector2;
  native let gravity: Vector2;
  native let teleportLockoutTime: Float;
  native let carrotPowerupVelocityBoostModifier: Float;
  native let runningBoundingRectangleRelativeSize: Vector2;
  native let jumpingboundingRectangleRelativeSize: Vector2;
  native let poweredupboundingRectangleRelativeSize: Vector2;
  native let invincibilityTime: Float;
  native let invincibilityWarningTime: Float;
  native let roachDeathAnimationTime: Float;
  native let roachDeathAnimationDisplacement: Float;
  native let image: inkImageRef;
  native let jumpSFX: CName;
  native let doubleJumpSFX: CName;
  native let teleportSFX: CName;
  native let invincibilityStartSFX: CName;
  native let invincibilityStopSFX: CName;
  native let carrotPowerupStartSFX: CName;
  native let carrotPowerupStopSFX: CName;
}

public native class gameuiarcadeRoachRaceSceneryObjectSpawnerController extends gameuiarcadeArcadeSpawnerController {
  native let sceneryObjectSpawnTime: Float;
}

public native class gameuiarcadeShooterAIBase extends gameuiarcadeShooterObjectController {}

public native class gameuiarcadeShooterAIController extends gameuiarcadeShooterAIBase {}

public native class gameuiarcadeShooterAIFlyingDroneController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAIMeleeController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAINPCDroneController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAIPickUpTransporterController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAIProp extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAIRangeController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAIRangeGrenadeController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAIRescueTransporterController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAISpiderDroneController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterAITransporterController extends gameuiarcadeShooterAIController {}

enum gameuiarcadeShooterAIType {
  MELEE = 0,
  RANGESHOOTER = 1,
  RANGEGRENADE = 2,
  FLYINGDRONE = 3,
  SPIDERDRONE = 4,
  POWERUPDRONE = 5,
  TRANSPORT = 6,
  VIP = 8,
  VIPPLAT = 9,
  LANDMINE = 12,
  BARREL = 13,
  NINJA = 14,
  BASILISK = 16,
  MEATHEAD = 15,
}

public native class gameuiarcadeShooterAIVIPController extends gameuiarcadeShooterAIController {}

public native class gameuiarcadeShooterArcadeScoreboardController extends gameuiarcadeArcadeScoreboardController {
  native let scoreBackground: inkWidgetRef;
  native let endingScoreBackground: inkWidgetRef;
  native let playerNames: inkWidgetRef;
  native let ranks: inkWidgetRef;
  native let scores: inkWidgetRef;
  native let highestScoreText: inkWidgetRef;
  native let highScoreText: inkWidgetRef;
  native let gameOverImage: inkImageRef;
  native let highestScoreOriginalOffset: Vector2;
  native let highestScoreEndingOffset: Vector2;
  native let highScoreTextOriginalOffset: Vector2;
  native let highScoreTextEndingOffset: Vector2;
  native let rankScoreOriginalOffset: Vector2;
  native let rankScoreEndingOffset: Vector2;
  native let namesOriginalOffset: Vector2;
  native let namesEndingOffset: Vector2;
}

public native class gameuiarcadeShooterBackgroundController extends inkLogicController {
  native let layerInfo: array<gameuiarcadeShooterLayerInfo>;
  native let allowMarginTranslation: Bool;
  native let expPlatformImageDetails: array<gameuiarcadeShooterExplodingPlatformsImageWidgetDetail>;
}

public native class gameuiarcadeShooterBossBasilisk extends gameuiarcadeShooterBossController {}

public native class gameuiarcadeShooterBossController extends gameuiarcadeShooterAIBase {
  native let customBoundSize: Bool;
  native let bossSize: Vector2;
}

public native class gameuiarcadeShooterBossMeatHead extends gameuiarcadeShooterBossController {}

public native class gameuiarcadeShooterBossNinja extends gameuiarcadeShooterBossController {}

public native class gameuiarcadeShooterBullet extends gameuiarcadeShooterObjectController {
  native let customBoundSize: Bool;
  native let boundSize: Vector2;
}

public native class gameuiarcadeShooterBulletSpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native class gameuiarcadeShooterCollisionController extends inkLogicController {
  native let explosionPlatformDelay: Float;
  native let respawnPlatformDetails: array<gameuiarcadeShooterExplodingPlatformSpawnDetail>;
}

public native struct gameuiarcadeShooterEventData {
  native let triggerPosition: Vector2;
  native let finalPosition: Vector2;
  native let spawnerDataList: array<gameuiarcadeShooterEventSpawnerData>;
}

public native class gameuiarcadeShooterEventManager extends inkLogicController {
  native let nextLevelThreshold: Vector2;
  native let levelEndCheckDelay: Float;
  native let eventFinishDelay: Float;
  native let eventId: Int32;
  native let eventList: array<gameuiarcadeShooterEventData>;
}

public native struct gameuiarcadeShooterEventSpawnerData {
  native let dataName: CName;
  native let targetSpawner: inkWidgetRef;
  native let tiedSpawner: inkWidgetRef;
  native let triggerCondition: gameuiarcadeShooterTriggerType;
  native let delayDuration: Float;
}

public native struct gameuiarcadeShooterExplodingPlatformsImageWidgetDetail {
  native let platformName: CName;
  native let platformImageDetails: array<gameuiarcadeShooterPlatformImageDetail>;
}

public native struct gameuiarcadeShooterExplodingPlatformSpawnDetail {
  native let spawnPlatformName: CName;
  native let explodingPlatformsNames: array<CName>;
}

public native class gameuiarcadeShooterGameController extends gameuiarcadeArcadeGameController {}

public native class gameuiarcadeShooterGameplayController extends gameuiarcadeArcadeGameplayController {
  native let player: inkWidgetRef;
  native let hud: inkWidgetRef;
  native let levelContainer: inkWidgetRef;
}

public native class gameuiarcadeShooterHealthController extends gameuiarcadeArcadeHealthController {}

public native class gameuiarcadeShooterHUDController extends inkLogicController {
  native let selectedWeaponSlot: inkImageRef;
  native let secondWeaponSlot: inkImageRef;
  native let thirdWeaponSlot: inkImageRef;
  native let healthContainer: inkWidgetRef;
  native let continueText: inkWidgetRef;
  native let continueCountdownWidget: inkImageRef;
  native let levelName: inkImageRef;
  native let levelNumber1: inkImageRef;
  native let levelNumber2: inkImageRef;
  native let levelFinishCard: inkWidgetRef;
}

public native struct gameuiarcadeShooterLayerInfo {
  native let referenceWidget: inkWidgetRef;
  native let planeRelativeValue: Vector2;
  native let layerName: CName;
}

public native class gameuiarcadeShooterLevelController extends inkLogicController {
  native let playerSpawnPoint: inkWidgetRef;
  native let background: inkWidgetRef;
  native let collision: inkWidgetRef;
  native let levelType: gameuiarcadeShooterLevelType;
  native let spawner: inkWidgetRef;
  native let enemyBulletSpawner: inkWidgetRef;
  native let playerBulletSpawner: inkWidgetRef;
  native let vfxSpawner: inkWidgetRef;
  native let mapEndBorder: Vector2;
}

enum gameuiarcadeShooterLevelType {
  HORIZONTAL = 0,
  VERTICALUP = 1,
  VERTICALDOWN = 2,
}

public native class gameuiarcadeShooterObjectController extends gameuiarcadeArcadeObjectController {}

public native class gameuiarcadeShooterPlatformCollisionController extends inkLogicController {}

public native class gameuiarcadeShooterPlatformController extends gameuiarcadeShooterObjectController {}

public native struct gameuiarcadeShooterPlatformImageDetail {
  native let platformImage: inkWidgetRef;
}

public native class gameuiarcadeShooterPlayerLevelTransitionController extends inkLogicController {}

public native class gameuiarcadeShooterPowerup extends gameuiarcadeShooterObjectController {}

public native class gameuiarcadeShooterSpawnController extends inkLogicController {
  native let enemyType: gameuiarcadeShooterAIType;
  native let spawnCondition: gameuiarcadeShooterSpawnerCondition;
  native let spawnDelay: Float;
  native let spawnCount: Uint32;
  native let offScreenSpawnExpiryTime: Float;
  native let skippable: Bool;
  native let skipOffset: Float;
  native let awaitPreviousUnitDead: Bool;
  native let enemyParameter: String;
}

enum gameuiarcadeShooterSpawnerCondition {
  ScreenLeft = 0,
  ScreenRight = 1,
  ScreenTop = 2,
  ScreenBottom = 3,
  EventTrigger = 4,
}

public native class gameuiarcadeShooterSpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native struct gameuiarcadeShooterTransporterSpawnData {
  native let aiType: gameuiarcadeShooterAIType;
  native let parameter: CName;
  native let count: Int32;
}

public native class gameuiarcadeShooterTransporterSpawnerController extends inkLogicController {
  native let spawnDelay: Float;
  native let isRandomSpawn: Bool;
  native let choosenMounts: array<gameuiarcadeShooterTransporterSpawnData>;
  native let choosenOnes: array<gameuiarcadeShooterTransporterSpawnData>;
}

public native class gameuiarcadeShooterTraumaMemberController extends gameuiarcadeShooterObjectController {
  native let baseFollowDelay: Float;
}

enum gameuiarcadeShooterTriggerType {
  Delay = 0,
  SpawnerFinish = 1,
  SpawnerObjectsDeath = 2,
}

public native class gameuiarcadeShooterVFXController extends gameuiarcadeShooterObjectController {}

public native class gameuiarcadeShooterVFXSpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native class gameuiarcadeTankBackgroundController extends gameuiarcadeArcadeBackgroundController {
  native let decorationSpawner: inkWidgetRef;
}

public native class gameuiarcadeTankCounterHUDController extends inkLogicController {
  native let counterText: inkTextRef;
}

public native class gameuiarcadeTankDecorationSpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native class gameuiarcadeTankDestroyableObjectController extends gameuiarcadeArcadeObjectController {}

public native class gameuiarcadeTankEnemyController extends gameuiarcadeTankDestroyableObjectController {
  native let headParent: inkWidgetRef;
  native let head: inkWidgetRef;
}

enum gameuiarcadeTankEnemyMovementType {
  x_axis = 0,
  x_axisL = 1,
  x_axisR = 2,
  y_axis = 3,
}

public native class gameuiarcadeTankEnemySpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native class gameuiarcadeTankGameplayController extends gameuiarcadeArcadeGameplayController {
  native let player: inkWidgetRef;
  native let enemySpawner: inkWidgetRef;
  native let obstacleSpawner: inkWidgetRef;
  native let pickupSpawner: inkWidgetRef;
  native let projectileSpawner: inkWidgetRef;
  native let background: inkWidgetRef;
  native let hudCounter: inkWidgetRef;
  native let hudScoreMultiplier: inkWidgetRef;
}

public native class gameuiarcadeTankObstacleSpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native class gameuiarcadeTankPickupController extends gameuiarcadeArcadeObjectController {
  native let pickup: inkWidgetRef;
  native let pickupText: inkWidgetRef;
}

public native class gameuiarcadeTankPickupSpawnerController extends gameuiarcadeArcadeSpawnerController {}

enum gameuiarcadeTankPickupType {
  Patch_Kit = 0,
  AEAMS = 1,
  Mini_Tank = 2,
  Pile_of_Eddies = 3,
  Pile_of_Guns = 4,
}

public native class gameuiarcadeTankPlayerAEAMSController extends inkLogicController {}

public native class gameuiarcadeTankPlayerController extends gameuiarcadeArcadePlayerController {
  native let avatarRef: inkWidgetRef;
  native let health: inkWidgetRef;
  native let lives: inkWidgetRef;
  native let aeams: inkWidgetRef;
  native let projectileSpawner: inkWidgetRef;
}

public native class gameuiarcadeTankPlayerHealthController extends inkLogicController {
  native let health: inkWidgetRef;
}

public native class gameuiarcadeTankPlayerLivesController extends inkLogicController {}

public native class gameuiarcadeTankProjectileController extends gameuiarcadeArcadeObjectController {}

public native class gameuiarcadeTankProjectileSpawnerController extends gameuiarcadeArcadeSpawnerController {}

public native class gameuiarcadeTankScoreMultiplierHUDController extends inkLogicController {
  native let scoreMultiplierBarFill: inkImageRef;
}

public native class gameuiAttachmentSlotsListener extends AttachmentSlotsListener {}

public native class gameuiAugmentedRealitySignGameController extends inkGameController {}

enum gameuiBaseMenuGameControllerPuppetGenderInfo {
  Male = 0,
  Female = 1,
  ShouldBeDetermined = 2,
}

public native struct gameuiBaseMenuGameControllerPuppetSceneInfo {
  native let sceneName: CName;
  native let markerRef: NodeRef;
  native let prefabRef: NodeRef;
  native let entityTemplate: ResourceAsyncRef; // raRef<entEntityTemplate>
  native let puppetRecordId: TweakDBID;
  native let gender: gameuiBaseMenuGameControllerPuppetGenderInfo;
}

enum gameuiBinkVideoStatus {
  Idle = 0,
  NotStarted = 1,
  Initializing = 2,
  Playing = 3,
  Finished = 4,
  OutOfFrustum = 5,
  Stopped = 6,
  Error = 7,
}

public native class gameuiBodyControllerCustomizationStateUpdater extends gameuiICustomizationStateUpdater {}

public native class gameuiBodyPartsControllerCustomizationStateUpdater extends gameuiICustomizationStateUpdater {}

public native class gameuiBriefingGameController extends inkGameController {
  native let briefingPlayerType: questBriefingPlayerType;
}

public native struct gameuiCensorshipInfo {
  native let censorFlagAction: gameuiCharacterCustomizationActionType;
}

enum gameuiCharacterCustomization_BrokenNoseStage {
  CCBN_Disabled = 0,
  CCBN_Stage1 = 1,
  CCBN_Stage2 = 2,
  CCBN_FinalScene = 3,
}

public native struct gameuiCharacterCustomizationAction {
  native let type: gameuiCharacterCustomizationActionType;
  native let params: String;
  native let applyToUISlot: Bool;
  native let applyImmediately: Bool;
}

enum gameuiCharacterCustomizationActionType {
  Activate = 0,
  Deactivate = 1,
  EquipItem = 2,
  UnequipItem = 3,
  Refresh = 4,
}

public native class gameuiCharacterCustomizationArmCyberwareController extends gameuiCharacterCustomizationBodyPartsController {
  native let defaultGroupName: CName;
  native let additionalCyberArmAppearances: array<ResourceAsyncRef>;
}

public native class gameuiCharacterCustomizationBeardController extends gameuiCharacterCustomizationHeadPartsController {}

public native class gameuiCharacterCustomizationBodyController extends gameuiICharacterCustomizationBodyController {}

public abstract native class gameuiCharacterCustomizationBodyPartsController extends gameuiICharacterCustomizationBodyPartsController {
  native let isHiddenInFpp: Bool;
}

public native class gameuiCharacterCustomizationBrokenNoseController extends gameuiICharacterCustomizationComponent {
  native let stage1App: gameuiCharacterCustomizationBrokenNoseControllerBrokenNoseAppearance;
  native let stage2App: gameuiCharacterCustomizationBrokenNoseControllerBrokenNoseAppearance;
  native let finalSceneGroup: CName;
}

public native struct gameuiCharacterCustomizationBrokenNoseControllerBrokenNoseAppearance {
  native let resource: ResourceAsyncRef; // raRef<appearanceAppearanceResource>
  native let definition: CName;
}

public native class gameuiCharacterCustomizationFaceController extends gameuiCharacterCustomizationHeadPartsController {}

public native class gameuiCharacterCustomizationFeetController extends gameuiCharacterCustomizationBodyPartsController {
  native let liftedFeetGroupName: CName;
  native let flatFeetGroupName: CName;
}

public native class gameuiCharacterCustomizationGenitalsController extends gameuiCharacterCustomizationBodyPartsController {
  native let upperBodyGroupName: CName;
  native let bottomBodyGroupName: CName;
  native let forceHideGenitals: Bool;
}

public native class gameuiCharacterCustomizationHairstyleController extends gameuiCharacterCustomizationHeadPartsController {}

public abstract native class gameuiCharacterCustomizationHeadPartsController extends gameuiCharacterCustomizationBodyPartsController {
  native let groupName: CName;
}

public native class gameuiCharacterCustomizationInfoResource extends CResource {
  native let version: Uint32;
  native let headCustomizationOptions: array<ref<gameuiCharacterCustomizationInfo>>;
  native let bodyCustomizationOptions: array<ref<gameuiCharacterCustomizationInfo>>;
  native let armsCustomizationOptions: array<ref<gameuiCharacterCustomizationInfo>>;
  native let armsGroups: array<gameuiOptionsGroup>;
  native let headGroups: array<gameuiOptionsGroup>;
  native let bodyGroups: array<gameuiOptionsGroup>;
  native let perspectiveInfo: array<gameuiPerspectiveInfo>;
  native let uiPresets: array<gameuiCharacterCustomizationUiPresetInfo>;
  native let excludedFromRandomize: array<CName>;
  native let versionUpdateInfo: array<gameuiCharacterCustomizationVersionUpdateInfo>;
}

public native class gameuiCharacterCustomizationNailsController extends gameuiCharacterCustomizationBodyPartsController {
  native let nailsGroupName: CName;
}

public native class gameuiCharacterCustomizationOptionImpl extends CharacterCustomizationOption {}

public native struct gameuiCharacterCustomizationOptionVersionPrereq {
  native let optionName: CName;
  native let definitionName: CName;
}

public native struct gameuiCharacterCustomizationOptionVersionUpdateInfo {
  native let curOptionNames: array<CName>;
  native let curDefintionName: CName;
  native let optionPrereqs: array<gameuiCharacterCustomizationOptionVersionPrereq>;
  native let newOptionName: CName;
  native let newDefinitionName: CName;
  native let replaceCurOption: Bool;
}

public native class gameuiCharacterCustomizationPersonalLinkController extends gameuiICharacterCustomizationComponent {
  native let simpleLinkGroup: CName;
}

public native class gameuiCharacterCustomizationPreset extends CResource {
  native let isMale: Bool;
  native let bodyGroups: array<gameuiCustomizationGroup>;
  native let headGroups: array<gameuiCustomizationGroup>;
  native let armsGroups: array<gameuiCustomizationGroup>;
  native let perspectiveInfo: array<gameuiPerspectiveInfo>;
  native let tags: redTagList;
  native let version: Uint32;
}

public native class gameuiCharacterCustomizationState extends gameuiICharacterCustomizationState {}

public importonly native class gameuiCharacterCustomizationSystem extends gameuiICharacterCustomizationSystem {}

public native class gameuiCharacterCustomizationUiPreset extends CResource {
  native let isMaleVO: Bool;
  native let values: array<gameuiCharacterCustomizationUiPresetValue>;
}

public native struct gameuiCharacterCustomizationUiPresetInfo {
  native let name: CName;
  native let resource: ResourceAsyncRef; // raRef<gameuiCharacterCustomizationUiPreset>
}

public native struct gameuiCharacterCustomizationUiPresetValue {
  native let optionName: CName;
  native let isActive: Bool;
  native let value: Uint32;
}

public native struct gameuiCharacterCustomizationVersionUpdateInfo {
  native let newVersion: Uint32;
  native let optionUpdates: array<gameuiCharacterCustomizationOptionVersionUpdateInfo>;
}

public native class gameuiCharacterReplicaInitializedEvent extends Event {}

enum gameuiChoiceIndicatorType {
  Default = 0,
  Speech = 1,
  Call = 2,
  Arrow = 3,
  Hand = 4,
  Loot = 5,
  Quest = 6,
  FastTravel = 7,
  Solo = 9,
  Netrunner = 10,
  Techie = 12,
}

enum gameuiChoiceListVisualizerType {
  Interaction = 0,
  Dialog = 1,
}

public native class gameuiCompassWidgetGameController extends inkHUDGameController {
  native let compassWidget: inkWidgetRef;
}

public native class gameuiCreditsPositionController extends inkLogicController {
  native let titleText: inkTextRef;
  native let namesText: inkTextRef;
}

public native class gameuiCreditsSectionController extends inkLogicController {
  native let sectionName: inkTextRef;
}

public native struct gameuiCustomizationGroup {
  native let name: CName;
  native let customization: array<gameuiCustomizationAppearance>;
  native let morphs: array<gameuiCustomizationMorph>;
}

enum gameuiCyberspaceElementType {
  CyberspaceNPC = 0,
  CyberspaceFakeObject = 1,
}

public native class gameuiCyberspaceUIObject extends GameObject {
  native let slotName: CName;
  native let mappinType: gameuiCyberspaceElementType;
  native let caption: String;
}

public native class gameuiDelayedNextVOEvt extends Event {}

public native class gameuiDialogListChoiceVisualizer extends gameuiIChoiceVisualizer {}

public native struct gameuiDistrictTriggerData {
  native let district: gamedataDistrict;
  native let triggerName: CName;
}

enum gameuiEIconOrientation {
  Upright = 0,
  Entity = 1,
}

public native class gameuiEntityPreviewGameObject extends GameObject {
  native let cameraSettings: inkEntityPreviewCameraSettings;
}

public native struct gameuiForcePlayerCustomizationData {
  native let customizationPart: gameuiCharacterCustomizationPart;
  native let uiSlot: CName;
  native let index: Uint32;
  native let partUiSlot: CName;
  native let partIndex: Uint32;
  native let definitionUiSlot: CName;
  native let definition: CName;
}

public native class gameuiFPSCounterGameController extends inkHUDGameController {
  native let counterWidget: inkTextRef;
}

public native class gameuiGameVersionTextController extends inkLogicController {
  native let gameVersionText: inkTextRef;
  native let expansionWrapper: inkCompoundRef;
  native let fluffWrapper: inkCompoundRef;
}

public native struct gameuiGarmentSwitchEffectController {
  native let sceneName: CName;
  native let effectName: CName;
  native let switchTime: Float;
  native let hideTime: Float;
}

enum gameuiGenericNotificationType {
  Generic = 0,
  QuestUpdate = 1,
  Vendor = 3,
  ZoneAlert = 4,
  VehicleAlert = 5,
  PreventionBounty = 6,
  ProgressionView = 7,
}

public native class gameuiGlobaltvWidgetGameController extends inkGameController {
  native let overlayContainer: inkCompoundRef;
}

public native class gameuiGPSGameController extends inkHUDGameController {
  native let gpsSettings: GPSSettings;
}

public native class gameuiGridDataFillFinished extends Event {}

public native class gameuiHackingMinigameLogicController extends inkLogicController {
  native let grid: inkUniformGridRef;
  native let buffer: inkCompoundRef;
  native let programs: inkCompoundRef;
  native let timer: inkTextRef;
  native let timerProgressBar: inkWidgetRef;
  native let timerContainer: inkWidgetRef;
  native let timerPlaceholder: inkWidgetRef;
  native let accessInformationText: inkTextRef;
  native let activatedTraps: inkCompoundRef;
  native let gridVerticalHiglight: inkWidgetRef;
  native let gridHorizontalHiglight: inkWidgetRef;
  native let programsColumnHiglight: inkWidgetRef;
  native let successScreenWidget: inkCompoundRef;
  native let failScreenWidget: inkCompoundRef;
  native let successExitTerminalText: inkTextRef;
  native let failedExitTerminalText: inkTextRef;
  native let successExitButton: inkWidgetRef;
  native let failureExitButton: inkWidgetRef;
  native let resetButton: inkWidgetRef;
  native let introAnimName: CName;
  native let loopAnimName: CName;
  native let cursorAnimName: CName;
  native let higlightAnimName: CName;
  native let gameWonAnimName: CName;
  native let gameLostAnimName: CName;
  native let terminalShutdownAnimName: CName;
  native let trapActivatedAnimName: CName;
  native let programSucceedAnimName: CName;
  native let programFailedAnimName: CName;
  native let programResetFromFailedAnimName: CName;
  native let gridCellHoverAnimName: CName;
  native let gridCellClickFlashAnimName: CName;
  native let bufferCellHoverAnimName: CName;
  native let bufferCellClickFlashAnimName: CName;
  native let programCellClickFlashAnimName: CName;
  native let activatedTrapIconLibraryName: CName;
  native let bufferCellLibraryName: CName;
  native let programCellLibraryName: CName;
  native let gridCellLibraryName: CName;
  native let programEntryLibraryName: CName;
  native let trapIconsContainerRelativePath: CName;
  native let bufferCellTextWidgetRelativePath: CName;
  native let programCellTextWidgetRelativePath: CName;
  native let gridCellTrapIconWidgetRelativePath: CName;
  native let gridCellTrapIconContainerRelativePath: CName;
  native let gridCellTextWidgetRelativePath: CName;
  native let gridCellProgramHighlightRelativePath: CName;
  native let programEntryTextWidgetRelativePath: CName;
  native let programEntryNoteWidgetRelativePath: CName;
  native let programEntryInstructionContainerRelativePath: CName;
  native let programEntryIconPath: CName;
  native let cursorWidgetRelativePath: CName;
  native let gridCellDefaultStateName: CName;
  native let gridCellHoveredStateName: CName;
  native let gridCellSelectedStateName: CName;
  native let gridCellDisabledStateName: CName;
  native let programSucceedStateName: CName;
  native let programFailedStateName: CName;
  native let programCellReadyStateName: CName;
  native let programCellHighlightStateName: CName;
  native let mainHiglightBarStateName: CName;
  native let secondaryHiglightBarStateName: CName;
  native let inactiveHiglightBarStateName: CName;
  native let gridCellDisabledSymbol: String;
}

public native class gameuiHolocallCameraComponent extends entRenderToTextureCameraComponent {}

public native struct gameuiHudScalingSensitiveWidget {
  native let widget: inkWidgetRef;
  native let adjustScale: Bool;
  native let adjustTranslation: Bool;
  native let adjustMargin: Bool;
  native let targetMarginAtDoubleScale: inkMargin;
  native let marginToScalecorrectOverride: inkMargin;
}

public native class gameuiHUDVideoPlayerController extends inkHUDGameController {
  native let playOnHud: Bool;
}

public native struct gameuiHUDVideoStartEvent {
  native let videoPathHash: Uint64;
  native let playOnHud: Bool;
  native let fullScreen: Bool;
  native let useFullscreenVideoState: Bool;
  native let keepWidescreenAspectRatio: Bool;
  native let position: Vector2;
  native let size: Vector2;
  native let skippable: Bool;
  native let isLooped: Bool;
  native let forceVideoFrameRate: Bool;
}

public native struct gameuiHUDVideoStopEvent {
  native let videoPathHash: Uint64;
  native let isSkip: Bool;
}

public abstract native class gameuiICharacterCustomizationBodyController extends gameuiICharacterCustomizationComponent {}

public abstract native class gameuiICharacterCustomizationBodyPartsController extends gameuiICharacterCustomizationComponent {}

public abstract native class gameuiICharacterCustomizationComponent extends IComponent {}

public abstract native class gameuiIChoiceVisualizer extends ISerializable {}

public abstract native class gameuiICustomizationStateUpdater extends IScriptable {}

public native class gameuiInGameCharacterCustomizationPuppetAttachmentSlotsListener extends AttachmentSlotsListener {}

public native struct gameuiInGameMenuGameControllerItemSceneInfo {
  native let sceneName: CName;
  native let puppetSceneName: CName;
  native let prefabRef: NodeRef;
  native let markerRef: NodeRef;
}

public native class gameuiInGameMenuGameCustomizationStateUpdater extends gameuiICustomizationStateUpdater {}

public native class gameuiInkChoiceVisualizer extends gameuiIChoiceVisualizer {
  native let isDynamic: Bool;
  native let type: gameuiChoiceListVisualizerType;
}

public native class gameuiItemDataSourceListener extends InventoryListener {}

public abstract native class gameuiIUIObjectsLoaderSystemListener extends ISerializable {}

public native class gameuiLootVisualizer extends gameuiIChoiceVisualizer {}

public native class gameuiNewsFeedDataProvider extends IScriptable {
  native let newsTitleTweak: TweakDBID;
  native let randomNewsFeedPack: TweakDBID;
}

public native class gameuiNewsFeedDisplayController extends inkLogicController {
  native let newsTitleWidget: inkTextRef;
  native let randomNewsLibraryWidget: CName;
  native let randomNewsContainer: inkCompoundRef;
}

public native class gameuiOnscreenVOPlayerController extends inkGameController {
  native let subtitlesContainer: inkCompoundRef;
  native let subtitlesLibraryResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let subtitlesRootName: CName;
  native let audioVOList: array<gameuiVOWithDelay>;
}

public native struct gameuiOptionsGroup {
  native let name: CName;
  native let options: array<CName>;
}

public native class gameuiPersonalLinkControllerCustomizationStateUpdater extends gameuiICustomizationStateUpdater {}

public native struct gameuiPerspectiveInfo {
  native let name: CName;
  native let fpp: CName;
  native let tpp: CName;
}

public native class gameuiPreGamePuppetAttachmentSlotsListener extends AttachmentSlotsListener {}

public native class gameuiPuppetAttachmentSlotsListener extends AttachmentSlotsListener {}

public native struct gameuiPuppetPreviewCameraController {
  native let cameraSetup: array<gameuiPuppetPreviewCameraSetup>;
  native let activeSetup: Uint32;
  native let transitionDelay: Float;
}

public native struct gameuiPuppetPreviewCameraSetup {
  native let slotName: CName;
  native let cameraZoom: Float;
  native let interpolationTime: Float;
}

public native class gameuiRandomNewsFeedAnimator extends inkLogicController {
  native let textWidget: inkTextRef;
  native let animDuration: Float;
}

public native struct gameuiResolutionSensitiveWidget {
  native let widget: inkWidgetRef;
  native let marginToScalecorrectOverride: inkMargin;
}

public native struct gameuiRoadEditorDecorationSettings {
  native let libraryName: CName;
  native let offset: Float;
  native let repeatPatternDensity: Uint32;
  native let repeatPatternStartOffset: Uint32;
}

public native struct gameuiRoadEditorObstacleSettings {
  native let libraryName: CName;
  native let offset: Float;
  native let speed: Float;
  native let segmentOffset: Uint32;
}

public native struct gameuiRoadEditorSegment {
  native let length: Uint32;
  native let curve: Float;
  native let hasCheckpoint: Bool;
  native let obstacleSettings: array<gameuiRoadEditorObstacleSettings>;
  native let decorationSettings: array<gameuiRoadEditorDecorationSettings>;
}

public native class gameuiRootHudGameController extends inkGameController {
  native let resolutionSensitiveRoots: array<inkCompoundRef>;
}

public native class gameuiRootHudSaveData extends ISerializable {
  native let entriesVisibility: array<questHUDEntryVisibilityData>;
}

public native class gameuiScreenAreaMultiplierChangeEvent extends Event {
  native let screenAreaMultiplier: Float;
}

public native class gameuiSetCharacterCreationDataRequest extends PlayerScriptableSystemRequest {
  native let lifepath: TweakDBID;
  native let attributes: array<CharacterCustomizationAttribute>;
}

public native class gameuiSpawnNewFeedEvent extends Event {}

public native class gameuiStaticIconLogicController extends gameuiDynamicIconLogicController {
  native let iconReference: TweakDBID;
}

public native class gameuiTextureMaxMipBiasChangeEvent extends Event {
  native let textureMaxMipBias: Uint32;
}

public native class gameuiTextureMinMipBiasChangeEvent extends Event {
  native let textureMinMipBias: Uint32;
}

public native class gameuiTooltipSlotData extends inkUserData {
  native let margin: inkMargin;
  native let placement: gameuiETooltipPlacement;
}

public native class gameuiTrialPeriodTimerController extends inkGenericSystemNotificationLogicController {
  native let timerText: inkTextRef;
}

public native class gameuiTutorialAreaDespawnEvent extends Event {
  native let bracketID: CName;
  native let areaID: Uint32;
}

public native class gameuiTutorialAreaSpawnEvent extends Event {
  native let bracketID: CName;
  native let areaID: Uint32;
  native let widget: wref<inkWidget>;
}

public native class gameuiTutorialBracketHideEvent extends Event {
  native let bracketID: CName;
}

public native class gameuiTutorialBracketShowEvent extends Event {
  native let data: TutorialBracketData;
}

public native class gameuiTutorialOverlayHideEvent extends Event {
  native let itemName: CName;
}

public native class gameuiTutorialOverlayShowEvent extends Event {
  native let itemName: CName;
}

public native class gameuiUIGameState extends ISerializable {
  native let uiData: array<ref<gameuiBaseUIData>>;
}

public native class gameuiUIObjectsLoaderSystem extends gameuiIUIObjectsLoaderSystem {}

public native struct gameuiVOWithDelay {
  native let playDelay: Float;
  native let voHexID: String;
}

public native class gameuiWorldMapGameObject extends GameObject {
  native let districts: array<gameuiDistrictTriggerData>;
}

public native class gameuiWorldMapUpdateGroupsEvent extends Event {}

public native class gameUniqueItemData extends gameItemData {}

enum gameVehicleCommonCurve {
  RPMLimit = 0,
  ForcedBrakeForce = 1,
  COUNT = 2,
}

public native class gameVehicleCommonCurveSet extends CurveSet {}

enum gameVehicleCurve {
  SpeedToWheelMaxTurn = 0,
  InputToWheelMaxTurn = 1,
  SpeedToWheelTurnSpeed = 2,
  InputToWheelTurnSpeed = 3,
  COUNT = 4,
}

public native class gameVehicleCurveSet extends CurveSet {}

public native class gameVehicleCurvesLibrary extends Entity {
  native let curves: array<ResourceRef>;
  native let commonCurves: array<ResourceRef>;
  native let bikeCurves: array<ResourceRef>;
}

public native struct gameVehicleDynamicSpawnLogic {}

public native class gameVehicleMeleeCleaveEvent extends Event {
  native let attackData: ref<AttackData>;
  native let hitPosition: Vector4;
  native let hitDirection: Vector4;
  native let hitComponent: wref<IPlacedComponent>;
}

public native class gameVisionActivatorComponent extends IComponent {}

public native class gameVisionAppearanceForcedEvent extends Event {
  native let state: Bool;
}

public importonly native class gameVisionModeActivationEvent extends Event {
  native let activate: Bool;
}

public native class gameVisionModePrereq extends IPrereq {
  native let type: gameVisionModeType;
}

public native class gameVisionModePrereqState extends PrereqState {}

public native class gameVisualTagsAppearanceNamesPreset_Entity extends ISerializable {
  native let entityPathHash: Uint64;
  native let debugEntityPath: CName;
  native let tagsToAppearances: array<gameVisualTagsAppearanceNamesPreset_TagsAppearances>;
}

public native class gameVisualTagsAppearanceNamesPreset_TagsAppearances extends ISerializable {
  native let visualTagHash: CName;
  native let appearanceNames: array<CName>;
}

public native class gameVisualTagsAppearanceNamesPreset extends ISerializable {
  native let presets: array<gameVisualTagsAppearanceNamesPreset_Entity>;
}

public native class gamewatchdogSystem extends IWatchdogSystem {}

public native class gameWaypoint extends worldIMarker {}

public native struct gameWeakSpotReplicatedInfo {
  native let weakSpotRecordID: Uint64;
  native let wsHealthValue: Float;
  native let LastDamageInstigator: wref<gamePuppet>;
}

public native class gameWeaponAudio extends ISerializable {}

public native class gameWeaponAudioComponent extends SoundComponentBase {}

public native class gameweaponeventsRequestAmmoChange extends Event {}

public native class gameweaponeventsShootEvent extends Event {}

public native class gameweaponeventsStopFiringEvent extends Event {}

public native struct gameWeaponReplicationHistory {
  native let weaponSlot: TweakDBID;
  native let latestShotId: Uint32;
  native let continuousAttack: gameReplicatedContinuousAttack;
}

public native struct gameWeaponsReplicatedState {}

public native class gameWorldBoundaryNode extends worldAreaShapeNode {}

public native class gameWorldBoundaryNodeInstance extends worldAreaShapeNodeInstance {}

public native class gameWorldBoundarySystem extends gameIWorldBoundarySystem {}

public native class gameWorldSpaceBlendCamera extends entCameraComponent {}

public importonly native class GarageComponent extends GameComponent {}

public importonly native class GarageComponentPS extends GameComponentPS {
  native persistent let spawnedVehiclesData: array<vehicleGarageComponentVehicleData>;
  native persistent let unlockedVehicles: array<GarageVehicleID>;
  native persistent let unlockedVehicleArray: array<vehicleUnlockedVehicle>;
  native persistent let uiFavoritedVehicles: array<GarageVehicleID>;
  native persistent let mountedVehicleData: vehicleGarageComponentVehicleData;
  native persistent let mountedVehicleStolen: Bool;
}

public native struct garmentBendingParams {
  native let bendPowerOffsetInCM: Float;
}

public native struct garmentCollarAreaParams {
  native let enable: Bool;
  native let radiusInCM: Float;
  native let radiusForTriangleRemovalInCM: Float;
  native let offsetFromSkinInCM: Float;
  native let offset: Vector3;
}

public native class garmentGarmentLayerParams extends CResource {
  native let bending: garmentBendingParams;
  native let smoothing: garmentSmoothingParams;
  native let collarArea: garmentCollarAreaParams;
  native let hiddenTrianglesRemoval: garmentHiddenTrianglesRemovalParams;
}

public native struct garmentHiddenTrianglesRemovalParams {
  native let garmentBorderThreshold: Float;
  native let removeHiddenTriangles: Bool;
  native let removeHiddenTrianglesRasterization: Bool;
  native let rayLengthInCM: Float;
  native let rayLengthMorphOffsetFactor: Float;
}

public native class garmentMeshParamGarment extends meshMeshParameter {
  native let chunks: array<garmentMeshParamGarmentChunkData>;
}

public native struct garmentMeshParamGarmentChunkData {
  native let numVertices: Uint32;
  native let lodMask: Uint8;
  native let isTwoSided: Bool;
}

public native struct garmentSmoothingParams {
  native let smoothingStrength: Float;
  native let smoothingRadiusInCM: Float;
  native let smoothingExponent: Float;
  native let smoothingNumNeighbours: Uint32;
  native let smoothNormalsEnabled: Bool;
}

public native class genLevelRandomizer extends GameObject {
  native let entries: array<genLevelRandomizerEntry>;
  native let seed: Uint32;
  native let dataSource: genLevelRandomizerDataSource;
  native let supervisorType: CName;
  native let debugSpawnAll: Bool;
}

enum genLevelRandomizerDataSource {
  Entries = 0,
  Markers = 1,
}

public native struct genLevelRandomizerEntry {
  native let id: String;
  native let templateName: CName;
  native let spawnPos: NodeRef;
  native let probability: Float;
}

public native class genNullRandomizationSupervisor extends IRandomizationSupervisor {}

public native class genRandomizerMarker extends worldIMarker {
  native let id: String;
  native let templateName: CName;
  native let probability: Float;
}

public native class GeometryShape extends ISerializable {
  native let vertices: array<Vector3>;
  native let indices: array<Uint16>;
  native let faces: array<GeometryShapeFace>;
}

public native struct GeometryShapeFace {
  native let indices: array<Uint32>;
}

public native class GICGIEditSettings extends ISerializable {}

enum GIGIOverrideType {
  Default = 0,
  Override_True = 1,
  Override_False = 2,
}

public native class GlobalIlluminationSettings extends IAreaSettings {
  native let multiBouceScale: CurveDataFloat;
  native let multiBouceSaturation: CurveDataFloat;
  native let emissiveScale: CurveDataFloat;
  native let diffuseScale: CurveDataFloat;
  native let localLightsScale: CurveDataFloat;
  native let lightScaleCompenensation: CurveDataFloat;
  native let reflectionCompensation: CurveDataFloat;
  native let ambientBase: CurveDataHDRColor;
  native let rayTracedSkyRadianceScale: CurveDataFloat;
}

public native struct GlobalLightingTrajectory {
  native let latitude: Float;
  native let sunRotationOffset: Float;
  native let moonRotationOffset: Float;
  native let timeOfYearSeason: ETimeOfYearSeason;
}

public native struct GlobalLightingTrajectoryOverride {
  native let overrideScale: Float;
  native let latitude: Float;
  native let sunRotationOffset: Float;
  native let moonRotationOffset: Float;
  native let timeOfYearSeason: ETimeOfYearSeason;
}

public native class GlobalLightOverrideAreaSettings extends IAreaSettings {
  native let color: CurveDataHDRColor;
  native let lightAzimuth: Float;
  native let lightElevation: Float;
}

public native struct GodModeData {
  native let type: gameGodModeType;
  native let source: CName;
}

public native struct GodModeEntityData {
  native let overrides: array<GodModeData>;
  native let base: array<GodModeData>;
}

public native struct GPSSettings {
  native let lineEffectOnFoot: ResourceAsyncRef; // raRef<worldEffect>
  native let lineEffectVehicle: ResourceAsyncRef; // raRef<worldEffect>
  native let fixedPathOffset: Vector3;
  native let fixedPortalMappinOffset: Vector3;
  native let pathRefreshTimeInterval: Float;
  native let lastPlayerNavmeshPositionRefreshTimeIntervalSecs: Float;
  native let maxPathDisplayLength: Float;
}

public native class GPSSystem extends IGPSSystem {}

enum GpuApieBufferUsageType {
  BUT_Default = 0,
  BUT_Immutable = 1,
  BUT_Readback = 2,
  BUT_Dynamic_Legacy = 3,
  BUT_Transient = 4,
  BUT_Mapped = 5,
  BUT_MAX = 6,
}

enum GpuWrapApiBufferGroup {
  System = 0,
  MeshResource = 1,
  MeshCustom = 2,
  AutoSpawner = 3,
  Debug = 4,
  DPL = 5,
  Weather = 6,
  ReflectionProbe = 7,
  Skinning = 8,
  Lights = 9,
  Video = 10,
  Particles = 11,
  GIManagerLitProbes = 12,
  GIManagerLookup = 13,
  GIManagerInterpolation = 14,
  GIManagerLitBricks = 15,
  GIManagerLights = 16,
  GIManagerEnvVolume = 17,
  GIProxyBrick = 18,
  GIProxySurfel = 19,
  GIProxyProbes = 20,
  GIProxyFactors = 21,
  GIProxyAcceleration = 22,
  Raytracing = 23,
  RaytracingUpload = 24,
  RaytracingAS = 25,
  RaytracingOMM = 26,
  Decals = 27,
  Instances = 28,
  Materials = 29,
  Multilayer = 30,
  FrameResources = 31,
  Misc = 32,
  MorphTargets = 33,
  MAX = 34,
}

enum GpuWrapApieBufferChunkCategory {
  BCC_Staging = 0,
  BCC_Vertex = 1,
  BCC_VertexUAV = 2,
  BCC_Index16Bit = 3,
  BCC_Index32Bit = 4,
  BCC_VertexIndex16Bit = 5,
  BCC_Constant = 6,
  BCC_TypedUAV = 7,
  BCC_Structured = 8,
  BCC_StructuredUAV = 9,
  BCC_StructuredAppendUAV = 10,
  BCC_IndirectUAV = 11,
  BCC_Index16BitUAV = 12,
  BCC_Raw = 13,
  BCC_ShaderTable = 14,
  BCC_Invalid = 15,
}

enum GpuWrapApieIndexBufferChunkType {
  IBCT_IndexUInt = 0,
  IBCT_IndexUShort = 1,
  IBCT_Max = 2,
}

enum GpuWrapApieTextureFormat {
  TEXFMT_A8_Unorm = 0,
  TEXFMT_R8_Unorm = 1,
  TEXFMT_L8_Unorm = 2,
  TEXFMT_R8G8_Unorm = 3,
  TEXFMT_R8G8B8X8_Unorm = 4,
  TEXFMT_R8G8B8A8_Unorm = 5,
  TEXFMT_R8G8B8A8_Unorm_SRGB = 40,
  TEXFMT_R8G8B8A8_Snorm = 6,
  TEXFMT_B8G8R8A8 = 50,
  TEXFMT_B8G8R8A8_SRGB = 51,
  TEXFMT_R16_Unorm = 7,
  TEXFMT_R16_Snorm = 49,
  TEXFMT_R16_Uint = 8,
  TEXFMT_R32_Uint = 9,
  TEXFMT_R32G32B32A32_Uint = 10,
  TEXFMT_R32G32_Uint = 11,
  TEXFMT_R16G16B16A16_Unorm = 12,
  TEXFMT_R16G16B16A16_Uint = 14,
  TEXFMT_R16G16_Uint = 15,
  TEXFMT_R10G10B10A2_Unorm = 16,
  TEXFMT_R16G16B16A16_Float = 17,
  TEXFMT_R11G11B10_Float = 18,
  TEXFMT_R16G16_Float = 19,
  TEXFMT_R32G32_Float = 20,
  TEXFMT_R32G32B32A32_Float = 21,
  TEXFMT_R32_Float = 22,
  TEXFMT_R16_Float = 23,
  TEXFMT_D24S8 = 24,
  TEXFMT_D32FS8 = 25,
  TEXFMT_D32F = 27,
  TEXFMT_D16U = 28,
  TEXFMT_BC1 = 29,
  TEXFMT_BC1_SRGB = 41,
  TEXFMT_BC2 = 30,
  TEXFMT_BC2_SRGB = 42,
  TEXFMT_BC3 = 31,
  TEXFMT_BC3_SRGB = 43,
  TEXFMT_BC4 = 32,
  TEXFMT_BC5 = 33,
  TEXFMT_BC6H_UNSIGNED = 34,
  TEXFMT_BC6H_SIGNED = 35,
  TEXFMT_BC7 = 36,
  TEXFMT_BC7_SRGB = 37,
  TEXFMT_R8_Uint = 38,
  TEXFMT_R16G16_Unorm = 44,
  TEXFMT_R16G16_Sint = 45,
  TEXFMT_R16G16_Snorm = 46,
  TEXFMT_B5G6R5_Unorm = 47,
  TEXFMT_A8 = 0,
  TEXFMT_R8 = 1,
  TEXFMT_L8 = 2,
  TEXFMT_R8G8 = 3,
  TEXFMT_R8G8B8X8 = 4,
  TEXFMT_R8G8B8A8 = 5,
  TEXFMT_R8G8B8A8 = 40,
  TEXFMT_Uint_16_norm = 7,
  TEXFMT_Uint_16 = 8,
  TEXFMT_Uint_32 = 9,
  TEXFMT_Uint_R32G32B32A32 = 10,
  TEXFMT_Uint_R32G32B32A32 = 14,
  TEXFMT_R10G10B10A2 = 16,
  TEXFMT_Float_R16G16B16A16 = 17,
  TEXFMT_Float_R11G11B10 = 18,
  TEXFMT_Float_R16G16 = 19,
  TEXFMT_Float_R32G32 = 20,
  TEXFMT_Float_R32G32B32A32 = 21,
  TEXFMT_Float_R32 = 22,
  TEXFMT_Float_R16 = 23,
  TEXFMT_BC6H = 34,
}

enum GpuWrapApieTextureGroup {
  TEXG_Generic_Color = 1,
  TEXG_Generic_Grayscale = 2,
  TEXG_Generic_Normal = 3,
  TEXG_Generic_Data = 4,
  TEXG_Generic_UI = 5,
  TEXG_Generic_Font = 6,
  TEXG_Generic_LUT = 7,
  TEXG_Generic_MorphBlend = 8,
  TEXG_Multilayer_Color = 9,
  TEXG_Multilayer_Normal = 10,
  TEXG_Multilayer_Grayscale = 11,
  TEXG_Multilayer_Microblend = 12,
}

enum GpuWrapApieTextureType {
  TEXTYPE_2D = 0,
  TEXTYPE_CUBE = 1,
  TEXTYPE_ARRAY = 2,
  TEXTYPE_3D = 3,
}

public native struct GpuWrapApiVertexLayoutDesc {
  native let slotMask: Uint32;
  native let hash: Uint32;
}

enum GpuWrapApiVertexPackingePackingType {
  PT_Invalid = -1,
  PT_Float1 = 0,
  PT_Float2 = 1,
  PT_Float3 = 2,
  PT_Float4 = 3,
  PT_Float16_2 = 4,
  PT_Float16_4 = 5,
  PT_UShort1 = 6,
  PT_UShort2 = 7,
  PT_UShort4 = 8,
  PT_UShort4N = 9,
  PT_Short1 = 10,
  PT_Short2 = 11,
  PT_Short4 = 12,
  PT_Short4N = 13,
  PT_UInt1 = 14,
  PT_UInt2 = 15,
  PT_UInt3 = 16,
  PT_UInt4 = 17,
  PT_Int1 = 18,
  PT_Int2 = 19,
  PT_Int3 = 20,
  PT_Int4 = 21,
  PT_Color = 22,
  PT_UByte1 = 23,
  PT_UByte1F = 24,
  PT_UByte4 = 25,
  PT_UByte4N = 26,
  PT_Byte4N = 27,
  PT_Dec4 = 28,
  PT_Index16 = 29,
  PT_Index32 = 30,
  PT_Max = 31,
}

enum GpuWrapApiVertexPackingePackingUsage {
  PS_Invalid = -1,
  PS_SysPosition = 0,
  PS_Position = 1,
  PS_Normal = 2,
  PS_Tangent = 3,
  PS_Binormal = 4,
  PS_TexCoord = 5,
  PS_Color = 6,
  PS_SkinIndices = 7,
  PS_SkinWeights = 8,
  PS_DestructionIndices = 9,
  PS_MultilayerPaint = 10,
  PS_InstanceTransform = 11,
  PS_InstanceLODParams = 12,
  PS_InstanceSkinningData = 13,
  PS_PatchSize = 14,
  PS_PatchBias = 15,
  PS_ExtraData = 16,
  PS_VehicleDmgNormal = 17,
  PS_VehicleDmgPosition = 18,
  PS_PositionDelta = 19,
  PS_LightBlockerIntensity = 20,
  PS_BoneIndex = 21,
  PS_Padding = 22,
  PS_PatchOffset = 23,
  PS_Max = 24,
}

enum GpuWrapApiVertexPackingEStreamType {
  ST_Invalid = -1,
  ST_PerVertex = 0,
  ST_PerInstance = 1,
  ST_Max = 2,
}

public native struct GpuWrapApiVertexPackingPackingElement {
  native let type: GpuWrapApiVertexPackingePackingType;
  native let usage: GpuWrapApiVertexPackingePackingUsage;
  native let usageIndex: Uint8;
  native let streamIndex: Uint8;
  native let streamType: GpuWrapApiVertexPackingEStreamType;
}

public native class graphGraphConnectionDefinition extends graphIGraphObjectDefinition {
  native let source: wref<graphGraphSocketDefinition>;
  native let destination: wref<graphGraphSocketDefinition>;
}

public abstract native class graphGraphDefinition extends graphIGraphObjectDefinition {
  native let nodes: array<ref<graphGraphNodeDefinition>>;
}

public abstract native class graphGraphNodeDefinition extends graphIGraphObjectDefinition {
  native let sockets: array<ref<graphGraphSocketDefinition>>;
}

public abstract native class graphGraphResource extends CResource {
  native let graph: ref<graphGraphDefinition>;
}

public abstract native class graphIGraphNodeCondition extends ISerializable {}

public abstract native class graphIGraphObjectDefinition extends ISerializable {}

public native struct grsDeathmatchPlayerGameInfo {
  native let peerID: netPeerID;
  native let isInGame: Bool;
  native let isDead: Bool;
  native let spawnTime: netTime;
  native let killCount: Uint32;
  native let deathCount: Uint32;
  native let lastShooter: netPeerID;
}

public native struct grsDeathmatchState {
  native let time: netTime;
  native let status: grsDeathmatchStatus;
  native let sessionLength: netTime;
}

enum grsDeathmatchStatus {
  Waiting = 0,
  AdditionalWaiting = 1,
  Starting = 2,
  InGame = 3,
  Ending = 4,
  Sumup = 5,
}

public native struct grsGatherAreaManager {
  native let activeGatherAreaRepInfo: grsGatherAreaReplicatedInfo;
}

public native struct grsGatherAreaReplicatedInfo {
  native let hasActiveQuestListener: Bool;
  native let enabled: Bool;
}

public native struct grsHeistPlayerGameInfo {
  native let peerID: netPeerID;
  native let isInGame: Bool;
  native let isReady: Bool;
  native let isRespawning: Bool;
  native let isDead: Bool;
  native let spawnTime: netTime;
  native let killCount: Uint32;
  native let deathCount: Uint32;
  native let characterRecord: String;
}

public native struct grsHeistState {
  native let time: netTime;
  native let status: grsHeistStatus;
}

public abstract importonly native class gsmBaseRequestsHandler extends inkISystemRequestsHandler {
  native let SavingComplete: gsmSavingRequesResult;
}

public native class gsmGameDefinition extends CResource {
  native let mainQuests: array<ref<gsmMainQuest>>;
  native let world: ResourceAsyncRef; // raRef<worldWorld>
  native let streamingWorld: ResourceAsyncRef; // raRef<CResource>
  native let worldName: String;
  native let spawnPointTags: redTagList;
}

public abstract native struct gsmIStateObserver {}

public native class gsmMainQuest extends ISerializable {
  native let questFile: ResourceAsyncRef; // raRef<questQuestResource>
  native let additionalContent: Bool;
  native let additionalContentName: CName;
}

public native class gsmMenuState_CreateSingleplayerSession extends gsmMenuState {}

public native class gsmMenuState_ErrorPopup extends gsmPopupState {}

public native class gsmMenuState_FindSessions extends gsmMenuState {}

public native class gsmMenuState_GatheringSaves extends gsmPopupState {}

public native class gsmMenuState_InGamePause extends gsmMenuState {}

public native class gsmMenuState_LoadGameDefinition extends gsmMenuState {}

public native class gsmMenuState_LoadSession extends gsmMenuState {}

public native class gsmMenuState_MainMenu extends gsmMenuState {}

public native class gsmMenuState_ModalPopup extends gsmPopupState {}

public native class gsmMenuState_Multiplayer extends gsmMenuState {}

public native class gsmMenuState_MultiplayerSelectCharacter extends gsmMenuState {}

public native class gsmMenuState_PlayRecordedSession extends gsmMenuState {}

public native class gsmMenuState_Singleplayer extends gsmMenuState {}

public abstract native class gsmMenuState extends gsmState {}

public abstract native class gsmPopupState extends gsmState {}

public native class gsmState_AutoJoinServer extends gsmMenuState {}

public native class gsmState_BoothModeMainMenu extends gsmMenuState {}

public native class gsmState_Initialization extends gsmState {}

public native class gsmState_PreGameSession extends gsmState_Session {}

public native class gsmState_ReconnectController extends gsmState {}

public native class gsmState_Session extends gsmState {}

public native class gsmState_SessionActive extends gsmState_SessionStreamingAware {}

public native class gsmState_SessionLoading extends gsmState {}

public native class gsmState_SessionNewGame extends gsmState {}

public native class gsmState_SessionPaused extends gsmState_SessionStreamingAware {}

public native class gsmState_SessionRestoreFromSave extends gsmState {}

public native class gsmState_SessionStreamingAware extends gsmState {}

public native class gsmState_TrialVersionUpgrade extends gsmState {}

public abstract native class gsmState extends IScriptable {}

enum gsmStateError {
  StateError_OK = 0,
  StateError_SettingsCorrupted = 1,
  StateError_SettingsCorrupted_Save = 2,
  StateError_ProfileCorrupted = 3,
  StateError_ProfileCorrupted_Save = 4,
  StateError_CannotInitializeContext = 5,
  StateError_CantLoadGameDefinition = 6,
  StateError_CantInitializeSession = 7,
  StateError_CantLoadSave_CantLoadFile = 8,
  StateError_CantLoadSave_CantCreateLoadStream = 9,
  StateError_CantLoadSave_CensorshipLevelMismatch = 10,
  StateError_CantLoadSave_RegionMismatch = 11,
  StateError_CantLoadSave_CensorshipOptionalNudity = 12,
  StateError_CantLoadSave_VersionMismatch = 13,
  StateError_CantLoadSave_Corrupted = 14,
  StateError_CantLoadSave_SessionDescInvalid = 15,
  StateError_CantLoadSave_CantLoadCloudFile = 16,
  StateError_CantLoadSave_AdditionalContentIDsMismatch = 17,
}

public native class GTFManager extends IScriptable {
  public final native func ParamManager()
}

public native class GTFParamManager extends IScriptable {
  public final native func SetFPSClamp()
  public final native func SetTurboMode()
}

public native class HACK_AREA_Settings extends IAreaSettings {
  native let surfelScale: Float;
  native let missingEnergyScale: Float;
  native let overrideOnPureView: Bool;
  native let surfAlbedoOverrideRatio: Float;
  native let surfAlbedoOverride: HDRColor;
  native let skyScale: Float;
  native let bottomHemisphereTint: CurveDataHDRColor;
  native let bottomHemisphereStrength: Float;
  native let emissiveScale: Float;
  native let albedoMetalness: Float;
}

public native class HasDialogVisualizerVisiblePrereq extends IPrereq {}

public native class HasDialogVisualizerVisiblePrereqState extends PrereqState {}

public native class HeatAgentComponent extends IPlacedComponent {}

public native class HeatHazeAreaSettings extends IAreaSettings {
  native let effectStrength: CurveDataFloat;
  native let startDistance: CurveDataFloat;
  native let maxDistance: CurveDataFloat;
  native let patternScale: CurveDataFloat;
  native let movementSpeedScale: CurveDataFloat;
}

public native class HideCustomTooltipEvent extends Event {}

public native class HitRepresentationComponent extends SlotComponent {
  native let representations: array<HitShapeContainer>;
  native let physicsMaterial: CName;
  native let bvhRoot: gameHitShapeBVH;
  native let useResourceData: Bool;
  native let resource: ResourceAsyncRef; // raRef<HitRepresentationResource>
  native let appearanceOverrides: array<HitRepresentationOverride>;
}

public importonly native class HitRepresentationOverride extends ISerializable {
  native let represenationOverride: HitShapeContainer;
}

public importonly native class HitRepresentationResource extends CResource {
  native let representations: array<HitShapeContainer>;
  native let overrides: array<HitRepresentationVisualTaggedOverride>;
}

public importonly native class HitRepresentationVisualTaggedOverride extends ISerializable {
  native let visualTags: redTagList;
  native let represenationOverride: HitShapeContainer;
}

public importonly native class HitShape_Capsule extends HitShapeBase {
  native let radius: Float;
  native let height: Float;
}

public importonly native class HitShape_ColliderComponent extends HitShapeBase {
  native let componentNames: array<CName>;
}

public importonly native class HitShape_OBB extends HitShapeBase {
  native let dimensions: Vector3;
}

public importonly native class HitShape_Sphere extends HitShapeBase {
  native let radius: Float;
}

public abstract importonly native class HitShapeBase extends IHitShape {
  native let translation: Vector3;
  native let rotation: Quaternion;
  native let localTransform: Matrix;
}

public importonly native struct HitShapeContainer {
  native let name: CName;
  native let slotName: CName;
  native let color: Color;
  native let shape: ref<IHitShape>;
  native let userData: ref<HitShapeUserData>;
  native let physicsMaterial: physicsMaterialReference;
}

public native class HudMeshComponent extends MeshComponent {}

public abstract native class IActivityCardsSystem extends IGameSystem {}

public abstract native struct IAgent {}

public abstract native class IAreaSettings extends ISerializable {
  native let enable: Bool;
  native let disabledIndexedProperties: Uint64;
}

public abstract native class IBackendData extends ISerializable {}

public abstract importonly native class IBlackboardUpdateProxy extends IGameSystem {}

public abstract native struct ICameraStorageCustomData {}

public abstract importonly native class IClientEntitySpawnSystem extends IGameSystem {}

public abstract native class ICommandsManager extends IGameSystem {}

public abstract native struct IDebugConsole {}

public native class IDestructionPersistencySystem extends DestructionPersistencySystem {}

public abstract native class IDeviceInteractionManager extends IGameSystem {}

public abstract native class IDynamicTextureGenerator extends ISerializable {}

public native class IEvaluator extends ISerializable {}

public abstract native class IEvaluatorColor extends IEvaluator {}

public abstract native class IEvaluatorFloat extends IEvaluator {}

public abstract native class IEvaluatorVector extends IEvaluator {
  native let freeAxes: EFreeVectorAxes;
  native let spill: Bool;
}

public abstract native class IGPSSystem extends IGameSystem {}

public abstract native class IHitRepresentationSystem extends IGameSystem {}

public abstract importonly native class IHitShape extends ISerializable {}

public native struct IKChainSettings {
  native let chainName: CName;
  native let enableFloatTrack: CName;
  native let ikEndPointOffset: Vector3;
  native let ikEndRotationOffset: Quaternion;
}

public native class ImageBasedFlareAreaSettings extends IAreaSettings {
  native let treshold: Float;
  native let dispersal: Float;
  native let haloWidth: Float;
  native let distortion: Float;
  native let curve: Float;
  native let tint: [Color; 8];
  native let scale: CurveDataFloat;
  native let saturation: CurveDataFloat;
}

public native class ImageTextureGenerator extends IDynamicTextureGenerator {}

public abstract native class IMaterial extends CResource {}

enum IMaterialDataProviderDescEParameterType {
  PT_None = 0,
  PT_Texture = 1,
  PT_Color = 2,
  PT_Cube = 3,
  PT_Vector = 4,
  PT_Scalar = 5,
  PT_Bool = 6,
  PT_TextureArray = 7,
  PT_StructBuffer = 8,
  PT_Cpu_NameU64 = 9,
  PT_SkinProfile = 10,
  PT_MultilayerSetup = 11,
  PT_MultilayerMask = 12,
  PT_HairProfile = 13,
  PT_FoliageProfile = 14,
  PT_TerrainSetup = 15,
  PT_Gradient = 16,
  PT_DynamicTexture = 17,
  PT_MAX = 18,
}

public abstract native class IMaterialDefinition extends IMaterial {
  native let paramBlockSize: [Uint32; 3];
  native let canHaveTangentUpdate: Bool;
  native let canHaveDismemberment: Bool;
  native let hasDPL: Bool;
  native let canBeMasked: Bool;
  native let shadingRateMode: EMaterialShadingRateMode;
  native let materialVersion: Uint8;
  native let vertexFactories: array<EMaterialVertexFactory>;
}

public abstract native class IMovePoliciesSystem extends IGameSystem {}

public abstract importonly native class IMoveSystem extends IGameSystem {}

public abstract native class IMovingPlatformSystem extends IGameSystem {}

public native class inkAdvertisementsLayer extends inkWorldFluffLayer {}

public native class inkanimAdvertPauseEvent extends inkAnimEvent {}

public native class inkanimAnimationController extends inkLogicController {}

public native class inkanimAnimationLibraryResource extends CResource {
  native let sequences: array<ref<inkAnimSequence>>;
}

public native class inkAnimatedAdvertController extends inkLogicController {
  native let animName: CName;
  native let loopType: inkanimLoopType;
}

public native class inkanimChangeStateEvent extends inkAnimEvent {
  native let state: CName;
}

public native class inkanimChangeTexturePartEvent extends inkAnimEvent {
  native let imageTexturePartName: CName;
}

public native class inkanimExecuteCodeEventEvent extends inkAnimEvent {
  native let eventToExecute: ref<Event>;
}

public native class inkanimExecuteControllerFunctionEvent extends inkAnimEvent {
  native let controllerType: CName;
  native let eventName: CName;
  native let params: String;
}

public native class inkanimMarkerEvent extends inkAnimEvent {
  native let markerName: CName;
}

public native class inkanimPlayAnimEvent extends inkAnimEvent {
  native let animName: CName;
  native let playbackOptions: inkAnimOptions;
}

public native class inkanimPlaySoundEvent extends inkAnimEvent {
  native let soundEventName: CName;
}

public native class inkanimPlayVideoEvent extends inkAnimEvent {
  native let videoResource: ResourceAsyncRef; // raRef<Bink>
}

public native class inkanimPlayVOEvent extends inkAnimEvent {
  native let VOLine: String;
  native let speakerName: String;
}

public abstract native class inkanimProcessor extends ISerializable {}

public native class inkanimSequenceTargetInfo extends ISerializable {
  native let path: array<Uint32>;
}

public native class inkanimSetStyleEvent extends inkAnimEvent {
  native let style: ResourceAsyncRef; // raRef<inkStyleResource>
}

public native class inkanimSetTextEvent extends inkAnimEvent {
  native let localizationString: String;
}

public native class inkAnimShapeBorderTransparency extends inkAnimInterpolator {
  native let startValue: Float;
  native let endValue: Float;
  public final native func GetEndTransparency()
  public final native func GetStartTransparency()
  public final native func SetEndTransparency()
  public final native func SetStartTransparency()
}

public native class inkAnimShapeFillTransparency extends inkAnimInterpolator {
  native let startValue: Float;
  native let endValue: Float;
  public final native func GetEndTransparency()
  public final native func GetStartTransparency()
  public final native func SetEndTransparency()
  public final native func SetStartTransparency()
}

public native class inkanimStopAnimEvent extends inkAnimEvent {
  native let animName: CName;
}

public native class inkanimStopVideoEvent extends inkAnimEvent {}

public native class inkAnimTextKiroshi extends inkAnimTextInterpolator {}

public native class inkAnimTranslationBetweenWidgets extends inkAnimTranslation {
  native let startWidgetPath: CName;
  native let endWidgetPath: CName;
}

public native class inkAnimVideo extends inkAnimInterpolator {
  native let startValue: Float;
  native let endValue: Float;
  native let synchronizeToAudio: Bool;
  native let allowSkipBackward: Bool;
  native let audioEvent: CName;
  native let retriggerAudioOnLoop: Bool;
}

public native class inkAudioHandlerUserData extends inkUserData {}

public native struct inkBinkLanguageDescriptor {
  native let bink: ResourceAsyncRef; // raRef<Bink>
  native let languageId: inkLanguageId;
}

public native class inkBlackwallEffect extends inkGlitchEffect {
  native let scaleX: Float;
  native let scaleY: Float;
  native let layerVisibility: Float;
}

public native class inkBoxBlurEffect extends inkIEffect {
  native let samples: Uint8;
  native let intensity: Float;
  native let blurDimension: inkEBlurDimension;
}

public native struct inkBrushWrapper {
  native let brush: ref<inkWidgetBrush>;
  native let externalBrush: ResourceRef; // rRef<inkWidgetBrushResource>
}

enum inkCacheMode {
  Normal = 0,
  Minimap = 1,
  ExternalDynamicTexture = 2,
}

public abstract native struct inkCallbackBase {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkCallbackListener {
  native let object: wref<IScriptable>;
  native let functionName: CName;
}

public native class inkCensorshipController extends inkLogicController {}

public native class inkCensorshipEffect extends inkGlitchEffect {}

enum inkCharacterEventType {
  CharInput = 0,
  MoveCaretForward = 1,
  MoveCaretBackward = 2,
  Delete = 3,
  Backspace = 4,
}

public abstract native class inkChildren extends ISerializable {}

public native class inkColorCorrectionEffect extends inkIEffect {
  native let brightness: Float;
  native let contrast: Float;
  native let saturation: Float;
}

public native class inkColorFillEffect extends inkIEffect {
  native let colorR: Float;
  native let colorG: Float;
  native let colorB: Float;
  native let colorA: Float;
  native let saturation: Float;
}

public native struct inkCompositionInterpolator {
  native let parameter: CName;
  native let interpolationMode: inkanimInterpolationMode;
  native let interpolationType: inkanimInterpolationType;
  native let duration: Float;
  native let startDelay: Float;
}

enum inkCompositionParamType {
  FLOAT = 0,
  VECTOR2 = 1,
}

public native struct inkCompositionPreset {
  native let stateName: CName;
  native let useBackgroundTexture: Bool;
  native let shaderParams: fxCompositionShaderParams;
  native let transitions: array<inkCompositionTransition>;
}

public native class inkCompositionPreviewSettings extends ISerializable {
  native let sourceState: CName;
  native let targetState: CName;
  native let previewResolution: inkETextureResolution;
  native let gameFrameTexture: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let textureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let texturePart: CName;
}

public native struct inkCompositionTransition {
  native let targetState: CName;
  native let interpolators: array<inkCompositionInterpolator>;
}

public native class inkContainerNavigationController extends inkDiscreteNavigationController {
  native let overrideEntries: array<inkNavigationOverrideEntry>;
  native let useGlobalInput: Bool;
}

public abstract native class inkControllerProcessor extends ISerializable {}

public native class inkCreditsResource extends CResource {
  native let sections: array<inkCreditsSectionEntry>;
}

public native struct inkCreditsSectionEntry {
  native let sectionTitle: String;
  native let names: array<String>;
  native let displayMode: inkDisplayMode;
}

public native class inkDebugLayer extends inkFullScreenLayer {}

public native struct inkDebugLayerEntry {
  native let widgetResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let anchorPlace: inkEAnchor;
  native let anchorPoint: Vector2;
}

public native class inkDebugSystem extends inkIDebugSystem {}

public native class inkDebugSystemAccessor extends inkILayerSystemAccesor {}

public native class inkDebugSystemData extends inkILayerSystemData {
  native let entries: array<inkDebugLayerEntry>;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
}

public native class inkDelayedSetLoadingScreenEvent extends Event {}

public native class inkDelayedSetStateEvent extends Event {}

enum inkDisplayMode {
  Invalid = 0,
  Basic = 1,
  BasicTranslatable = 2,
  Bold = 3,
  Header = 4,
  Single = 5,
}

public native struct inkDrawArea {
  native let size: Vector2;
  native let scale: Float;
  native let relativePosition: Vector2;
  native let absolutePosition: Vector2;
}

public native struct inkDynamicTextureSlot {
  native let texture: ResourceAsyncRef; // raRef<DynamicTexture>
  native let parts: array<inkTextureAtlasMapper>;
}

enum inkEBlurDimension {
  Horizontal = 0,
  Vertical = 1,
}

public native class inkEditorLayer extends inkFullScreenLayer {}

enum inkEEndCapStyle {
  BUTT = 0,
  SQUARE = 1,
  ROUND = 2,
  JOINED = 3,
}

enum inkEJointStyle {
  MITER = 0,
  BEVEL = 1,
  ROUND = 2,
}

enum inkELayerLoadPriority {
  Normal = 0,
  High = 1,
}

public native class inkEnableHUDScaleOverride extends inkInitializedWidgetUserData {
  native let scalingInterpolationValue: Float;
}

public native class inkEngineSettingsResource extends CResource {
  native let fallbackCompositionResource: ResourceRef; // rRef<inkFullscreenCompositionResource>
  native let fallbackShapeCollectionResource: ResourceRef; // rRef<inkShapeCollectionResource>
  native let fallbackIconAtlasResource: ResourceRef; // rRef<inkTextureAtlas>
  native let inputKeyIconsDefinitionResource: ResourceAsyncRef; // raRef<JsonResource>
  native let fallbackFontFamilyPath: ResourceRef; // rRef<inkFontFamilyResource>
  native let blackTexture: ResourceRef; // rRef<CBitmapTexture>
  native let advertMissingFormatTexture: ResourceRef; // rRef<CBitmapTexture>
  native let advertWrongResourceTexture: ResourceRef; // rRef<CBitmapTexture>
  native let fallbackTextureAtlas: ResourceRef; // rRef<inkTextureAtlas>
  native let imageTilingMaterial: ResourceRef; // rRef<IMaterial>
  native let imageNineSliceMaterial: ResourceRef; // rRef<IMaterial>
  native let depthMaterial: ResourceRef; // rRef<IMaterial>
  native let whiteMaskAtlas: ResourceRef; // rRef<inkTextureAtlas>
  native let defaultBinkMaterial: ResourceRef; // rRef<CMaterialTemplate>
  native let tooManyBinksTexture: ResourceRef; // rRef<CBitmapTexture>
  native let componentMissingTexture: ResourceRef; // rRef<CBitmapTexture>
}

enum inkEShapeVariant {
  Fill = 0,
  Border = 1,
  FillAndBorder = 2,
}

enum inkETextDirection {
  LeftToRight = 0,
  RightToLeft = 1,
  Mixed = 2,
}

enum inkETextureResolution {
  UltraHD_3840_2160 = 0,
  FullHD_1920_1080 = 1,
  HD_1280_720 = 2,
}

public native class inkFastTravelLoadingControllerSupervisor extends inkGameController {
  native let glitchEffect: ResourceRef; // rRef<worldEffect>
}

public native class inkFinalConfigurationController extends inkLogicController {
  native let visibilityFlag: inkFinalConfigurationVisibility;
}

enum inkFinalConfigurationVisibility {
  VisibleOnlyInFinal = 0,
  HiddenOnlyInFinal = 1,
}

enum inkFitToContentDirection {
  None = 0,
  Horizontal = 2,
  Vertical = 1,
}

public native class inkFitToViewport extends inkUserData {}

enum inkFocusCause {
  Mouse = 0,
  Navigation = 1,
  SetDirectly = 2,
  Cleared = 3,
  OtherWidgetLostFocus = 4,
  WindowActivate = 5,
}

public native class inkFocusEvent extends inkEvent {
  public final native func GetCause()
}

public native class inkFontFamilyResource extends CResource {
  native let familyName: CName;
  native let fontStyles: array<inkFontStyle>;
}

public native struct inkFontStyle {
  native let styleName: CName;
  native let font: ResourceRef; // rRef<rendFont>
}

public abstract native class inkFullscreenCompositionManager extends ISerializable {}

public native class inkFullscreenCompositionResource extends CResource {
  native let compositionPresets: array<inkCompositionPreset>;
  native let backgroundMenuTextureUHDRes: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let backgroundMenuTextureFHDRes: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let previewSettings: ref<inkCompositionPreviewSettings>;
}

public abstract native class inkFullScreenLayer extends inkLayer {}

public native class inkGameNotificationEvt extends Event {}

public native class inkGameNotificationsLayer extends inkFullScreenLayer {}

public native class inkGameSettingsResource extends CResource {
  native let compositionResource: ResourceRef; // rRef<inkFullscreenCompositionResource>
  native let permanentTextureAtlases: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesPC: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesDurango: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesOrbis: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesProspero: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesStadiaSwitch: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesStadia: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesStadiaDurango: array<ResourceAsyncRef>;
  native let permanentTextureAtlasesStadiaOrbis: array<ResourceAsyncRef>;
  native let themes: array<inkStyleThemeDescriptor>;
  native let layersResource: ResourceRef; // rRef<inkLayersResource>
  native let iconReferenceFallbackTextureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let initLoadingScreenLogoLoopVideo: ResourceAsyncRef; // raRef<Bink>
  native let npcNameplateResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let defaultShapeCollectionResource: ResourceRef; // rRef<inkShapeCollectionResource>
  native let globalTVBinkLengthDataResource: ResourceAsyncRef; // raRef<JsonResource>
  native let worldMapFloorplanWidgetResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let gpsAugmentedRealitySignEntity: ResourceAsyncRef; // raRef<entEntityTemplate>
  native let gpsAugmentedRealityWidgetTurnLeft: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let gpsAugmentedRealityWidgetTurnRight: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let gpsAugmentedRealityWidgetTurnBack: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let malePresetResource: ResourceAsyncRef; // raRef<CResource>
  native let femalePresetResource: ResourceAsyncRef; // raRef<CResource>
  native let fallbackHeadCustomizationFpp: ResourceAsyncRef; // raRef<CResource>
  native let fallbackHeadCustomizationTpp: ResourceAsyncRef; // raRef<CResource>
  native let fallbackHeadCustomizationTppFaceRig: ResourceAsyncRef; // raRef<CResource>
  native let fallbackBodyCustomization: ResourceAsyncRef; // raRef<CResource>
  native let fallbackArmsCustomization: ResourceAsyncRef; // raRef<CResource>
  native let vsetSceneResource: ResourceAsyncRef; // raRef<CResource>
  native let keyboardIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let steamIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let durangoIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let orbisIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let prosperoIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let nintendoSwitchIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let stadiaIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let stadiaDurangoIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let stadiaOrbisIconsAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
}

public native class inkGlitchEffect extends inkIEffect {
  native let intensity: Float;
  native let offsetX: Float;
  native let offsetY: Float;
  native let sizeX: Float;
  native let sizeY: Float;
}

public native class inkGradient extends inkBaseShapeWidget {
  native let gradientMode: inkGradientMode;
  native let startColor: HDRColor;
  native let endColor: HDRColor;
  native let angle: Float;
}

enum inkGradientMode {
  Linear = 0,
  Rectangular = 1,
}

public native struct inkGridItem {
  native let rootIdx: Uint32;
}

public native struct inkGridItemTemplate {
  native let sizeX: Uint32;
  native let sizeY: Uint32;
  native let widget: inkWidgetLibraryReference;
}

public native class inkHideLoadingScreenDelayedEvent extends Event {}

public native struct inkHierarchyPooler {}

public native class inkHighwaySignLogicController extends inkIStreetNameSignLogicController {
  native let districtName: inkTextRef;
  native let subDistrictName: inkTextRef;
  native let metroStationIconLeft: inkImageRef;
  native let metroStationIconRight: inkImageRef;
}

public native class inkHudEntriesResource extends CResource {
  native let rootWidget: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let themeOverride: CName;
  native let entries: array<inkHudWidgetSpawnEntry>;
}

public native class inkHudEntryInfo extends inkUserData {
  native let size: Vector2;
  native let offset: Vector2;
  public final native func SetSize()
}

public native class inkHudEntrySpawnedEvent extends Event {}

public native class inkHUDLayer extends inkFullScreenLayer {}

public native class inkHUDScalingMarginAdjustment extends inkInitializedWidgetUserData {
  native let adjustmentMargin: inkMargin;
}

public native class inkHudSystem extends inkIHudSystem {}

public native class inkHudSystemAccessor extends inkILayerSystemAccesor {}

public native class inkHudSystemData extends inkILayerSystemData {
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let entriesResource: ResourceRef; // rRef<inkHudEntriesResource>
}

public native class inkIconAtlas extends inkIIconAtlas {}

public abstract native class inkIDebugSystem extends inkILayerSystem {}

public abstract native class inkIEffect extends ISerializable {
  native let isEnabled: Bool;
  native let effectName: CName;
}

public native class inkIgnoreHUDSafeZones extends inkInitializedWidgetUserData {}

public native class inkIgnoreOnConsoles extends inkUserData {}

public native class inkIgnoresCursorState extends inkUserData {}

public native class inkIgnoreSwapHorizontallyMode extends inkUserData {}

public abstract native class inkIHudSystem extends inkILayerSystem {}

public abstract native class inkIIconAtlas extends IScriptable {}

public abstract native struct inkIIconAtlasManager {}

public abstract native class inkILayerSystem extends IScriptable {}

public abstract native class inkILayerSystemAccesor extends IScriptable {}

public abstract native class inkILayerSystemData extends IScriptable {}

public native struct inkILoadingScreenData {}

public native class inkInitializedWidgetUserData extends inkUserData {}

public native class inkInitialLoadingControllerSupervisor extends gameuiOnscreenVOPlayerController {}

public abstract native class inkInkLayer extends ISerializable {}

public native class inkInnerGlowEffect extends inkIEffect {
  native let colorR: Float;
  native let colorG: Float;
  native let colorB: Float;
  native let colorA: Float;
  native let offsetX: Float;
  native let offsetY: Float;
}

public native class inkInputActionValidityController extends inkLogicController {
  native let invertVisibility: Bool;
  native let inputActionName: CName;
  native let inputValidityDependentWidgets: array<inkWidgetRef>;
}

public native struct inkInputDevicesMappingsJSON {
  native let devices: array<CName>;
  native let mappings: array<inkInputIconMappingJSON>;
}

public native struct inkInputIconMappingJSON {
  native let id: CName;
  native let part: CName;
  native let hold: Bool;
}

public native class inkInputKeyDictionaryJSON extends ISerializable {
  native let devicesMappings: array<inkInputDevicesMappingsJSON>;
}

public native class inkInputKeyIconManager extends ISerializable {}

public native class inkInternationalizationManager extends ISerializable {}

public native class inkIsAbleToSwapHorizontally extends inkUserData {}

public abstract native class inkIStateMachine extends ISerializable {}

public abstract native struct inkIStateMachineState {}

public abstract native class inkIStreetNameSignLogicController extends inkLogicController {}

public abstract native class inkIWaitingSignSystem extends inkILayerSystem {}

public abstract native struct inkIWidgetComponentWrapper {}

public abstract native class inkIWidgetSlotController extends inkLogicController {
  native let slotID: CName;
  native let layout: inkWidgetLayout;
}

public abstract native struct inkIWorldWidgetComponentWrapper {}

public native struct inkLanguageDefinition {
  native let languageCode: CName;
  native let isoScriptCode: CName;
  native let textDirection: inkETextDirection;
  native let fonts: array<inkLanguageFont>;
}

public native struct inkLanguageFont {
  native let font: ResourceAsyncRef; // raRef<inkFontFamilyResource>
  native let mapper: ref<inkLanguageFontMapper>;
}

public native class inkLanguageFontMapper extends ISerializable {
  native let mappings: array<inkLanguageFontMapping>;
}

public native struct inkLanguageFontMapping {
  native let languageCode: CName;
  native let font: ResourceAsyncRef; // raRef<inkFontFamilyResource>
  native let fontSizeModifier: Int16;
  native let trackingModifier: Uint32;
  native let lineHeightModifier: Float;
  native let fontSizeModifierFloat: Float;
  native let styleModifer: CName;
}

enum inkLanguageId {
  EN = 0,
  PL = 1,
  JP = 2,
  DE = 3,
  ES = 4,
  MX = 5,
  KR = 6,
  IT = 7,
  FR = 8,
  RU = 9,
  PR = 10,
  ZH_CN = 11,
  TW = 12,
  CZ = 13,
  HU = 14,
  AR = 15,
  TR = 16,
  TH = 17,
  HT = 18,
  UA = 20,
  DEBUG = 21,
}

enum inkLastTickVideoState {
  NotDrawn = 0,
  Drawn = 1,
  Paused = 2,
}

public abstract native class inkLayer extends ISerializable {}

public native struct inkLayerDefinition_NEW {
  native let name: CName;
  native let layerType: inkELayerType;
  native let drawingPolicy: inkLayerDrawingPolicy;
  native let loadPriority: inkELayerLoadPriority;
  native let enabled: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkLayerDefinitionCollection {
  native let menuLayer: inkMenuLayerDefinition;
  native let menuLayerMP: inkMenuLayerDefinition;
  native let hudLayer: inkHUDLayerDefinition;
  native let videoLayer: inkVideoLayerDefinition;
  native let offscreenLayer: inkOffscreenLayerDefinition;
  native let gameNotificationsLayer: inkGameNotificationsLayerDefinition;
  native let photoModeLayer: inkPhotoModeLayerDefinition;
  native let debugLayer: inkDebugLayerDefinition;
}

public native struct inkLayerDefinitionsSet {
  native let layersDefinitions: array<inkLayerDefinition_NEW>;
  native let layersSystemConnections: array<inkLayerSystemConnection>;
}

enum inkLayerDrawingPolicy {
  InOrder = 0,
  InParallel = 1,
}

public abstract native class inkLayerProxy extends ISerializable {}

public native class inkLayersResource extends CResource {
  native let layerDefinitions: inkLayerDefinitionCollection;
  native let preGameLayerDefinitions: inkLayerDefinitionCollection;
  native let permanentLayerDefinitions: inkPermanentLayerDefinitionCollection;
  native let layerDefinitionsSet: inkLayerDefinitionsSet;
}

public native struct inkLayerSystemConnection {
  native let layerName: CName;
  native let system: ref<inkILayerSystemData>;
}

public native class inkLightSweepEffect extends inkIEffect {
  native let positionX: Float;
  native let positionY: Float;
  native let angle: Float;
  native let width: Float;
  native let intensity: Float;
}

public native class inkLinearWipeEffect extends inkIEffect {
  native let angle: Float;
  native let transition: Float;
}

enum inkLineType {
  RegularPatternSpacing = 0,
  LoosePatternSpacing = 1,
}

public native struct inkLineVertex {
  native let int: Vector2;
  native let neType: inkLineType;
}

public native class inkLoadingLayer extends inkFullScreenLayer {}

public native struct inkLocalizedBink {
  native let binks: array<inkBinkLanguageDescriptor>;
}

enum inkMaskDataSource {
  TextureAtlas = 0,
  DynamicTexture = 1,
}

public native class inkMaskEffect extends inkIEffect {
  native let angle: Float;
  native let opacity: Float;
  native let invert: Bool;
}

public native struct inkMenuEntry {
  native let name: CName;
  native let menuWidget: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let depth: Uint32;
  native let spawnMode: inkSpawnMode;
  native let isAffectedByFadeout: Bool;
  native let inputContext: CName;
}

public native class inkMenuInstance_MenuInstanceListener extends Event {}

public abstract importonly native class inkMenuInstance extends IScriptable {}

public importonly native class inkMenuInstanceImpl extends inkMenuInstance {}

public native class inkMenuLayer extends inkFullScreenLayer {}

public native class inkMenuResource extends CResource {
  native let menusEntries: array<inkMenuEntry>;
  native let scenariosNames: array<CName>;
  native let initialScenarioName: CName;
}

public native class inkMetroSignLogicController extends inkIStreetNameSignLogicController {
  native let stationName: inkTextRef;
  native let subDistrictName: inkTextRef;
  native let metroStationsContainer: inkCompoundRef;
  native let metroStationLibraryName: CName;
  native let metroStationTextWidgetName: CName;
}

public native class inkMoveToTopOfMenu extends inkUserData {}

public native class inkMultiChildren extends inkChildren {
  native let children: array<ref<inkWidget>>;
}

public native class inkMultisamplingEffect extends inkIEffect {}

public native struct inkNavigationOverrideEntry {
  native let from: inkWidgetRef;
  native let direction: inkDiscreteNavigationDirection;
  native let to: inkWidgetRef;
}

public native class inkNewHudSpawnedEvent extends Event {}

public native class inkNoChildren extends inkChildren {}

public native class inkNullIconAtlas extends inkIIconAtlas {}

public native class inkOffscreenLayer extends inkLayer {}

public native class inkOffscreenWidgetSpawnEvt extends Event {}

public native struct inkOnscreenVOData {
  native let text: CRUID;
}

public native struct inkOnscreenVOHandler {}

public native struct inkPermanentLayerDefinitionCollection {
  native let loadingLayer: inkLoadingLayerDefinition;
  native let watermarksLayer: inkWatermarksLayerDefinition;
  native let sysNotificationsLayer: inkSystemNotificationsLayerDefinition;
  native let waitingSignLayerDefinition: inkWaitingSignLayerDefinition;
}

public native class inkPhotoModeLayer extends inkFullScreenLayer {}

public native class inkPointCloudEffect extends inkIEffect {
  native let repeat: Float;
  native let offsetX: Float;
  native let offsetY: Float;
  native let angle: Float;
  native let fovScale: Float;
  native let parallaxDepth: Float;
  native let depthToOpacity: Float;
  native let depthToBrightness: Float;
}

public native class inkPoolIdentifier extends inkUserData {}

public native class inkProcessLoadingScreenDelayedEvent extends Event {}

public native struct inkPropertyBinding {
  native let propertyName: CName;
  native let stylePath: CName;
}

public native class inkPropertyManager extends ISerializable {
  native let bindings: array<inkPropertyBinding>;
}

public native class inkQuadShape extends inkBaseShapeWidget {
  native let textureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let texturePart: CName;
  native let vertexList: array<Vector2>;
}

public native class inkRadialWipeEffect extends inkIEffect {
  native let startAngle: Float;
  native let transition: Float;
}

public native class inkRollingListController extends ListController {
  native let itemsToDisplay: Int32;
  native let convexity: Float;
  native let verticalCompression: Float;
  native let scrollTime: Float;
}

public native class inkRootWidgetIdentifier extends inkUserData {}

public native struct inkRuntimeStylePropertyReference {}

public native class inkScanlineWipeEffect extends inkIEffect {
  native let angle: Float;
  native let transition: Float;
  native let width: Float;
}

public native class inkSelectItemIndexEvent extends Event {}

public native class inkShapeCollectionResource extends CResource {
  native let presets: array<inkShapePreset>;
}

public native struct inkShapePreset {
  native let name: CName;
  native let points: array<Vector2>;
}

public native class inkShapePresetWraper extends ISerializable {
  native let shapePreset: inkShapePreset;
}

public native struct inkSimpleHierarchyPool {}

public native struct inkSingleDrawMetric {
  native let exeedsLimit: Bool;
  native let hierarchySize: Vector2;
  native let usedTextures: array<Uint32>;
}

public native struct inkSize {
  native let width: Float;
  native let height: Float;
}

public abstract native class inkSpawningProcessor extends ISerializable {}

enum inkSpawnMode {
  SingleAndMultiplayer = 0,
  OnlySingleplayer = 1,
  OnlyMultiplayer = 2,
}

enum inkState {
  InitEngine = 0,
  PreGameMenu = 3,
  InitialLoading = 4,
  Game = 5,
  InGameMenu = 6,
  PauseMenu = 7,
  FastTravelLoading = 8,
  PhotoMode = 9,
  MiniGameMenu = 10,
  EndGameLoading = 11,
  EditorMode = 12,
}

public abstract native class inkStateMachine extends inkIStateMachine {}

public native class inkStateTransitionAnimationController extends inkLogicController {
  native let transition: array<inkWidgetStateAnimatedTransition>;
  native let stopActiveAnimation: Bool;
}

public native class inkStreetNameSignLogicController extends inkIStreetNameSignLogicController {
  native let streetName: inkTextRef;
  native let districtName: inkTextRef;
  native let subdistrictName: inkTextRef;
}

public native class inkStreetSignsLayer extends inkWorldFluffLayer {}

public native struct inkStyle {
  native let styleID: CName;
  native let state: CName;
  native let properties: array<inkStyleProperty>;
}

public native struct inkStyleOverride {
  native let overrideType: inkStyleOverrideType;
  native let styleResource: ResourceRef; // rRef<inkStyleResource>
}

enum inkStyleOverrideType {
  Invalid = 0,
  BigFont = 1,
  FluffReduction = 2,
}

public native struct inkStyleProperty {
  native let propertyPath: CName;
  native let value: Variant;
}

public native struct inkStylePropertyReference {
  native let referencedPath: CName;
}

public native class inkStyleResource extends CResource {
  native let styles: array<inkStyle>;
  native let styleImports: array<ResourceRef>;
  native let themes: array<inkStyleTheme>;
  native let overrides: array<inkStyleOverride>;
  native let hideInInheritingStyles: Bool;
}

public native class inkStyleResourceWrapper extends ISerializable {
  native let styleResource: ResourceAsyncRef; // raRef<inkStyleResource>
}

public native struct inkStyleTheme {
  native let themeID: CName;
  native let styleResource: ResourceRef; // rRef<inkStyleResource>
}

public native struct inkStyleThemeDescriptor {
  native let themeID: CName;
  native let themeNameLocKey: CName;
}

public native class inkSubtitlesLanguageOverride extends inkUserData {}

public native class inkSystemNotificationEvt extends Event {}

public native class inkSystemNotificationsLayer extends inkFullScreenLayer {}

public native class inkSystemNotificationToken extends IScriptable {}

enum inkTextReplaceAnimationControllerWidgetTextUsage {
  BaseText = 0,
  TargetText = 1,
  NoUsage = 2,
}

public native class inkTextureAtlas extends CResource {
  native let activeTexture: inkTextureType;
  native let textureResolution: inkETextureResolution;
  native let texture: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let dynamicTexture: ResourceAsyncRef; // raRef<DynamicTexture>
  native let parts: array<inkTextureAtlasMapper>;
  native let slices: array<inkTextureAtlasSlice>;
  native let dynamicTextureSlot: inkDynamicTextureSlot;
  native let isSingleTextureMode: Bool;
}

public native struct inkTextureAtlasMapper {
  native let partName: CName;
  native let clippingRectInPixels: Rect;
  native let clippingRectInUVCoords: RectF;
}

public native struct inkTextureAtlasSlice {
  native let partName: CName;
  native let nineSliceScaleRect: RectF;
}

public native struct inkTextureSlot {
  native let texture: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let parts: array<inkTextureAtlasMapper>;
  native let slices: array<inkTextureAtlasSlice>;
}

enum inkTextWrappingPolicy {
  SingleLine = 0,
  MultiLine = 1,
  MultilineNoWrap = 2,
}

public native class inkTutorialOverlayInputRequest extends Event {
  native let isInputRequested: Bool;
}

public native class inkTypographyResource extends CResource {
  native let languages: array<inkLanguageDefinition>;
}

public native struct inkUITransform {
  native let translation: Vector2;
  native let scale: Vector2;
  native let shear: Vector2;
  native let rotation: Float;
}

enum inkVideoInstanceDoneReason {
  Failed = 0,
  Stopped = 1,
  Finished = 2,
}

public native class inkVideoLayer extends inkFullScreenLayer {}

enum inkVideoOptimizationState {
  None = 0,
  TooManyBinks = 1,
  FullscreenBinkVisible = 2,
}

public native class inkVideoSequenceController extends inkLogicController {
  native let videoWidget: inkVideoRef;
  native let videoSequence: array<inkVideoSequenceEntry>;
}

public native struct inkVideoSequenceEntry {
  native let videoResource: ResourceAsyncRef; // raRef<Bink>
  native let audioEvent: CName;
  native let syncToAudio: Bool;
  native let retriggerAudioOnLoop: Bool;
  native let loop: Bool;
}

public native class inkVirtualWindow extends inkWindow {}

public native class inkVisualStatePopStateMachineEvent extends Event {}

public native class inkVORequestEvt extends Event {}

public native class inkWaitingSignLayer extends inkFullScreenLayer {}

public native class inkWaitingSignSystem extends inkIWaitingSignSystem {}

public native class inkWatermarksLayer extends inkFullScreenLayer {}

public native class inkWidgetBackendData extends IBackendData {
  native let owner: wref<inkWidget>;
  native let isHiddenInEditor: Bool;
  native let isLocked: Bool;
  native let boundLibraryItemName: CName;
}

public native class inkWidgetBrush extends IScriptable {
  native let textureAtlas: ResourceRef; // rRef<inkTextureAtlas>
  native let texturePartId: CName;
  native let tileType: inkBrushTileType;
  native let mirrorType: inkBrushMirrorType;
  public final native func GetMirrorType()
  public final native func GetTexturePart()
  public final native func GetTileType()
  public final native func IsTexturePartExist()
  public final native func SetTexturePart()
}

public native class inkWidgetBrushResource extends CResource {
  native let brush: ref<inkWidgetBrush>;
}

public native class inkWidgetClipboardData extends ISerializable {
  native let widget: ref<inkWidget>;
  native let widgetPath: inkWidgetPath;
}

public native struct inkWidgetCompositor {}

public native struct inkWidgetLibraryItem {
  native let name: CName;
}

public native class inkWidgetLibraryItemClipboardData extends ISerializable {
  native let libraryItem: ref<inkWidgetLibraryItemUnpackedView>;
}

public native class inkWidgetLibraryItemInstance extends ISerializable {
  native let rootWidget: ref<inkWidget>;
  native let gameController: ref<inkIGameController>;
  native let rootResolution: inkETextureResolution;
}

public native class inkWidgetLibraryItemUnpackedView extends ISerializable {
  native let name: CName;
  native let instance: ref<inkWidgetLibraryItemInstance>;
}

public native class inkWidgetLibraryUnpackedView extends ISerializable {
  native let libraryItems: array<ref<inkWidgetLibraryItemUnpackedView>>;
  native let externalLibraries: array<ResourceRef>;
}

enum inkWidgetResourceVersion {
  Default = 0,
  BrushToAtlas = 1,
}

public native struct inkWidgetSlotAttachmentParams {
  native let slotID: CName;
  native let useSlotLayout: Bool;
  native let layoutOverride: inkWidgetLayout;
}

public native class inkWidgetSlotController extends inkIWidgetSlotController {}

public native struct inkWidgetStateAnimatedTransition {
  native let startState: CName;
  native let endState: CName;
  native let animationName: CName;
  native let playbackOptions: inkAnimOptions;
}

public native class inkWindow extends inkCanvas {}

public native struct inkWindowDrawMetrics {
  native let allTextures: array<Vector2>;
  native let textureSizeTypes: array<Vector2>;
  native let textureTypeTotal: array<Uint32>;
  native let maxUsedTextureTypes: array<Uint32>;
  native let drawMetrics: array<inkSingleDrawMetric>;
}

public abstract native class inkWorldFluffLayer extends inkLayer {}

public native class inkWorldLayer extends inkLayer {}

public abstract native class inkWorldWidgetComponentUserData extends inkUserData {}

enum inputEInputDevice {
  INVALID = 0,
  KBD_MOUSE = 1,
  ORBIS = 2,
  DURANGO = 3,
  STEAM = 4,
  XINPUT_PAD = 5,
  STADIA = 6,
  NINTENDO_SWITCH = 7,
  SCARLETT_GAMEPAD = 8,
  PROSPERO = 9,
  EID_COUNT = 10,
}

public native class InputHintController extends inkLogicController {
  native let inputDisplayLibRef: inkWidgetLibraryReference;
  native let inputDisplayContainer: inkCompoundRef;
  native let textWidgetRef: inkTextRef;
}

public native class InputHintGroupController extends inkLogicController {
  native let titleTextRef: inkTextRef;
  native let descriptionTextRef: inkTextRef;
  native let hintsContainerRef: inkCompoundRef;
  native let iconRef: inkImageRef;
}

public abstract native struct inputIInputSystem {}

public native class InternalFunctionalTestsRuntimeSystem extends FunctionalTestsIRuntimeSystem {}

public native struct interopDispatchPrefabProxyJobsResult {
  native let numProxyJobsDispatched: Uint32;
  native let numProxyJobsSkipped: Uint32;
  native let numProxyJobsFailed: Uint32;
}

public native struct interopEntityEffectSelectionSyncData {
  native let effectName: CName;
  native let effectIDPath: toolsEditorObjectIDPath;
}

public native struct interopEntityEffectSpawnerSyncData {
  native let componentName: CName;
  native let effects: array<interopEntityEffectSelectionSyncData>;
  native let templatePath: String;
  native let templateColor: Color;
  native let included: Bool;
}

public native struct interopGlobalNodeIDInfo {
  native let globalName: String;
  native let globalNodeIDPath: String;
  native let globalNodeIDHash: Uint64;
  native let globalNameIsAutoGenerated: Bool;
}

public native struct interopGlobalNodeIDResult {
  native let errorMessage: String;
  native let result: String;
  native let isValid: Bool;
}

public native struct interopGraphConnectionCreationData {
  native let data: String;
  native let extraData: array<String>;
}

public native struct interopMaterialListDescriptor {
  native let chunksInfo: String;
  native let chunksLODInfo: String;
  native let numLayers: Uint32;
  native let isForward: Bool;
  native let isMultilayer: Bool;
  native let isLocalInstance: Bool;
  native let isTemplate: Bool;
  native let itemMaterialIndex: Uint32;
  native let materialName: String;
  native let appearanceName: String;
  native let availableMaterials: array<String>;
}

public native struct interopNodeTransformInfo {
  native let id: interopStringWithID;
  native let transformInfo: interopTransformInfo;
}

public native struct interopOpaqueData {
  native let description: String;
  native let payload: String;
  native let version: Int32;
}

public native struct interopReExportOptions {
  native let occlusionExportOptNames: array<CName>;
  native let occlusionExportOptValues: array<Bool>;
  native let typeExportOptions: array<Bool>;
  native let filePath: String;
  native let runDispatcher: Bool;
  native let files: array<String>;
  native let depotPath: String;
  native let maskDumpFilePath: AbsolutePathSerializable;
  native let exportMaterials: Bool;
  native let hjobToken: String;
  native let hjobParams: String;
  native let hjobParamsOutput: String;
  native let assetName: String;
  native let rigs: String;
  native let hjobTemplate: String;
  native let bodyType: String;
  native let baseType: String;
  native let exportBounds: Box;
  native let referencePoint: Vector3;
  native let assetPaths: array<String>;
  native let jsonFile: AbsolutePathSerializable;
  native let prefabType: Uint8;
  native let proxyFromProxy: Bool;
  native let onlyProxy: Bool;
  native let exportTextures: Bool;
  native let minBBoxDiag: Double;
  native let asBBoxThreshold: Double;
  native let asBBoxPrefabsThreshold: Double;
  native let asBBoxPrefabsSubdivide: Double;
  native let asBBoxPrefabsForceLast: Bool;
  native let skipCollisions: Bool;
  native let preferSmallProxiesTreshold: Float;
  native let generatePlayerBlockingCollision: Bool;
}

public native struct interopRTTIClassDump {
  native let classNames: array<String>;
  native let descriptiveNames: array<String>;
  native let resourceInfos: array<interopRTTIResourceDumpInfo>;
  native let entries: array<interopRTTIClassDumpEntry>;
}

public native struct interopRTTIClassDumpEntry {
  native let i: Int32;
  native let b: Int32;
  native let r: Int32;
  native let a: Int32;
}

public native struct interopRTTIResourceDumpInfo {
  native let extension: String;
  native let deprecatedExtension: String;
  native let friendlyDescription: String;
}

public native struct interopSelectByDefinitionOptions {
  native let searchInSelection: Bool;
  native let minBBoxDiagonalLength: Float;
  native let maxBBoxDiagonalLength: Float;
  native let maxBBoxParentPercantageDiagonalLength: Float;
  native let includePrefabNodes: Bool;
  native let includeDecalNodes: Bool;
  native let includeMeshNodes: Bool;
}

public native struct interopSelectionChangeInfo {
  native let selected: array<Uint64>;
  native let deselected: array<Uint64>;
}

public native struct interopStringUint64Pair {
  native let string: String;
  native let number: Uint64;
}

public native struct interopStringWithID {
  native let text: String;
  native let id: Uint64;
}

public native struct interopTerrainEditToolCreationSlotInfo {
  native let scale: Vector2;
  native let heightMappingOverrideEnable: Bool;
  native let heightMappingMin: Float;
  native let heightMappingMax: Float;
}

public native struct interopTerrainEditToolInfo {
  native let defaultHeightmapMode: Int32;
  native let defaultEmptyHeightmapWidth: Int32;
  native let defaultEmptyHeightmapHeight: Int32;
  native let defaultEmptyHeightmapMaskFalloff: Float;
  native let defaultEmptyHeightmapMaskRoundness: Float;
  native let defaultEmptyHeightmapZeroMaskMargin: Uint32;
  native let defaultHeightmap1: String;
  native let defaultHeightmap2: String;
  native let defaultColormap1: String;
  native let defaultColormap2: String;
  native let creationSlots: array<interopTerrainEditToolCreationSlotInfo>;
}

public native struct interopTerrainImportedTile {
  native let heightMapAbsolutePath: String;
  native let controlMapAbsolutePath: String;
  native let colorMapAbsolutePath: String;
  native let position: Point;
}

public native struct interopTerrainImportParams {
  native let cellRes: Uint32;
  native let cellSize: Uint32;
  native let scale: Vector3;
  native let position: Vector3;
  native let extraOffset: Vector2;
  native let tileWidth: Uint32;
  native let tileHeight: Uint32;
  native let prefabPlacementInterval: Uint32;
  native let importHeightMaps: Bool;
  native let importColorMaps: Bool;
  native let importControlMaps: Bool;
  native let overwriteTransformsOfExistingNodes: Bool;
  native let nodesNamingPattern: String;
  native let prefabsNamingPattern: String;
  native let prefabsDestinationPath: String;
  native let dstPrefabNodePath: toolsEditorObjectIDPath;
}

public native struct interopTerrainNodeInfo {
  native let width: Uint32;
  native let height: Uint32;
  native let externalDataSource: Bool;
  native let isTerrainNode: Bool;
  native let blendOrder: Uint8;
  native let blendModeHeightIsIgnore: Bool;
  native let blendModeHeightIsNormal: Bool;
  native let blendModeColorIsIgnore: Bool;
  native let blendModeHolesIsIgnore: Bool;
  native let terrainSysID: Uint16;
  native let nodeName: String;
  native let nodeScale: Vector3;
  native let nodeTransform: Transform;
  native let nodeCellResScale: Float;
  native let densityTexelSize: Float;
  native let nodeIDPath: toolsEditorObjectIDPath;
}

public native struct interopTerrainSystemInstanceInfo {
  native let cellSize: Uint32;
  native let cellRes: Uint32;
  native let numUsedCells: Uint32;
  native let numPatches: Uint32;
  native let numPatchesFromTerrainNodes: Uint32;
  native let numPatchesFromRoadNodes: Uint32;
  native let isEnabled: Bool;
  native let isVisibleCompiled: Bool;
  native let useDebugDraw: Bool;
  native let gridWidth: Uint32;
  native let gridHeight: Uint32;
  native let numUsedLODCells: array<Uint32>;
}

public native struct interopTransformInfo {
  native let translation: Vector3;
  native let rotation: EulerAngles;
}

public native struct interopUint64Pair {
  native let first: Uint64;
  native let second: Uint64;
}

public native class InventoryPrereq extends IComparisonPrereq {
  native let itemID: ItemID;
  native let amount: Uint32;
}

public native class InventoryPrereqState extends PrereqState {}

public importonly native class InventoryPS extends GameComponentPS {
  native persistent let isRegisteredShared: Bool;
  native persistent let accessible: Bool;
}

public abstract native class IObjectCarrySystem extends IGameSystem {}

public abstract native class IObjectScriptBase extends IScriptable {
  native let gameObject: ref<GameObject>;
  public final native func GetGameObject()
}

public abstract native class IParticleDrawer extends ISerializable {
  native let pivotOffset: Float;
}

public abstract native class IParticleEvent extends IParticleModule {
  native let eventName: CName;
}

public abstract native class IParticleInitializer extends IParticleModule {
  native let seed: Uint32;
}

public abstract native class IParticleModificator extends IParticleInitializer {}

public abstract native class IParticleModule extends ISerializable {
  native let editorName: String;
  native let editorGroup: String;
  native let isEnabled: Bool;
}

public abstract native struct IRenderProxyCustomData {}

public abstract native class IRenderResourceBlob extends ISerializable {}

public abstract native class IRichPresenceSystem extends IGameSystem {}

public abstract native class IRPGPrereq extends IComparisonPrereq {}

public abstract native struct ISceneStorageCustomData {}

public abstract native class ISmartObjectManager extends IGameSystem {}

public native struct IsQuickhackPanelOpenedPrereq {
  native let inverted: Bool;
}

public native struct IsQuickhackPanelOpenedPrereqState {}

public native class IsVisualizerActivePrereq extends IPrereq {}

public native class IsVisualizerActivePrereqState extends PrereqState {}

public native class ItemDecorationEvent extends Event {}

public native class itempreviewUIObjectsLoaderSystemListener extends gameuiIUIObjectsLoaderSystemListener {}

public abstract native class ITexture extends CResource {}

public abstract native class ITierSystem extends IGameSystem {}

public abstract native class ITonemappingMode extends ISerializable {
  native let colorPreservation: CurveDataFloat;
}

public abstract native class IUIIconsGeneratorSystem extends IGameSystem {}

public native class IUpdatableSystem extends IScriptable {}

public abstract native class IWorkspotManager extends IGameSystem {}

public native class JoinTrafficEvent extends AIEvent {}

public native class JournalBriefing extends JournalFileEntry {}

enum JournalCallbackOption {
  DoNotFire = 0,
  Fire = 1,
}

public native class JournalContactModifierEntry extends JournalEntry {}

public native class JournalPointOfInterestGroup extends JournalFileEntry {}

public native class JournalPointOfInterestMappin extends JournalEntry {
  native let staticNodeRef: NodeRef;
  native let dynamicEntityRef: EntityReference;
  native let securityAreaRef: NodeRef;
  native let mappinData: PointOfInterestMappinData;
  native let offset: Vector3;
  native let questPath: ref<gameJournalPath>;
  native let recommendedLevelID: TweakDBID;
  native let notificationTriggerAreaRef: NodeRef;
}

public native class JournalQuestMultiMapPin extends JournalQuestMapPinBase {
  native let references: array<NodeRef>;
  native let slotName: CName;
  native let mappinData: MappinData;
  native let offset: Vector3;
  native let uiAnimation: TweakDBID;
}

public native class JournalQuestPointOfInterestMapPin extends JournalQuestMapPinBase {}

public native class JournalQuestTitleModifier extends JournalEntry {
  native let title: LocalizationString;
  public final native func GetTitle()
}

public native struct JournalRequestClassFilter {
  native let className: CName;
}

public native class JsonResource extends CResource {
  native let root: ref<ISerializable>;
}

public native struct LanguageSpecificImagData {
  native let languageID: inkLanguageId;
  native let textureAtlasForLanguage: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let partNameForLanguage: CName;
}

public native class LanguageSpecificImageController extends inkLogicController {
  native let languages: array<LanguageSpecificImagData>;
  native let fallbackTextureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let fallbackPartName: CName;
}

public native class LanguageSpecificVideoController extends inkLogicController {
  native let isLooped: Bool;
  native let specificVideoForLanguage: ResourceAsyncRef; // raRef<Bink>
  native let languages: array<inkLanguageId>;
  native let fallbackVideo: ResourceAsyncRef; // raRef<Bink>
}

public abstract native class LibTreeCMetanodeDefinition extends LibTreeINodeDefinition {}

public native class LibTreeCMetanodeIfDefinition extends LibTreeCMetanodeDefinition {
  native let ifCondition: LibTreeDefBool;
  native let ifBranch: ref<LibTreeINodeDefinition>;
  native let elseBranch: ref<LibTreeINodeDefinition>;
}

public abstract native class LibTreeCTreeReference extends ISerializable {
  native let TreeDefinition: ResourceRef; // rRef<LibTreeCTreeResource>
  native let parameters: LibTreeParameterList;
}

public abstract native class LibTreeCTreeResource extends CResource {
  native let variables: LibTreeDefTreeVariablesList;
}

public native struct LibTreeDefBool {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: Bool;
}

public native struct LibTreeDefCName {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: CName;
}

public native struct LibTreeDefEnum {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: Int64;
}

public native struct LibTreeDefFloat {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: Float;
}

public native struct LibTreeDefInt32 {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: Int32;
}

public native struct LibTreeDefISerializable {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: ref<ISerializable>;
}

public native struct LibTreeDefNodeRef {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: NodeRef;
}

public native struct LibTreeDefTree {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: ref<LibTreeCTreeReference>;
}

public native struct LibTreeDefTreeList {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: array<ref<LibTreeCTreeReference>>;
}

public abstract native class LibTreeDefTreeVariable extends ISerializable {
  native let id: Uint16;
  native let readableName: CName;
}

public native class LibTreeDefTreeVariableBool extends LibTreeDefTreeVariableBoolBase {
  native let exportAsProperty: Bool;
  native let defaultValue: Bool;
}

public abstract native class LibTreeDefTreeVariableBoolBase extends LibTreeDefTreeVariable {}

public native class LibTreeDefTreeVariableCName extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: CName;
}

public native class LibTreeDefTreeVariableEnum extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let enumClass: CName;
  native let defaultValue: Int64;
}

public native class LibTreeDefTreeVariableFloat extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: Float;
}

public native class LibTreeDefTreeVariableInt32 extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: Int32;
}

public abstract native class LibTreeDefTreeVariableISerializable extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
}

public native class LibTreeDefTreeVariableNodeRef extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: NodeRef;
}

public native struct LibTreeDefTreeVariablesList {
  native let list: array<ref<LibTreeDefTreeVariable>>;
}

public native class LibTreeDefTreeVariableTreeRef extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: ref<LibTreeCTreeReference>;
}

public native class LibTreeDefTreeVariableTreeRefList extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: array<ref<LibTreeCTreeReference>>;
}

public native class LibTreeDefTreeVariableVector extends LibTreeDefTreeVariable {
  native let exportAsProperty: Bool;
  native let defaultValue: Vector3;
}

public native struct LibTreeDefVector {
  native let variableId: Uint16;
  native let treeVariable: CName;
  native let v: Vector3;
}

enum LibTreeEParameterType {
  PARAM_Bool = 0,
  PARAM_Int32 = 1,
  PARAM_Enum = 2,
  PARAM_Float = 3,
  PARAM_CName = 4,
  PARAM_TreeRef = 5,
  PARAM_TreeRefList = 6,
  PARAM_NodeRef = 7,
  PARAM_Vector = 9,
}

public native struct LibTreeGenericData {}

public abstract native class LibTreeINodeDefinition extends ISerializable {}

public native struct LibTreeParameter {
  native let parameterName: CName;
  native let parameterId: Uint16;
  native let parameterType: LibTreeEParameterType;
  native let value: Variant;
}

public native struct LibTreeParameterList {
  native let parameters: array<LibTreeParameter>;
}

public native struct LibTreeParametersForwarder {
  native let overrides: array<Uint32>;
}

public native struct LibTreeSharedVarReferenceName {
  native let name: CName;
}

public native struct LibTreeSharedVarRegistrationName {
  native let name: CName;
}

public native class LightAreaSettings extends IAreaSettings {
  native let latitude: CurveDataFloat;
  native let season: ETimeOfYearSeason;
  native let sunRotationOffset: CurveDataFloat;
  native let sunColor: CurveDataHDRColor;
  native let sunSize: CurveDataFloat;
  native let moonRotationOffset: CurveDataFloat;
  native let moonColor: CurveDataHDRColor;
  native let moonSize: CurveDataFloat;
  native let specularTint: CurveDataHDRColor;
}

public native class LightChannelComponent extends IVisualComponent {
  native let isEnabled: Bool;
  native let shape: ref<GeometryShape>;
}

public native class LightColorSettings extends IAreaSettings {
  native let light: worldWorldGlobalLightParameters;
}

public native class LightDirectionSettings extends IAreaSettings {
  native let direction: GlobalLightingTrajectoryOverride;
}

public native class LightGroupsAreaSettings extends IAreaSettings {
  native let groupFade: [CurveDataFloat; 8];
}

public native struct LoadoutData {
  native let slotID: TweakDBID;
  native let itemID: ItemID;
}

public native class localizationPersistenceCLNumberDateContainer extends ISerializable {
  native let clNumber: CName;
  native let clTimestamp: CName;
  native let clGeneratedIds: array<String>;
}

public native class localizationPersistenceLocDataMap extends ISerializable {
  native let entries: array<localizationPersistenceLocDataMapEntry>;
}

public native struct localizationPersistenceLocDataMapEntry {
  native let langCode: CName;
  native let onscreensPath: ResourceAsyncRef; // raRef<JsonResource>
  native let subtitlePath: ResourceAsyncRef; // raRef<JsonResource>
}

public native class localizationPersistenceOnScreenEntries extends ISerializable {
  native let entries: array<localizationPersistenceOnScreenEntry>;
}

public native struct localizationPersistenceOnScreenEntry {
  native let primaryKey: Uint64;
  native let secondaryKey: String;
  native let femaleVariant: String;
  native let maleVariant: String;
}

public native class localizationPersistenceSubtitleEntries extends ISerializable {
  native let entries: array<localizationPersistenceSubtitleEntry>;
}

public native struct localizationPersistenceSubtitleEntry {
  native let stringId: CRUID;
  native let femaleVariant: String;
  native let maleVariant: String;
}

public native class localizationPersistenceSubtitleMap extends ISerializable {
  native let entries: array<localizationPersistenceSubtitleMapEntry>;
}

public native struct localizationPersistenceSubtitleMapEntry {
  native let subtitleGroup: CName;
  native let subtitleFile: ResourceAsyncRef; // raRef<JsonResource>
}

enum locHolocallActorMode {
  Default = 0,
  ActorUsesHolocall = 1,
  ActorDoesntUseHolocall = 2,
}

enum locVoiceoverContext {
  Vo_Context_Quest = 0,
  Vo_Context_Community = 1,
  Vo_Context_Combat = 2,
  Vo_Context_Minor_Activity = 3,
  Default_Vo_Context = 5,
}

enum locVoiceoverExpression {
  Vo_Expression_Spoken = 0,
  Vo_Expression_Phone = 1,
  Vo_Expression_InnerDialog = 2,
  Vo_Expression_Loudspeaker_Room = 3,
  Vo_Expression_Loudspeaker_Street = 4,
  Vo_Expression_Loudspeaker_City = 5,
  Vo_Expression_Radio = 6,
  Vo_Expression_GlobalTV = 7,
  Vo_Experession_Cb_Radio = 8,
  Vo_Expression_Cyberspace = 9,
  Vo_Expression_Possessed = 10,
  Vo_Expression_Helmet = 11,
}

public native class locVoiceoverLengthMap extends ISerializable {
  native let entries: array<locVoLengthEntry>;
}

public native class locVoiceoverMap extends ISerializable {
  native let entries: array<locVoLineEntry>;
}

public native struct locVoiceTag {
  native let voiceTag: CName;
  native let voicesetScenePath: String;
  native let id: CRUID;
  native let isApuc: Bool;
}

enum locVoiceTagGender {
  Undefined = 0,
  Male = 1,
  Female = 2,
}

public native class locVoiceTagListResource extends CResource {
  native let voiceTags: array<locVoiceTag>;
}

public native struct locVoLanguageDataEntry {
  native let languageCode: CName;
  native let voiceverMapReport: ResourceAsyncRef; // raRef<JsonResource>
  native let lengthMapReport: ResourceAsyncRef; // raRef<JsonResource>
  native let voMapChunks: array<ResourceAsyncRef>;
}

public native class locVoLanguageDataMap extends ISerializable {
  native let entries: array<locVoLanguageDataEntry>;
}

public native struct locVoLengthEntry {
  native let stringId: CRUID;
  native let femaleLength: Float;
  native let maleLength: Float;
}

public native struct locVoLineEntry {
  native let stringId: CRUID;
  native let femaleResPath: ResourceAsyncRef; // raRef<locVoResource>
  native let maleResPath: ResourceAsyncRef; // raRef<locVoResource>
}

public native class locVoResource extends CResource {}

public native struct LookAtPartInfo {
  native let partName: CName;
  native let defaultPositionBoneName: CName;
}

public native struct LookAtPartsDependency {
  native let masterPart: CName;
  native let slavePart: CName;
  native let angle: Float;
  native let speedToTargetFactor: Float;
  native let speedToTargetByAngleCurve: CurveDataFloat;
  native let verticalPullSpeedFactor: Float;
  native let verticalPullSpeedByAngleCurve: CurveDataFloat;
  native let horizontalPullSpeedFactor: Float;
  native let horizontalPullSpeedByAngleCurve: CurveDataFloat;
  native let pullScaleBySquareSizeFactor: Float;
  native let pullScaleBySquareSizeCurve: CurveDataFloat;
  native let innerSquareScale: Float;
}

public native struct LookAtStateMachineSettings {
  native let partName: CName;
  native let partAlias: CName;
  native let sphereAttachmentBone: CName;
  native let sphereRadius: Float;
  native let followingSpeedFactor: Float;
  native let followingSpeedByAngleCurve: CurveDataFloat;
  native let enableFloatTrack: CName;
  native let eyesOverrideFloatTrack: CName;
  native let transitionSpeedMultiplier: Float;
  native let blendWeightPowFactor: Float;
  native let coneLimitReached: CName;
  native let allowToBlendBehindBack: Bool;
}

public importonly native class LoSFinderSystem extends ILoSFinderSystem {}

public importonly native class MappinComponent extends IPlacedComponent {
  native let data: MappinData;
}

public native struct MaterialLayerDef {
  native let name: CName;
  native let size: Uint32;
  native let colorPalette: array<Color>;
  native let material: ResourceRef; // rRef<CMaterialInstance>
}

public native struct MaterialParameterInstance {
  native let name: CName;
  native let data: Variant;
}

public native struct MaterialPass {
  native let stagePassNameRegular: CName;
  native let stagePassNameDiscarded: CName;
  native let depthStencilMode: PSODescDepthStencilModeDesc;
  native let rasterizerMode: PSODescRasterizerModeDesc;
  native let blendMode: PSODescBlendModeDesc;
  native let stencilReadMask: Uint8;
  native let stencilWriteMask: Uint8;
  native let stencilRef: Uint8;
  native let orderIndex: Uint8;
  native let enablePixelShader: Bool;
}

public native struct MaterialTechnique {
  native let passes: array<MaterialPass>;
  native let featureFlagsEnabledMask: FeatureFlagsMask;
  native let streamsToBind: Uint32;
}

public native struct MaterialUsedParameter {
  native let name: CName;
  native let register: Uint8;
}

public native class mathExprExpression extends ISerializable {
  native let tokenData: array<Uint32>;
  native let valuesData: array<Float>;
  native let returnVarType: Uint16;
}

public native class MergedMesh extends CMesh {}

public native struct meshChunkFlags {
  native let renderInScene: Bool;
  native let renderInShadows: Bool;
  native let isTwoSided: Bool;
  native let isRayTracedEmissive: Bool;
  native let isConsoleLOD0: Bool;
  native let skipDynamicDecalGeneration: Bool;
}

public native struct meshChunkIndicesOffset {
  native let start: Uint32;
  native let count: Uint32;
  native let boneIndex: Uint8;
}

public native struct meshChunkMaterials {
  native let materialNames: array<CName>;
}

public native struct meshChunkOffset {
  native let chunkIndex: Uint32;
  native let start: Uint16;
  native let count: Uint16;
}

public native struct meshCookedClothMeshTopologyData {
  native let gfxIndexToTriangles: array<Uint32>;
  native let phxIndexToTriangles: array<Uint32>;
  native let gfxBarycentrics: array<Uint32>;
  native let phxBarycentrics: array<Uint32>;
  native let phxLodSwitchData: array<Uint32>;
  native let phxSimulated: array<Uint32>;
  native let gfxNumIndicesToTriangles: Uint32;
  native let phxNumIndicesToTriangles: Uint32;
  native let gfxNumBarycentrics: Uint32;
  native let phxNumBarycentrics: Uint32;
  native let phxNumLodSwitchData: Uint32;
  native let phxNumSimulated: Uint32;
}

public native struct meshDestructionBond {
  native let bondIndex: Uint16;
  native let bondHealth: Uint8;
}

public native struct meshGfxClothChunkData {
  native let simulation: array<Uint16>;
}

public native struct meshImportedSnapTags {
  native let includeTags: array<CName>;
  native let excludeTags: array<CName>;
}

public native struct meshLocalMaterialHeader {
  native let offset: Uint32;
  native let size: Uint32;
}

public native class meshMeshAppearance extends ISerializable {
  native let name: CName;
  native let chunkMaterials: array<CName>;
  native let tags: array<CName>;
}

public native class meshMeshImportedSnapPoint extends ISerializable {
  native let localToCloud: Matrix;
  native let range: Float;
  native let rotationAlignmentSteps: Uint8;
  native let snapTags: meshImportedSnapTags;
}

public native struct meshMeshMaterialBuffer {
  native let rawDataHeaders: array<meshLocalMaterialHeader>;
}

public native class meshMeshParamBakedDestructionData extends meshMeshParameter {
  native let regionData: array<meshRegionData>;
}

public native class meshMeshParamBendedRoad extends meshMeshParameter {
  native let occInds: array<Uint16>;
  native let occVerts: array<Vector4>;
  native let occSkinWeights: array<Vector4>;
  native let occSkinInds: array<Color>;
  native let collInds: array<array<Uint16>>;
  native let collVerts: array<array<Vector3>>;
  native let collSkinWeights: array<array<Vector4>>;
  native let collSkinInds: array<array<Color>>;
  native let collMaterialName: array<String>;
  native let collFilterPresetName: array<String>;
  native let collFaceMatInds: array<array<Uint16>>;
  native let collFaceMaterialNames: array<array<String>>;
}

public native class meshMeshParamCloth_Graphical extends meshMeshParameter {
  native let lodChunkIndices: array<array<Uint16>>;
  native let chunks: array<meshGfxClothChunkData>;
  native let latchers: array<array<array<Uint16>>>;
}

public native class meshMeshParamCloth extends meshMeshParameter {
  native let lodChunkIndices: array<array<Uint16>>;
  native let chunks: array<meshPhxClothChunkData>;
  native let drivers: array<array<Uint16>>;
  native let capsules: ref<physicsclothClothCapsuleExportData>;
}

public native class meshMeshParamCompiledPhysics extends meshMeshParameter {
  native let collection: ref<physicsDeferredCollection>;
}

public native class meshMeshParamDeformableShapesData extends meshMeshParameter {
  native let ownerIndex: array<Uint8>;
  native let startingPose: array<Transform>;
  native let finalPose: array<Transform>;
}

public native class meshMeshParamDestructionBonds extends meshMeshParameter {
  native let bonds: array<meshDestructionBond>;
}

public native class meshMeshParamDestructionBoneChunkMapping extends meshMeshParameter {
  native let boneChunkMasks: array<Uint64>;
}

public native class meshMeshParamDestructionChunkIndicesOffsets extends meshMeshParameter {
  native let offsets: array<meshChunkIndicesOffset>;
  native let chunkOffsets: array<Uint32>;
}

public native class meshMeshParamDestructionStepData extends meshMeshParameter {
  native let offsets: array<physicsDestructionHierarchyOffset>;
  native let isInstantRemovable: String;
}

public abstract native class meshMeshParameter extends ISerializable {}

public native class meshMeshParamGarmentSupport extends meshMeshParameter {
  native let chunkCapVertices: array<array<Uint32>>;
  native let customMorph: Bool;
}

public native class meshMeshParamGpuBuffer extends meshMeshParameter {
  native let stride: Uint32;
}

public native class meshMeshParamImportedSnapPoint extends meshMeshParameter {
  native let snapFeatureData: array<ref<meshMeshImportedSnapPoint>>;
}

public native class meshMeshParamOccluderData extends meshMeshParameter {
  native let occluderResource: ref<visIOccluderResource>;
  native let defaultOccluderType: visWorldOccluderType;
  native let autoHideDistanceScale: Uint8;
}

public native class meshMeshParamPhysics extends meshMeshParameter {
  native let physicsData: ref<physicsSystemResource>;
}

public native class meshMeshParamShadowMeshCreationData extends meshMeshParameter {
  native let geometries: array<ref<physicsICollider>>;
  native let bonesPerGeometry: array<Int32>;
}

public native class meshMeshParamSpeedTreeWind extends meshMeshParameter {}

public native class meshMeshParamTerrain extends meshMeshParameter {
  native let chunkBoundingBoxes: array<Box>;
}

public native class meshMeshParamTopologyData extends meshMeshParameter {
  native let offsets: array<Uint32>;
  native let sizes: array<Uint32>;
}

public native class meshMeshParamTopologyMetadata extends meshMeshParameter {
  native let offsets: array<Uint32>;
  native let sizes: array<Uint32>;
}

public native class meshMeshParamUICollisionData extends meshMeshParameter {
  native let uvs: array<Vector2>;
  native let trianglesIndices: array<Uint16>;
  native let vertices: array<Vector3>;
}

public native class meshMeshParamWaterPatchData extends meshMeshParameter {
  native let animLoop: Bool;
  native let animLength: Float;
}

public native class meshMeshParamWorkspotOffsets extends meshMeshParameter {
  native let names: array<CName>;
  native let offsets: array<Matrix>;
}

public native struct meshPhxClothChunkData {}

public native struct meshRawClothData {
  native let state: physicsclothState;
}

public native struct meshRegionData {
  native let chunkDataIntact: array<meshChunkOffset>;
  native let chunkDataFractured: array<meshChunkOffset>;
  native let chunkMaskIntact: Uint64;
  native let chunkMaskFractured: Uint64;
  native let isStaticRemains: Bool;
}

public native struct MicroblendDef {
  native let name: CName;
  native let texture: ResourceRef; // rRef<CBitmapTexture>
}

public native class MinigameCollisionLogicAdvanced extends inkLogicController {
  public final native func GetDynObject()
}

public native class MinigameDynObjectAdvanced extends inkLogicController {
  public final native func GetGameState()
}

public abstract native class MinigameLogicControllerAdvanced extends inkLogicController {
  native let playerLibraryName: CName;
  native let playerColliderPositionOffset: Vector2;
  native let playerColliderSizeOffset: Vector2;
  native let gameplayRoot: inkCompoundRef;
  native let baseSpeed: Float;
  native let layers: array<inkWidgetRef>;
  native let cheatCodes: array<SideScrollerCheatCodeAdvanced>;
  native let acceptableCheatKeys: array<CName>;
  public final native func FinishGame()
}

public native class MinigamePlayerControllerAdvanced extends inkLogicController {
  public final native func GetGameState()
}

public native class MinimapDataNode extends worldNode {
  native let encodedShapesRef: ResourceAsyncRef; // raRef<minimapEncodedShapes>
  native let streamingDistance: Float;
  native let localBounds: Box;
  native let allInteriorShapes: Bool;
}

public native class MinimapDataNodeInstance extends worldINodeInstance {}

public native class minimapEncodedShapes extends CResource {
  native let QuantizationScale: Vector2;
  native let QuantizationBias: Vector2;
  native let BoxQuantizationScale: Vector3;
  native let BoxQuantizationBias: Vector3;
  native let NumPoints: Uint32;
  native let NumBorderPoints: Uint32;
  native let NumFillPoints: Uint32;
  native let NumShapes: Uint32;
  native let NumSpatialBuckets: Uint32;
  native let NumUniqueGeometry: Uint32;
  native let NumOwners: Uint32;
  native let Version: Uint32;
}

public native class MinimapHazardWarningMappinController extends BaseMinimapMappinController {}

enum minimapuiELayerType {
  Floor = 0,
  Cover = 1,
  WallInterior = 2,
  WallExterior = 3,
  Door = 4,
  Stairs = 5,
  Road = 6,
  Count = 7,
}

public native class minimapuiGeometryWidget extends inkCanvas {
  native let widgetTemplates: array<inkWidgetRef>;
  native let settings: minimapuiSettings;
}

public native struct minimapuiSettings {
  native let showTime: Float;
  native let hideTime: Float;
}

public native struct MipMapGenParams {
  native let applyToksvig_ShouldInvChannel: Bool;
  native let applyToksvig_Channel: Uint8;
  native let applyToksvig_sourceNormalMap: ResourceAsyncRef; // raRef<CBitmapTexture>
}

public native class ModdingSystem extends IGameSystem {}

public native class MorphTargetMesh extends resStreamedResource {
  native let baseMesh: ResourceRef; // rRef<CMesh>
  native let targets: array<MorphTargetMeshEntry>;
  native let boundingBox: Box;
  native let baseTextureParamName: CName;
  native let blob: ref<IRenderResourceBlob>;
  native let baseMeshAppearance: CName;
  native let baseTexture: ResourceRef; // rRef<ITexture>
}

public native struct MorphTargetMeshEntry {
  native let name: CName;
  native let regionName: CName;
  native let faceRegion: MorphTargetsFaceRegion;
  native let boneNames: array<CName>;
  native let boneRigMatrices: array<Matrix>;
}

enum MorphTargetsDiffTextureSize {
  TEXTURE_SIZE_1024x1024 = 0,
  TEXTURE_SIZE_512x512 = 1,
  TEXTURE_SIZE_256x256 = 2,
}

enum MorphTargetsFaceRegion {
  FACE_REGION_EYES = 0,
  FACE_REGION_NOSE = 1,
  FACE_REGION_MOUTH = 2,
  FACE_REGION_JAW = 3,
  FACE_REGION_EARS = 4,
  FACE_REGION_NONE = 255,
}

public native struct MorphTargetsTextureBlendInfo {
  native let blend: Bool;
  native let diffSize: MorphTargetsDiffTextureSize;
  native let name: CName;
}

public native class MotionBlurAreaSettings extends IAreaSettings {
  native let strength: Float;
}

enum MountDescriptor_MountingType {
  Unmounted = 0,
  KeepState = 1,
  Vehicle = 3,
  MovingPlatform = 4,
}

public native class moveComponent extends entIMoverComponent {}

public native class moveDroneMotionPlannerComponent extends moveMotionPlannerComponent {}

public importonly native class MoveEquip extends AttachmentSlotEvent {}

public abstract native class moveIMotionPlannerComponent extends IComponent {}

public native class moveMotionPlannerComponent extends moveIMotionPlannerComponent {
  native let snapToGround: Bool;
}

enum moveMovementOrientationType {
  NotSet = 0,
  Forward = 1,
  Backward = 2,
  Left = 3,
  Right = 4,
}

public abstract native class movePoliciesContract extends ISerializable {}

public native class movePoliciesContractMoveToSmartObject extends movePoliciesContract {}

public native class movePoliciesContractMoveToWorkspot extends movePoliciesContract {}

public native class MovePoliciesSystem extends IMovePoliciesSystem {}

public native struct moveReplicatedMovePoliciesState {
  native let items: array<moveReplicatedMovePolicies>;
  native let lastAppliedActionsTime: netTime;
}

public native class MoveSystem extends IMoveSystem {}

public native class MoveSystemStopEvent extends ActionEvent {}

public native class MovingPlatformSystem extends IMovingPlatformSystem {}

public native struct mpCMultiplayerDebugFunctions {
  public final static native func MPDebugPlaySound(sound: CName, position: Vector4)
  public final static native func MPDebugRemoteClientShutdown(hardExit: Bool)
}

public native class mpInteractionActivatorComponent extends IPlacedComponent {}

public native class mpPersistentTestBox extends GameObject {}

public native class MultiEcsManagerComponent extends IComponent {}

public native struct Multilayer_Layer {
  native let matTile: Float;
  native let mbTile: Float;
  native let microblend: ResourceRef; // rRef<CBitmapTexture>
  native let microblendContrast: Float;
  native let microblendNormalStrength: Float;
  native let microblendOffsetU: Float;
  native let microblendOffsetV: Float;
  native let opacity: Float;
  native let offsetU: Float;
  native let offsetV: Float;
  native let material: ResourceRef; // rRef<Multilayer_LayerTemplate>
  native let colorScale: CName;
  native let normalStrength: CName;
  native let roughLevelsIn: CName;
  native let roughLevelsOut: CName;
  native let metalLevelsIn: CName;
  native let metalLevelsOut: CName;
  native let overrides: CName;
}

public native struct Multilayer_LayerOverrideSelection {
  native let colorScale: CName;
  native let normalStrength: CName;
  native let roughLevelsIn: CName;
  native let roughLevelsOut: CName;
  native let metalLevelsIn: CName;
  native let metalLevelsOut: CName;
}

public native class Multilayer_LayerTemplate extends CResource {
  native let overrides: Multilayer_LayerTemplateOverrides;
  native let defaultOverrides: Multilayer_LayerOverrideSelection;
  native let colorTexture: ResourceRef; // rRef<CBitmapTexture>
  native let normalTexture: ResourceRef; // rRef<CBitmapTexture>
  native let roughnessTexture: ResourceRef; // rRef<CBitmapTexture>
  native let metalnessTexture: ResourceRef; // rRef<CBitmapTexture>
  native let tilingMultiplier: Float;
  native let colorMaskLevelsIn: [Float; 2];
  native let colorMaskLevelsOut: [Float; 2];
}

public native struct Multilayer_LayerTemplateOverrides {
  native let colorScale: array<Multilayer_LayerTemplateOverridesColor>;
  native let roughLevelsIn: array<Multilayer_LayerTemplateOverridesLevels>;
  native let roughLevelsOut: array<Multilayer_LayerTemplateOverridesLevels>;
  native let metalLevelsIn: array<Multilayer_LayerTemplateOverridesLevels>;
  native let metalLevelsOut: array<Multilayer_LayerTemplateOverridesLevels>;
  native let normalStrength: array<Multilayer_LayerTemplateOverridesNormalStrength>;
}

public native struct Multilayer_LayerTemplateOverridesColor {
  native let n: CName;
  native let v: [Float; 3];
}

public native struct Multilayer_LayerTemplateOverridesLevels {
  native let n: CName;
  native let v: [Float; 2];
}

public native struct Multilayer_LayerTemplateOverridesNormalStrength {
  native let n: CName;
  native let v: Float;
}

public native class Multilayer_Mask extends CResource {
  native let renderResourceBlob: rendRenderMultilayerMaskResource;
}

public native class Multilayer_Setup extends CResource {
  native let layers: array<Multilayer_Layer>;
  native let ratio: Float;
  native let useNormal: Bool;
}

public importonly native class MultiPrereq extends IPrereq {
  native let aggregationType: gameAggregationType;
  native let nestedPrereqs: array<ref<IPrereq>>;
}

public native class MuppetBlackboardsComponent extends MuppetComponent {}

public abstract native class MuppetComponent extends IComponent {}

public native class MuppetInputHandlerComponent extends IComponent {}

public native class MuppetInputStates extends MuppetComponent {
  native let replicationTime: netTime;
}

public native class MuppetInventory extends MuppetComponent {}

public native class MuppetLocomotionComponent extends MuppetComponent {}

public native class MuppetPhysicsComponent extends MuppetComponent {}

public native class MuppetRawInput extends MuppetComponent {}

public native class MuppetStats extends MuppetComponent {}

public native class MuppetUpperBodyRequestsComponent extends MuppetComponent {}

public native class MusicEvent extends Event {
  native let eventName: CName;
}

public native class MusicSync extends Event {
  native let syncType: audioMusicSyncType;
  native let syncParameter: Float;
}

public importonly native class NarrationPlateComponent extends IComponent {
  native let narrationCaption: CName;
  native let narrationText: CName;
  native let isEnabled: Bool;
}

public native struct navgendebugCompactCell {
  native let cellData: Uint64;
}

public native struct navgendebugCompactContour {
  native let rawVertices: array<Int32>;
  native let simplifiedVertices: array<Int32>;
  native let innerPoints: array<Int32>;
  native let region: Uint16;
  native let area: Uint8;
  native let box: Box;
}

public native class navgendebugCompactPolygon extends ISerializable {
  native let index: Uint16;
  native let indices: array<Uint16>;
  native let neighbors: array<Uint16>;
  native let area: Uint8;
  native let region: Uint16;
  native let flags: Uint16;
}

public native struct navgendebugCompactSpan {
  native let spanData: Uint32;
}

public native struct navgendebugContourSet {
  native let contours: array<navgendebugCompactContour>;
  native let boundingBox: Box;
  native let cellSize: Float;
  native let cellHeight: Float;
  native let width: Int32;
  native let height: Int32;
  native let borderSize: Int32;
  native let maxError: Float;
}

public native class navgendebugHeightfield extends ISerializable {
  native let bounds: Box;
  native let cellSize: Float;
  native let cellHeight: Float;
  native let width: Uint16;
  native let height: Uint16;
  native let rawSpans: navgendebugSpansData;
  native let compactSpans: navgendebugSpansData;
  native let cells: array<navgendebugCompactCell>;
  native let regions: array<Uint16>;
  native let distancefield: array<Uint16>;
  native let maxDistancefieldValue: Uint16;
}

public native struct navgendebugInputGeometry {
  native let triangles: array<navgendebugInputGeometryTriangle>;
  native let tileBoundingBox: Box;
  native let extrudedBoundingBox: Box;
}

public native struct navgendebugInputGeometryTriangle {
  native let vertices: [Vector3; 3];
  native let area: Uint8;
}

public native class navgendebugPolyMesh extends ISerializable {
  native let vertices: array<Vector3>;
  native let polygons: array<navgendebugCompactPolygon>;
  native let bounds: Box;
  native let cellSize: Float;
  native let cellHeight: Float;
  native let borderSize: Int32;
  native let maxEdgeError: Float;
  native let maxVerticesPerPolygon: Int32;
}

public native struct navgendebugSpansData {
  native let spans: array<navgendebugCompactSpan>;
  native let areas: array<Uint8>;
  native let filteredAreas: array<Uint8>;
}

public native class navgendebugTileGenerationDebugData extends ISerializable {
  native let tileIndex: Uint32;
  native let contours: navgendebugContourSet;
}

public native struct NavGenNavigationSetting {
  native let navmeshImpact: NavGenNavmeshImpact;
}

enum NavGenNavmeshImpact {
  Ignored = 1,
  Walkable = 0,
  Blocking = 2,
  Road = 3,
  Stairs = 4,
  Drones = 5,
  Terrain = 6,
  CrowdWalkable = 0,
}

enum NavGenSamplingDensity {
  None = 0,
  Sparse = 1,
  Dense = 2,
  Very_dense = 3,
}

public native class NavigationFunctionalTests extends IScriptable {
  public final native func GetPathOnNavmesh()
  public final native func RunGPSQuery()
  public final native func UpdateGPSQuery()
}

public native class navLocomotionPath extends ISerializable {
  native let splineNodeRef: NodeRef;
  native let segments: array<navLocomotionPathSegmentInfo>;
  native let backwardSegments: array<navLocomotionPathSegmentInfo>;
  native let points: array<navLocomotionPathPointInfo>;
  native let userData: array<navLocomotionPathPointUserDataEntry>;
}

public native struct navLocomotionPathPointInfo {
  native let point: navSerializableSplineProgression;
  native let userDataIndex: Uint32;
}

public native class navLocomotionPathPointUserData extends ISerializable {}

public native struct navLocomotionPathPointUserDataEntry {
  native let userData: ref<navLocomotionPathPointUserData>;
  native let nextUserData: Uint32;
}

public native class navLocomotionPathResource extends CResource {
  native let paths: array<ref<navLocomotionPath>>;
}

public native struct navLocomotionPathSegmentInfo {
  native let type: navLocomotionPathSegmentTypes;
  native let segmentEnd: navSerializableSplineProgression;
  native let offMeshLink: Uint64;
}

enum navLocomotionPathSegmentTypes {
  Invalid = 0,
  Spline = 1,
  OffMeshLink = 2,
}

enum navNavAreaID {
  Unwalkable = 0,
  Terrain = 1,
  Crouchable = 2,
  Regular = 3,
  Road = 4,
  Pavement = 5,
  Door = 10,
  Ladder = 11,
  Jump = 12,
  Elevator = 14,
  Stairs = 15,
  Drones = 16,
  Exploration = 17,
  CrowdWalkable = 5,
}

enum navPathQueryDebugStatus {
  InvalidQuery = 0,
  Active = 1,
  WaitingForStreaming = 2,
  Completed = 3,
  NoPathPossible = 4,
}

public native class navRuntimeSystemPathfinding extends worldIRuntimeSystem {}

public native struct navSerializableSplineProgression {
  native let sectionIdx: Uint32;
  native let alpha: Float;
}

public native struct netEntityAttachmentInterface {
  native let time: netTime;
}

public native class netEntitySystem extends worldIRuntimeSystem {}

public abstract native struct netIComponentState {
  native let componentName: CName;
  native let enabled: Bool;
}

public abstract native struct netIEntityState {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
}

public abstract native class netIIngameProfilerSystem extends IGameSystem {}

public native struct netPeerID {
  native let value: Uint8;
}

public importonly native class NetrunnerPrototypeComponent extends IComponent {
  native let structs: array<gameNetrunnerPrototypeStruct>;
}

public importonly native class NetrunnerPrototypeNodeSetupEvent extends Event {
  native let scale: Vector3;
}

public native struct netTime {
  native let milliSecs: Uint64;
}

public native class NotifyFootstepMaterialContextChangedEvent extends Event {
  native let footwareType: CName;
  native let surfaceFlavourName: CName;
}

public native class NotImplementedAICommandParams extends AICommandParams {}

public native class NotPrereq extends IPrereq {
  native let negatedPrereq: ref<IPrereq>;
}

public native class NotPrereqState extends PrereqState {}

public native struct oauthAuthenticationToken {
  native let token: String;
  native let secret: String;
  native let sessionHandle: String;
  native let tokenExpiresIn: Uint64;
  native let authorizationExpiresIn: Uint64;
}

public native class ObjectCarrierComponent extends IComponent {
  native let objectToSpawn: TweakDBID;
}

public native class ObjectCarrierComponentAttached extends Event {}

public abstract native class ObjectCarrierComponentDetached extends Event {}

public native class ObjectCarrySystem extends IObjectCarrySystem {}

public importonly native class ObjectSelectionManager extends AIObjectSelectionManagerInterface {}

public native class OnAxis extends inkPointerEvent {}

public native class OnDoubleClick extends inkPointerEvent {}

public native class OnEnter extends inkPointerEvent {}

public native class OnFocusLost extends inkFocusEvent {}

public native class OnFocusReceived extends inkFocusEvent {}

public native class OnHold extends inkPointerEvent {}

public native class OnHoverOut extends inkPointerEvent {}

public native class OnHoverOver extends inkPointerEvent {}

public native class OnLeave extends inkPointerEvent {}

public native class OnPress extends inkPointerEvent {}

public native class OnRelative extends inkPointerEvent {}

public native class OnRelease extends inkPointerEvent {}

public native class OnRepeat extends inkPointerEvent {}

public native class OnVisibilityBlockerAffectedTBHEvent extends Event {
  native let newTBHModifier: Float;
}

public native struct OrientedBox {
  native let position: Vector4;
}

public native class OutlineArea extends IArea {}

public native class PalladiaAdvertisementWidgetComponent extends AdvertisementWidgetComponent {}

public abstract native class PanzerBonus extends MinigameDynObjectAdvanced {
  native let fallingSpeed: Float;
}

public native class PanzerBullet extends MinigameDynObjectAdvanced {}

public native class PanzerCloud extends MinigameDynObjectAdvanced {}

public native class PanzerEnemy extends MinigameDynObjectAdvanced {
  native let noBonusChanceCoeff: Uint32;
  native let health: Int32;
  native let score: Uint32;
  native let shootPoint: Vector2;
  native let bulletSpeed: Float;
  native let gameLayerName: CName;
  native let explosionLibraryName: CName;
  native let bulletLibraryName: CName;
  native let lifeBonusLibraryName: CName;
  native let lifeBonusChanceCoeff: Uint32;
  native let scoreBonusLibraryName: CName;
  native let scoreBonusChanceCoeff: Uint32;
  native let score50ChanceCoeff: Uint32;
  native let score100ChanceCoeff: Uint32;
  native let score200ChanceCoeff: Uint32;
}

public native class PanzerEnemyAV extends PanzerEnemy {
  native let speed: Float;
  native let shotsAmount: Uint32;
  native let longShotInterval: Float;
  native let shortShotInterval: Float;
}

public native class PanzerEnemyBullet extends PanzerBullet {}

public native class PanzerEnemyDrone extends PanzerEnemy {
  native let speed: Float;
  native let shootIntervalMinimum: Float;
  native let shootIntervalMaximum: Float;
}

public native class PanzerExplosion extends MinigameDynObjectAdvanced {
  native let animationName: CName;
}

public native class PanzerFriendlyBullet extends PanzerBullet {}

public native class PanzerGameLogicController extends MinigameLogicControllerAdvanced {
  native let gameOverDelay: Float;
  native let mainMenuLibraryName: CName;
  native let scoreboardLibraryName: CName;
  native let panelsLayer: CName;
  native let gameLayer: CName;
  native let cloudsLayer: CName;
  native let backgroundLibraryName: CName;
  native let cloudsLibraryNames: array<CName>;
  native let minCloudSpawnInterval: Float;
  native let maxCloudSpawnInterval: Float;
  native let minCloudSpeed: Float;
  native let maxCloudSpeed: Float;
  native let scoreCounter: inkTextRef;
  native let livesCounter: inkTextRef;
  native let moveUpKey: CName;
  native let moveDownKey: CName;
  native let moveLeftKey: CName;
  native let moveRightKey: CName;
  native let shootKey: CName;
  native let backKey: CName;
  native let submitKey: CName;
  native let axisDeadZone: Float;
  native let moveXAxis: CName;
  native let moveYAxis: CName;
  native let shootAxis: CName;
  native let droneLibraryName: CName;
  native let minDroneSpawnInterval: Float;
  native let maxDroneSpawnInterval: Float;
  native let avLibraryName: CName;
  native let minAvSpawnInterval: Float;
  native let maxAvSpawnInterval: Float;
}

public native class PanzerGameState extends MinigameStateAdvanced {}

public native class PanzerLifeBonus extends PanzerBonus {}

public native class PanzerPlayerController extends MinigameDynObjectAdvanced {
  native let bulletSpeed: Float;
  native let bulletSpawnOffset: Vector2;
  native let bulletLibraryname: CName;
  native let shootInterval: Float;
  native let gameLayerName: CName;
  native let invulnerableAnimationName: CName;
  native let explosionLibraryName: CName;
}

public native class PanzerScoreBoard extends MinigameDynObjectAdvanced {
  native let scoreboardList: inkVerticalPanelRef;
  native let champions: array<PanzerScoreRecordData>;
  native let recordWidgetLibraryName: CName;
}

public native class PanzerScoreBonus extends PanzerBonus {}

public native class PanzerScoreRecord extends inkLogicController {
  native let nameWidget: inkTextRef;
  native let scoreWidget: inkTextRef;
}

public native struct PanzerScoreRecordData {
  native let name: String;
  native let score: Uint32;
}

public native struct ParamData {
  native let name: String;
  native let type: String;
  native let defaultValue: Variant;
}

public native struct ParticleBurst {
  native let burstTime: Float;
  native let spawnCount: Uint32;
  native let spawnTimeRange: Float;
  native let repeatTime: Float;
}

public native class ParticleDamage extends ISerializable {
  native let boundingBoxes: array<Box>;
}

public native class PathTracingSettings extends IAreaSettings {
  native let albedoModulation: Float;
  native let diffuseGlobalScale: Float;
  native let diffuseSunScale: Float;
  native let diffuseSkyScale: Float;
  native let diffuseLocalLightsScale: Float;
  native let diffuseEmissiveScale: Float;
  native let specularGlobalScale: Float;
  native let specularSunScale: Float;
  native let specularSkyScale: Float;
  native let specularLocalLightsScale: Float;
  native let specularEmissiveScale: Float;
  native let maxIntensity: Float;
  native let GIOnlyLightScale: Float;
  native let rayNumber: Uint32;
  native let bounceNumber: Uint32;
  native let rayNumberScreenshot: Uint32;
  native let bounceNumberScreenshot: Uint32;
}

public native class PhotoModeBackgroundViewComponent extends IComponent {
  native let backgroundPrefabRef: NodeRef;
  native let targetPointRef: NodeRef;
}

public native class PhotoModeCursorStateChangedEvent extends Event {
  native let cursorEnabled: Bool;
  native let keepCursorPosition: Bool;
}

public native class PhotoModeFailedToOpenEvent extends Event {}

public native class PhotoModeLastInputDeviceEvent extends Event {}

public native class PhotoModeQuestPrefabStateListener extends worldIQuestPrefabStateListener {}

public native class PhotoModeRegisaterCallbacksEvent extends Event {}

public native class PhotoModeUIHideForScreenshotEvent extends Event {
  native let hide: Bool;
}

public native class PhotoModeUIInteractiveEvent extends Event {
  native let interactive: Bool;
}

public native class PhotoModeUIVisibilityEvent extends Event {
  native let visible: Bool;
}

public native class PhysicalDeformShapesEvent extends Event {
  native let shapes: array<Int32>;
  native let value: Float;
}

public native class PhysicalDestructionNode extends worldNode {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let meshAppearance: CName;
  native let forceLODLevel: Int32;
  native let forceAutoHideDistance: Float;
  native let destructionParams: physicsDestructionParams;
  native let destructionLevelData: array<physicsDestructionLevelData>;
  native let audioMetadata: CName;
  native let navigationSetting: NavGenNavigationSetting;
  native let useMeshNavmeshSettings: Bool;
  native let systemsToNotifyFlags: Uint16;
}

public native class PhysicalFractureFieldNode extends worldNode {
  native let shape: physicsTriggerShape;
  native let fractureFieldParams: physicsFractureFieldParams;
}

public importonly native class PhysicalSkinnedMeshComponent extends entSkinnedMeshComponent {
  native let simulationType: physicsSimulationType;
  native let useResourceSimulationType: Bool;
  native let startInactive: Bool;
  native let filterDataSource: physicsFilterDataSource;
  native let filterData: ref<physicsFilterData>;
  public final native func CreatePhysicalBodyInterface()
}

public abstract importonly native class PhysicalTriggerComponent extends IPlacedComponent {
  native let simulationType: physicsSimulationType;
  native let shape: physicsTriggerShape;
  native let filterData: ref<physicsFilterData>;
  native let isEnabled: Bool;
}

public native struct physicsApperanceMaterial {
  native let apperanceName: CName;
  native let materialFrom: CName;
  native let material: CName;
}

public native struct physicsCacheEntry {
  native let entryOffset: Uint32;
  native let entrySize: Uint32;
}

public native struct physicsCacheKey {
  native let key: physicsGeometryKey;
  native let entryIndex: Uint32;
}

public native class physicsclothClothCapsuleExportData extends ISerializable {
  native let capsules: array<physicsclothExportedCapsule>;
}

public native struct physicsclothExportedCapsule {
  native let p0: Vector3;
  native let p1: Vector3;
  native let r0: Float;
  native let r1: Float;
  native let boneName: CName;
}

public native struct physicsclothPhaseConfig {
  native let stiffness: Float;
  native let stiffnessMultiplier: Float;
  native let compressionLimit: Float;
  native let stretchLimit: Float;
}

public native struct physicsclothRuntimeInfo {
  native let translation: Vector3;
  native let rotation: Quaternion;
  native let gravity: Vector3;
  native let damping: Float;
  native let drag: Float;
  native let inertia: Float;
  native let numSolverIterations: Uint32;
  native let stiffnessFrequency: Float;
  native let friction: Float;
  native let tetherStiffness: Float;
  native let tetherScale: Float;
  native let selfCollisionDistance: Float;
  native let selfCollisionStiffness: Float;
  native let liftCoefficient: Float;
  native let dragCoefficient: Float;
  native let gravityScale: Float;
  native let motionConstraintStiffness: Float;
  native let enableSelfCollision: Bool;
}

public native struct physicsclothState {
  native let verticalPhaseData: physicsclothPhaseConfig;
  native let horizontalPhaseData: physicsclothPhaseConfig;
  native let bendPhaseData: physicsclothPhaseConfig;
  native let shearPhaseData: physicsclothPhaseConfig;
  native let runtimeInfo: physicsclothRuntimeInfo;
}

public native class physicsColliderBox extends physicsICollider {
  native let halfExtents: Vector3;
  native let isObstacle: Bool;
}

public native class physicsColliderCapsule extends physicsICollider {
  native let radius: Float;
  native let height: Float;
}

public native class physicsColliderConvex extends physicsICollider {
  native let vertices: array<Vector3>;
  native let indexBuffer: array<Uint8>;
  native let polygonVertices: array<Uint16>;
}

public native class physicsColliderMesh extends physicsICollider {
  native let faceMaterials: array<CName>;
}

public native class physicsColliderSphere extends physicsICollider {
  native let radius: Float;
}

public native class physicsCollisionFilterResource extends ISerializable {
  native let collisionPresetJson: ResourceRef; // rRef<JsonResource>
  native let overridesJson: ResourceRef; // rRef<JsonResource>
  native let queryPresetJson: ResourceRef; // rRef<JsonResource>
}

public native class physicsCollisionPresetDefinition extends ISerializable {
  native let Name: CName;
  native let Description: String;
  native let ForceEnableCollisionCallbacks: Bool;
  native let CollisionType: array<CName>;
  native let CollisionMask: array<CName>;
  native let QueryDetect: array<CName>;
}

public native struct physicsCollisionPresetOverride {
  native let from: CName;
  native let to: CName;
}

public native class physicsCollisionPresetsOverridesResource extends ISerializable {
  native let overrides: array<physicsCollisionPresetOverride>;
}

public native class physicsCollisionPresetsResource extends ISerializable {
  native let presets: array<physicsCollisionPresetDefinition>;
}

public native class physicsCustomFilterData extends ISerializable {
  native let collisionType: array<CName>;
  native let collideWith: array<CName>;
  native let queryDetect: array<CName>;
}

public native class physicsDeferredCollection extends ISerializable {}

public native struct physicsDestructionHierarchyOffset {
  native let combined: Uint32;
}

public native struct physicsDestructionLevelData {
  native let filterData: ref<physicsFilterData>;
  native let fracturingEffect: ResourceAsyncRef; // raRef<worldEffect>
}

public native struct physicsDestructionParams {
  native let startInactive: Bool;
  native let simulationType: physicsSimulationType;
  native let markEdgeChunks: Bool;
  native let useAggregatesForClusters: Bool;
  native let turnDynamicOnImpulse: Bool;
  native let buildConvexForClusters: Bool;
  native let damageThreshold: Float;
  native let damageEndurance: Float;
  native let bondEndurance: Float;
  native let accumulateDamage: Bool;
  native let enableImpulseDamage: Bool;
  native let impulseToDamage: Float;
  native let contactToDamage: Float;
  native let maxContactImpulseRatio: Float;
  native let impulseChildPropagationFactor: Float;
  native let impulsePropagationFactor: Float;
  native let impulseDiminishingFactor: Float;
  native let breakBonds: Bool;
  native let debrisInstantRemovalThreshold: Float;
  native let debrisTimeoutThreshold: Float;
  native let debrisTimeout: Bool;
  native let debrisTimeoutMin: Float;
  native let debrisTimeoutMax: Float;
  native let fadeOutTime: Float;
  native let debrisMaxSeparation: Float;
  native let visualsRemain: Bool;
  native let debrisDestructible: Bool;
  native let supportDamage: Bool;
  native let maxAngularVelocity: Float;
}

public native class physicsFilterData extends ISerializable {
  native let simulationFilter: SimulationFilter;
  native let queryFilter: QueryFilter;
  native let preset: CName;
  native let customFilterData: ref<physicsCustomFilterData>;
}

enum physicsFilterDataSource {
  Parent = 0,
  Collider = 1,
  Component = 0,
  Body = 1,
}

enum physicsFractureFieldEffect {
  FE_Fracture = 0,
  FE_Erase = 1,
}

public native struct physicsFractureFieldParams {
  native let origin: Vector3;
  native let fractureFieldValue: Float;
  native let fractureFieldEffect: physicsFractureFieldEffect;
  native let fractureFieldValueType: physicsFractureFieldValueType;
}

enum physicsFractureFieldValueType {
  FFVT_Impulse = 0,
  FFVT_Velocity = 1,
}

public native class PhysicsFunctionalTests extends IScriptable {
  public final native func CreateTrigger()
  public final native func QueryOverlapBox()
}

public native class physicsGeometryCache extends CResource {
  native let sectorEntries: array<physicsSectorEntry>;
  native let sectorGeometries: array<physicsGeometryKey>;
  native let sectorCacheEntries: array<physicsSectorCacheEntry>;
  native let alwaysLoadedSector: physicsSectorEntry;
}

public native class physicsGeometryCacheArtifact extends CResource {
  native let entryKeys: array<physicsCacheKey>;
  native let entryTable: array<physicsCacheEntry>;
}

public native struct physicsGeometryKey {
  native let pe: Uint8;
  native let ta: [Uint8; 12];
}

public abstract native class physicsICollider extends ISerializable {
  native let localToBody: Transform;
  native let material: CName;
  native let materialApperanceOverrides: array<physicsApperanceMaterial>;
  native let tag: CName;
  native let isImported: Bool;
  native let isQueryShapeOnly: Bool;
  native let volumeModifier: Float;
  native let filterData: ref<physicsFilterData>;
}

public abstract native class physicsISystemObject extends ISerializable {
  native let name: CName;
}

enum physicsMaterialFriction {
  Enabled = 0,
  DisabledStrong = 1,
  Disabled = 2,
}

public native class physicsMaterialLibraryResource extends CResource {
  native let defaultMaterial: ref<physicsMaterialResource>;
}

public native struct physicsMaterialReference {
  native let name: CName;
}

public native class physicsMaterialResource extends CResource {
  native let staticFriction: Float;
  native let dynamicFriction: Float;
  native let restitution: Float;
  native let frictionMode: physicsMaterialFriction;
  native let density: Float;
  native let tags: physicsMaterialTags;
  native let color: Color;
  native let id: Uint64;
}

enum physicsMaterialTagAIVisibility {
  None = 0,
  SemiTransparent = 1,
  Transparent = 2,
}

enum physicsMaterialTagProjectilePenetration {
  TechOnly = 0,
  Any = 1,
  Medium = 2,
  Heavy = 3,
  Never = 4,
}

enum physicsMaterialTagProjectileRicochet {
  Default = 0,
  Always = 1,
}

public native struct physicsMaterialTags {
  native let aiVisibility: physicsMaterialTagVisibility;
  native let playerVisibility: physicsMaterialTagVisibility;
  native let projectilePenetration: physicsMaterialTagProjectilePenetration;
  native let projectileRicochet: physicsMaterialTagProjectileRicochet;
  native let vehicleTraction: physicsMaterialTagVehicleTraction;
}

enum physicsMaterialTagType {
  AIVisibility = 0,
  PlayerVisibility = 1,
  ProjectilePenetration = 2,
  ProjectileRicochet = 3,
  VehicleTraction = 4,
}

enum physicsMaterialTagVehicleTraction {
  Default = 0,
  Gravel = 1,
}

enum physicsMaterialTagVisibility {
  None = 0,
  SemiTransparent = 1,
  Transparent = 2,
  Ignore = 3,
}

public abstract native class PhysicsParticleInitializer extends ISerializable {}

public native class physicsPhysicalJointPin extends ISerializable {
  native let object: ref<physicsISystemObject>;
  native let featureIndex: Int32;
  native let localPosition: Vector3;
  native let localRotation: Quaternion;
}

enum physicsPhysicalSystemOwner {
  Unknown = 0,
  BakedDestructionNode = 1,
  ClothMeshNode = 2,
  CollisionAreaNode = 3,
  DecorationMeshNode = 4,
  DynamicMeshNode = 5,
  InstancedDestructibleNode = 6,
  PhysicalDestructionNode = 7,
  PhysicalTriggerNode = 8,
  StaticMeshNode = 9,
  TerrainCollisionNode = 10,
  WaterPatchNode = 11,
  WorldCollisionNode = 12,
  BakedDestructionComponent = 13,
  ClothComponent = 14,
  ColliderComponent = 15,
  PhysicalDestructionComponent = 16,
  PhysicalMeshComponent = 17,
  PhysicalSkinnedMeshComponent = 18,
  PhysicalTriggerComponent = 19,
  SimpleColliderComponent = 20,
  SkinnedClothComponent = 21,
  StateMachineComponent = 22,
  VehicleChassisComponent = 23,
  PhysicalParticleSystem = 24,
  PhotoModeSystem = 25,
  RagdollBinder = 26,
  FoliageDestruction = 27,
  EntityProxy = 28,
}

enum physicsPhysicsJointAxis {
  AxisX = 0,
  AxisY = 1,
  AxisZ = 2,
  Twist = 3,
  Swing1 = 4,
  Swing2 = 5,
}

public native struct physicsPhysicsJointDrive {
  native let forceLimit: Float;
  native let isAcceleration: Bool;
  native let stiffness: Float;
  native let damping: Float;
}

enum physicsPhysicsJointDriveType {
  AxisX = 0,
  AxisY = 1,
  AxisZ = 2,
  Swing = 3,
  Twist = 4,
  SLERP = 5,
}

public native struct physicsPhysicsJointDriveVelocity {
  native let linearVelocity: Vector4;
  native let angularVelocity: Vector4;
}

public native struct physicsPhysicsJointLimitBase {
  native let restitution: Float;
  native let bounceThreshold: Float;
  native let stiffness: Float;
  native let damping: Float;
  native let contactDistance: Float;
}

enum physicsPhysicsJointMotion {
  Locked = 0,
  Limited = 1,
  Free = 2,
}

enum physicsProxyType {
  Invalid = 0,
  PhysicalSystem = 1,
  CharacterController = 2,
  Destruction = 3,
  ParticleSystem = 4,
  Trigger = 5,
  Cloth = 6,
  WorldCollision = 7,
  Terrain = 8,
  SimpleCollider = 9,
  AggregateSystem = 10,
  CharacterObstacle = 11,
  Ragdoll = 12,
  FoliageDestruction = 13,
}

public native class physicsQueryPresetDefinition extends ISerializable {
  native let name: CName;
  native let queryGroups: array<CName>;
}

public native class physicsQueryPresetResource extends ISerializable {
  native let presets: array<physicsQueryPresetDefinition>;
}

enum physicsQueryUseCase {
  Default = 0,
  ActionAnimation = 1,
  AI = 2,
  AnimationComponent = 3,
  Audio = 4,
  AudioHedgehog = 5,
  Components = 6,
  Debug = 7,
  Gameplay = 8,
  GeomDescription = 9,
  LineOfSightTests = 10,
  MoveZAlignment = 11,
  Navigation = 12,
  Nodes = 13,
  PuppetBlackboardUpdater = 14,
  Ragdoll = 15,
  Scripts = 16,
  TargetingSystem = 17,
  VehicleAI = 18,
  VehicleAIColliders = 19,
  Vehicles = 20,
  VehicleChassis = 21,
  VehiclesCrowd = 22,
  VehicleWheel = 23,
  VehicleStreamingHack = 24,
  VehicleWater = 25,
  VisibilityResolver = 26,
  WorldUI = 27,
  GameEffects = 28,
  GameProjectiles = 29,
}

public native struct physicsRagdollBodyInfo {
  native let ParentAnimIndex: Int32;
  native let ChildAnimIndex: Int32;
  native let ParentBodyIndex: Int32;
  native let ShapeType: physicsRagdollShapeType;
  native let ShapeRadius: Float;
  native let HalfHeight: Float;
  native let ShapeLocalTranslation: Vector3;
  native let ShapeLocalRotation: Quaternion;
  native let IsRootDisplacementPart: Bool;
  native let SwingAnglesY: [Float; 2];
  native let SwingAnglesZ: [Float; 2];
  native let TwistAngles: [Float; 2];
  native let IsStiff: Bool;
  native let ExcludeFromEarlyCollision: Bool;
  native let FilterDataOverride: CName;
}

public native struct physicsRagdollBodyNames {
  native let ParentAnimName: CName;
  native let ChildAnimName: CName;
}

enum physicsRagdollShapeType {
  CAPSULE = 0,
  BOX = 1,
  SPHERE = 2,
}

public native class physicsSectorCacheArtifact extends CResource {
  native let sectorGeometryKeys: array<physicsGeometryKey>;
  native let sectorInPlaceGeometry: ref<physicsGeometryCacheArtifact>;
  native let sectorBounds: Box;
}

public native struct physicsSectorCacheEntry {
  native let entryOffset: Uint32;
  native let entrySize: Uint32;
}

public native struct physicsSectorEntry {
  native let sectorBounds: Box;
  native let sectorHash: Uint64;
  native let entryOffset: Uint32;
  native let entrySize: Uint32;
}

enum physicsShapeType {
  Box = 0,
  Sphere = 1,
  Capsule = 2,
  ConvexMesh = 3,
  TriangleMesh = 4,
  Invalid = 6,
}

enum physicsSimulationType {
  Static = 0,
  Dynamic = 1,
  Kinematic = 2,
  Invalid = 3,
}

enum physicsStaticCollisionShapeCategory {
  Interior = 0,
  Exterior = 1,
  Architecture = 2,
  Decoration = 3,
  Other = 4,
}

public native struct physicsStaticCollisionShapeDebugInfo {
  native let sourceMeshPathHash: Uint64;
  native let prefabPathHash: Uint64;
  native let nodeNameHash: Uint64;
}

public native class physicsSystemBody extends physicsISystemObject {
  native let params: physicsSystemBodyParams;
  native let localToModel: Transform;
  native let collisionShapes: array<ref<physicsICollider>>;
  native let mappedBoneName: CName;
  native let mappedBoneToBody: Transform;
  native let isQueryBodyOnly: Bool;
}

public native struct physicsSystemBodyParams {
  native let simulationType: physicsSimulationType;
  native let linearDamping: Float;
  native let angularDamping: Float;
  native let solverIterationsCountPosition: Uint32;
  native let solverIterationsCountVelocity: Uint32;
  native let maxDepenetrationVelocity: Float;
  native let maxAngularVelocity: Float;
  native let maxContactImpulse: Float;
  native let mass: Float;
  native let inertia: Vector3;
  native let comOffset: Transform;
}

public native class physicsSystemJoint extends physicsISystemObject {
  native let localToWorld: Matrix;
  native let pinA: ref<physicsPhysicalJointPin>;
  native let pinB: ref<physicsPhysicalJointPin>;
  native let linearLimit: physicsPhysicsJointLinearLimit;
  native let twistLimit: physicsPhysicsJointAngularLimitPair;
  native let swingLimit: physicsPhysicsJointLimitConePair;
  native let driveY: physicsPhysicsJointDrive;
  native let driveX: physicsPhysicsJointDrive;
  native let driveZ: physicsPhysicsJointDrive;
  native let driveTwist: physicsPhysicsJointDrive;
  native let driveSwing: physicsPhysicsJointDrive;
  native let driveSLERP: physicsPhysicsJointDrive;
  native let driveVelocity: physicsPhysicsJointDriveVelocity;
  native let drivePosition: Matrix;
  native let projectionEnabled: Bool;
  native let linearTolerance: Float;
  native let angularTolerance: Float;
  native let isBreakable: Bool;
  native let breakingForce: Float;
  native let breakingTorque: Float;
}

public native class physicsSystemResource extends CResource {
  native let bodies: array<ref<physicsSystemBody>>;
  native let joints: array<ref<physicsSystemJoint>>;
}

public native struct physicsTriggerShape {
  native let shapeType: physicsShapeType;
  native let shapeSize: Vector3;
  native let shapeLocalPose: Transform;
}

public native class PingComponent extends IPlacedComponent {
  native let associatedPingType: gamedataPingType;
}

public native struct Plane {
  native let NormalDistance: Vector4;
}

public native class PlatformSpecificImageController extends inkLogicController {
  native let textureAtlas: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let textureAtlas_PS4: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let textureAtlas_Prospero: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let textureAtlas_XB1: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let textureAtlas_Scarlett: ResourceAsyncRef; // raRef<inkTextureAtlas>
  native let partName: CName;
  native let partName_PS4: CName;
  native let partName_Prospero: CName;
  native let partName_XB1: CName;
  native let partName_Scarlett: CName;
}

public native class PlatformSpecificTextController extends inkLogicController {
  native let textLocKey: CName;
  native let textLocKey_PS4: CName;
  native let textLocKey_Prospero: CName;
  native let textLocKey_XB1: CName;
  native let textLocKey_Scarlett: CName;
}

public native class PlatformSpecificVideoController extends inkLogicController {
  native let isLooped: Bool;
  native let video: ResourceAsyncRef; // raRef<Bink>
  native let video_PS4: ResourceAsyncRef; // raRef<Bink>
  native let video_XB1: ResourceAsyncRef; // raRef<Bink>
}

public native class PlayerFunctionalTests extends IScriptable {
  public final native func RemoveCollision()
  public final native func SetCameraOrientation()
}

public native class PlayerMappinComponent extends IComponent {}

public native class PlayerProximityPrereq extends IPrereq {
  native let squaredRange: Float;
}

public native class PlayerProximityPrereqState extends PrereqState {}

public native struct Point {
  native let x: Int32;
  native let y: Int32;
}

public native struct Point3D {
  native let x: Int32;
  native let y: Int32;
  native let z: Int32;
}

public abstract native class populationModifier extends ISerializable {}

public native class populationPopulationSpawnParameter extends gameObjectSpawnParameter {}

enum populationSpawnerObjectCtrlAction {
  Undefined = 0,
  Activate = 1,
  Deactivate = 2,
  Reactivate = 3,
  ResetKillCount = 4,
  Spawn = 1,
  Despawn = 2,
  Respawn = 3,
}

public native class populationSpawnModifier extends populationModifier {
  native let spawnParameter: ref<gameObjectSpawnParameter>;
}

public native class PositionEvaluator extends PhysicsParticleInitializer {}

enum ProximityProgressBarAction {
  Activated = 0,
  Inactivated = 1,
  Completed = 2,
  WentOutOfRange = 3,
}

public native class prvFunctionalTestsTrigger extends IScriptable {}

public native class PSMResetPhysicalRepresentation extends Event {}

public native class PSMResetStateMachine extends Event {
  native let stateMachineIdentifier: StateMachineIdentifier;
}

public native class PSMTeleportEvent extends Event {}

public native struct PSODescBlendModeDesc {
  native let numTargets: Uint8;
  native let independent: Bool;
  native let alphaToCoverage: Bool;
  native let renderTarget: [PSODescRenderTarget; 8];
}

enum PSODescBlendModeFactor {
  FAC_Zero = 0,
  FAC_One = 1,
  FAC_SrcColor = 2,
  FAC_InvSrcColor = 3,
  FAC_SrcAlpha = 4,
  FAC_InvSrcAlpha = 5,
  FAC_DestColor = 6,
  FAC_InvDestColor = 7,
  FAC_DestAlpha = 8,
  FAC_InvDestAlpha = 9,
  FAC_BlendFactor = 10,
  FAC_InvBlendFactor = 11,
  FAC_Src1Color = 12,
  FAC_InvSrc1Color = 13,
  FAC_Src1Alpha = 14,
  FAC_InvSrc1Alpha = 15,
}

enum PSODescBlendModeOp {
  OP_Add = 0,
  OP_Subtract = 1,
  OP_RevSub = 2,
  OP_Min = 3,
  OP_Max = 4,
  OP_Or = 5,
  OP_And = 6,
  OP_Xor = 7,
  OP_nOr = 9,
  OP_nAnd = 8,
}

enum PSODescBlendModeWriteMask {
  MASK_None = 0,
  MASK_R = 1,
  MASK_G = 2,
  MASK_B = 4,
  MASK_A = 8,
  MASK_RG = 3,
  MASK_RB = 5,
  MASK_RA = 9,
  MASK_GB = 6,
  MASK_GA = 10,
  MASK_BA = 12,
  MASK_RGB = 7,
  MASK_RGA = 11,
  MASK_RBA = 13,
  MASK_GBA = 14,
  MASK_RGBA = 15,
}

enum PSODescDepthStencilModeComparisonMode {
  COMPARISON_Never = 0,
  COMPARISON_Less = 1,
  COMPARISON_Equal = 2,
  COMPARISON_LessEqual = 3,
  COMPARISON_Greater = 4,
  COMPARISON_NotEqual = 5,
  COMPARISON_GreaterEqual = 6,
  COMPARISON_Always = 7,
}

public native struct PSODescDepthStencilModeDesc {
  native let depthTestEnable: Bool;
  native let depthWriteEnable: Bool;
  native let depthFunc: PSODescDepthStencilModeComparisonMode;
  native let stencilEnable: Bool;
  native let stencilReadMask: Bool;
  native let stencilWriteMask: Bool;
  native let frontFace: PSODescStencilFuncDesc;
}

enum PSODescDepthStencilModeStencilOpMode {
  STENCILOP_Keep = 0,
  STENCILOP_Zero = 1,
  STENCILOP_Replace = 2,
  STENCILOP_IncreaseSaturate = 3,
  STENCILOP_DecreaseSaturate = 4,
  STENCILOP_Invert = 5,
  STENCILOP_Increase = 6,
  STENCILOP_Decrease = 7,
}

enum PSODescPrimitiveTopologyType {
  Invalid = 0,
  Point = 1,
  Line = 2,
  Triangle = 3,
  Patch = 4,
}

enum PSODescRasterizerModeCullMode {
  CULL_None = 0,
  CULL_Front = 1,
  CULL_Back = 2,
}

public native struct PSODescRasterizerModeDesc {
  native let wireframe: Bool;
  native let frontWinding: PSODescRasterizerModeFrontFaceWinding;
  native let cullMode: PSODescRasterizerModeCullMode;
  native let allowMSAA: Bool;
  native let conservativeRasterization: Bool;
  native let offsetMode: PSODescRasterizerModeOffsetMode;
  native let scissors: Bool;
  native let valid: Bool;
}

enum PSODescRasterizerModeFrontFaceWinding {
  FRONTFACE_CCW = 0,
  FRONTFACE_CW = 1,
}

enum PSODescRasterizerModeOffsetMode {
  OFFSET_None = 0,
  OFFSET_NormalBias = 1,
  OFFSET_ShadowBias = 2,
  OFFSET_DecalBias = 3,
}

public native struct PSODescRenderTarget {
  native let blendEnable: Bool;
  native let writeMask: PSODescBlendModeWriteMask;
  native let colorOp: PSODescBlendModeOp;
  native let alphaOp: PSODescBlendModeOp;
  native let destFactor: PSODescBlendModeFactor;
  native let destAlphaFactor: PSODescBlendModeFactor;
  native let srcFactor: PSODescBlendModeFactor;
  native let srcAlphaFactor: PSODescBlendModeFactor;
}

public native struct PSODescRenderTargetSetup {
  native let dsFormat: GpuWrapApieTextureFormat;
}

public native struct PSODescStencilFuncDesc {
  native let stencilPassOp: PSODescDepthStencilModeStencilOpMode;
  native let stencilFunc: PSODescDepthStencilModeComparisonMode;
}

public native class puppetpreviewPuppetPreview_UIObjectsLoaderSystemListener extends gameuiIUIObjectsLoaderSystemListener {}

public native struct QsTransform {
  native let Translation: Vector4;
  native let Rotation: Quaternion;
  native let Scale: Vector4;
}

public native struct Quad {
  native let p1: Vector4;
  native let p2: Vector4;
  native let p3: Vector4;
  native let p4: Vector4;
}

public native class QuadRacerPlayer extends MinigamePlayerController {
  native let playerImage: inkImageRef;
  native let leftTireSmoke: inkImageRef;
  native let rightTireSmoke: inkImageRef;
  native let rightFlame: inkImageRef;
  native let leftFlame: inkImageRef;
  native let leftTurnAtlasRegion: CName;
  native let rightTurnAtlasRegion: CName;
  native let straightTurnAtlasRegion: CName;
}

public native class QuadRacerRoad extends MinigameDynObject {
  native let groundParts: array<CName>;
  native let roadParts: array<CName>;
}

public native class QuadRacerSprite extends MinigameDynObject {}

public native struct QueryPreset {
  native let presetName: CName;
}

public native class questAchievementManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIAchievementManagerNodeType>;
}

public native struct questActorOverrideEntry {
  native let MetadataForOverride: CName;
  native let ActorName: CName;
}

public native class questAddBraindanceClue_NodeType extends questIUIManagerNodeType {
  native let clueName: CName;
  native let startTime: Float;
  native let endTime: Float;
  native let layer: gameuiEBraindanceLayer;
}

public native class questAddCombatLogMessage_NodeType extends questIUIManagerNodeType {
  native let message: String;
  native let localizedMessage: LocalizationString;
}

public native class questAddRemoveContact_NodeType extends questIPhoneManagerNodeType {
  native let params: array<questChangeContactList_NodeTypeParams>;
}

public native struct questAddRemoveContact_NodeTypeParams {
  native let contact: CName;
  native let addContact: Bool;
}

public native class questAddRemoveItem_NodeType extends questIItemManagerNodeType {
  native let params: array<ref<questAddRemoveItem_NodeTypeParams>>;
}

public native class questAddRemoveItem_NodeTypeParams extends ISerializable {
  native let sendNotification: Bool;
  native let isPlayer: Bool;
  native let objectRef: EntityReference;
  native let entityRef: ref<questUniversalRef>;
  native let nodeType: questEAddRemoveItemType;
  native let itemID: TweakDBID;
  native let quantity: Int32;
  native let flagItemAddedCallbackAsSilent: Bool;
  native let removeAllQuantity: Bool;
  native let tagToRemove: CName;
  native let itemIDsToIgnoreOnRemove: array<TweakDBID>;
  native let tagsToIgnoreOnRemove: array<CName>;
}

public abstract native class questAICommandNodeBase extends questSignalStoppingNodeDefinition {}

public native class questAnimationEventsOverrideClearNode extends questIAudioNodeType {
  native let resetGlobalOverride: Bool;
  native let resetActorsOverride: Bool;
}

public native class questAnimationEventsOverrideNode extends questIAudioNodeType {
  native let perActorOverrides: array<questActorOverrideEntry>;
  native let GlobalMetadata: CName;
}

public native struct questAnimMoveOnSplineParams {
  native let controllersSetupName: CName;
  native let blendTime: Float;
  native let globalInBlendTime: Float;
  native let globalOutBlendTime: Float;
  native let turnCharacterToMatchVelocity: Bool;
  native let customStartAnimationName: CName;
  native let customMainAnimationName: CName;
  native let customStopAnimationName: CName;
  native let startSnapToTerrain: Bool;
  native let mainSnapToTerrain: Bool;
  native let stopSnapToTerrain: Bool;
  native let startSnapToTerrainBlendTime: Float;
  native let stopSnapToTerrainBlendTime: Float;
}

public native class questAssignCharacter_NodeType extends questIVehicleManagerNodeType {
  native let characterRef: EntityReference;
  native let vehicleRef: EntityReference;
  native let isPlayer: Bool;
  native let assign: Bool;
  native let slotName: CName;
  native let isInstant: Bool;
  native let clearAssignedVehicleIdWhenUnmounting: Bool;
  native let entryAnimName: CName;
  native let entrySlotName: CName;
}

public native class questAssignConvoy_NodeType extends questIVehicleManagerNodeType {
  native let Followers: array<EntityReference>;
  native let vehicleLeaderRef: EntityReference;
}

enum questAttachmentOffsetMode {
  UseRealOffset = 0,
  UseCustomOffset = 1,
}

public native class questAudioCharacterManagerBreathing_NodeSubType extends questIAudioCharacterManager_NodeSubType {}

public native class questAudioCharacterManagerFootsteps_NodeSubType extends questIAudioCharacterManager_NodeSubType {}

public native class questAudioCharacterManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIAudioCharacterManager_NodeType>;
}

public native class questAudioCharacterSystemsManager_NodeType extends questIAudioCharacterManager_NodeType {
  native let subType: ref<questIAudioCharacterManager_NodeSubType>;
}

public native class questAudioEventNodeType extends questIAudioNodeType {
  native let events: array<audioAudEventStruct>;
  native let musicEvents: array<audioAudEventStruct>;
  native let switches: array<audioAudSwitch>;
  native let params: array<audioAudParameter>;
  native let dynamicParams: array<CName>;
  native let event: audioAudEventStruct;
  native let ambientUniqueName: CName;
  native let emitter: CName;
  native let isMusic: Bool;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
}

enum questAudioEventPrefetchMode {
  AddEventPrefetch = 0,
  RemoveEventPrefetch = 1,
}

public native class questAudioEventPrefetchNode extends questIAudioNodeType {
  native let prefetchEvents: array<questAudioEventPrefetchStruct>;
}

public native struct questAudioEventPrefetchStruct {
  native let eventName: CName;
  native let mode: questAudioEventPrefetchMode;
}

public native class questAudioFocusNodeType extends questIAudioNodeType {}

public native class questAudioMixNodeType extends questIAudioNodeType {
  native let mixSignpost: CName;
}

public native class questAudioMusicSyncNodeType extends questIAudioNodeType {
  native let syncType: audioMusicSyncType;
  native let description: String;
  native let syncTrack: CName;
  native let userCue: CName;
}

public native class questAudioNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questIAudioNodeType>;
}

public native class questAudioParameterNodeType extends questIAudioNodeType {
  native let param: audioAudParameter;
  native let isMusic: Bool;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
}

public native class questAudioSetListenerOverrideNodeType extends questIAudioNodeType {
  native let enable: Bool;
}

public native class questAudioSwitchNodeType extends questIAudioNodeType {
  native let switch: audioAudSwitch;
  native let isMusic: Bool;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
}

public native class questAudioVehicleMultipliers_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let multipliers: audioVehicleMultipliers;
}

enum questAvailableVehicleType {
  AnyCar = 0,
  AnyMotorcycle = 1,
  AnyVehicle = 2,
  SpecificVehicle = 3,
}

public abstract native class questBaseObjectNodeDefinition extends questDisableableNodeDefinition {
  native let reference: NodeRef;
}

public native class questBehaviourManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let puppet: EntityReference;
  native let type: ref<workIWorkspotQuestAction>;
  native let newType: ref<questIBehaviourManager_NodeType>;
}

public native class questBehind_ConditionType extends questISensesConditionType {
  native let targetRef: EntityReference;
  native let eventType: questBehindInteractionEventType;
}

enum questBehindInteractionEventType {
  Undefined = 0,
  StartedBeingBehind = 1,
  StoppedBeingBehind = 2,
  IsBehind = 3,
  IsNotBehind = 4,
}

enum questBlockAction {
  Block = 0,
  Unblock = 1,
  UnblockAll = 2,
}

public native class questBlockTokenActivation_NodeSubType extends questIContentTokenManager_NodeSubType {
  native let action: questBlockAction;
  native let source: CName;
  native let resetTokenSpawnTimer: Bool;
}

enum questBriefingPlayerType {
  Fullscreen = 0,
  Hud = 1,
  World = 2,
}

public native class questBriefingSequencePlayer_NodeType extends questIUIManagerNodeType {
  native let function: questBriefingSequencePlayerFunction;
  native let briefingResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let userData: ref<inkUserData>;
  native let audioEvent: CName;
  native let animationName: CName;
  native let startMarkerName: CName;
  native let endMarkerName: CName;
  native let loopType: inkanimLoopType;
  native let briefingPlayerType: questBriefingPlayerType;
  native let briefingType: questBriefingType;
  native let enableScanner: Bool;
}

public native class questBriefingSequencePlayerEvent extends Event {}

enum questBriefingSequencePlayerFunction {
  StartSequence = 0,
  ChangeSequence = 1,
  FinishSequence = 2,
}

enum questBriefingType {
  Fullscreen = 0,
  Hud = 1,
  World = 2,
}

public native class questBuild_ConditionType extends questIStatsScriptConditionType {}

public native class questCallContact_NodeType extends questIPhoneManagerNodeType {
  native let caller: ref<gameJournalPath>;
  native let addressee: ref<gameJournalPath>;
  native let phase: questPhoneCallPhase;
  native let mode: questPhoneCallMode;
  native let prefabNodeRef: NodeRef;
  native let applyPhoneRestriction: Bool;
  native let isRejectable: Bool;
  native let showAvatar: Bool;
  native let visuals: questPhoneCallVisuals;
}

public native class questCameraClippingPlane_NodeType extends questISceneManagerNodeType {
  native let preset: questCameraPlanesPreset;
}

public native class questCameraFocus_ConditionType extends questISystemConditionType {
  native let objectRef: EntityReference;
  native let timeInterval: Float;
  native let onScreenTest: Bool;
  native let useFrustrumCheck: Bool;
  native let angleTolerance: Float;
  native let inverted: Bool;
  native let zoomed: Bool;
}

enum questCameraParallaxSpace {
  Trajectory = 0,
  Camera = 1,
  Chest = 2,
}

enum questCameraPlanesPreset {
  Undefined = 0,
  VeryNear = 1,
  Near = 2,
  Normal = 3,
  None = 4,
}

public native struct questChangeContactList_NodeTypeParams {
  native let contact: ref<gameJournalPath>;
  native let addContact: Bool;
  native let sendNotification: Bool;
}

public native class questChangeGameDifficulty_NodeSubType extends questIGameManagerNonSignalStoppingNodeType {
  native let difficulty: gameDifficulty;
}

public native class questChangeVoicesetState_NodeType extends questIVoicesetManager_NodeType {
  native let params: array<questChangeVoicesetState_NodeTypeParams>;
}

public native struct questChangeVoicesetState_NodeTypeParams {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let enableVoicesetLines: Bool;
  native let enableVoicesetGrunts: Bool;
  native let inputsToBlock: array<entVoicesetInputToBlock>;
}

public native class questCharacterAim_ConditionType extends questICharacterConditionType {
  native let isPlayer: Bool;
  native let preciseAiming: Bool;
  native let targetRef: EntityReference;
}

public native class questCharacterAppearancePrefetched_ConditionType extends questICharacterConditionType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let appearanceName: CName;
}

public native class questCharacterAttack_ConditionType extends questICharacterConditionType {
  native let attackerRef: EntityReference;
  native let targetRef: EntityReference;
  native let isTargetPlayer: Bool;
}

public native class questCharacterBodyType_CondtionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let gender: CName;
}

public native class questCharacterCallReinforcements_ConditionType extends questICharacterConditionType {
  native let puppetRef: EntityReference;
}

public native class questCharacterCombat_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let inverted: Bool;
}

public native class questCharacterCondition extends questTypedCondition {
  native let type: ref<questICharacterConditionType>;
}

public native class questCharacterControlledObjectHit_ConditionType extends questICharacterConditionType {
  native let attackerRef: EntityReference;
  native let targetRef: EntityReference;
  native let isTargetPlayer: Bool;
  native let includeHitTypes: array<questCharacterHitEventType>;
  native let excludeHitTypes: array<questCharacterHitEventType>;
  native let includeHitShapes: array<CName>;
  native let excludeHitShapes: array<CName>;
}

public native class questCharacterCover_ConditionType extends questICharacterConditionType {
  native let puppetRef: EntityReference;
  native let coverRef: NodeRef;
}

public native class questCharacterCyberdeckProgram_ConditionType extends questICharacterConditionType {
  native let cyberdeckProgramID: TweakDBID;
}

public native class questCharacterEquippedItem_ConditionType extends questICharacterConditionType {
  native let isPlayer: Bool;
  native let puppetRef: EntityReference;
  native let itemID: TweakDBID;
  native let itemTag: CName;
  native let excludedTweakDBIDs: array<TweakDBID>;
  native let excludedTags: array<CName>;
  native let inverted: Bool;
}

public native class questCharacterEquippedItemAttachmentSlotsListener extends AttachmentSlotsListener {}

public native class questCharacterEquippedItemInventoryListener extends InventoryListener {}

public native class questCharacterEquippedWeapon_ConditionType extends questICharacterConditionType {
  native let anyWeaponEquipped: Bool;
  native let weaponID: String;
  native let weaponTag: CName;
  native let inverted: Bool;
}

public native class questCharacterGender_CondtionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let gender: CName;
}

public native class questCharacterGroupAttitude_CondtionType extends questICharacterConditionType {
  native let group1Name: CName;
  native let group2Name: CName;
  native let attitude: EAIAttitude;
}

public native class questCharacterHealth_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let percent: Float;
  native let comparisonType: EComparisonType;
}

public native class questCharacterHit_ConditionType extends questICharacterConditionType {
  native let attackerRef: EntityReference;
  native let isAttackerPlayer: Bool;
  native let targetRef: EntityReference;
  native let isTargetPlayer: Bool;
  native let includeHitTypes: array<questCharacterHitEventType>;
  native let excludeHitTypes: array<questCharacterHitEventType>;
  native let includeHitShapes: array<CName>;
  native let excludeHitShapes: array<CName>;
}

enum questCharacterHitEventType {
  Bullet = 0,
  Explosion = 1,
  Melee = 2,
  Other = 3,
}

public native class questCharacterKilled_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let source: ref<questUniversalRef>;
  native let comparisonParams: ref<questComparisonParam>;
  native let killed: Bool;
  native let unconscious: Bool;
  native let defeated: Bool;
}

public native class questCharacterLifePath_ConditionType extends questICharacterConditionType {
  native let lifePathID: TweakDBID;
}

public native class questCharacterManagerCombat_AssignSquad extends questICharacterManagerCombat_NodeSubType {
  native let presetID: TweakDBID;
  native let puppetRef: EntityReference;
  native let squadType: AISquadType;
}

public native class questCharacterManagerCombat_ChangeLevel extends questICharacterManagerCombat_NodeSubType {
  native let puppetRef: EntityReference;
  native let level: questInt32ValueWrapper;
  native let setExactLevel: Bool;
}

public native class questCharacterManagerCombat_EquipWeapon extends questICharacterManagerCombat_NodeSubType {
  native let equip: Bool;
  native let weaponID: TweakDBID;
  native let slotID: TweakDBID;
  native let equipLastWeapon: Bool;
  native let forceFirstEquip: Bool;
  native let instant: Bool;
  native let ignoreStateMachine: Bool;
}

public native class questCharacterManagerCombat_Kill extends questICharacterManagerCombat_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let noAnimation: Bool;
  native let noRagdoll: Bool;
  native let skipDefeatedState: Bool;
  native let doDismemberment: Bool;
  native let dismembermentStrenght: Float;
}

public native class questCharacterManagerCombat_ManageRagdoll extends questICharacterManagerCombat_NodeSubType {
  native let puppetRef: EntityReference;
  native let enableRagdoll: Bool;
}

public native class questCharacterManagerCombat_ModifyHealth extends questICharacterManagerCombat_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let percent: Float;
  native let setExactValue: Bool;
  native let noDamageIndicator: Bool;
  native let damageSourceRef: EntityReference;
}

public native class questCharacterManagerCombat_NodeType extends questICharacterManager_NodeType {
  native let subtype: ref<questICharacterManagerCombat_NodeSubType>;
}

public native class questCharacterManagerCombat_SetDeathDirection extends questICharacterManagerCombat_NodeSubType {
  native let puppetRef: EntityReference;
  native let direction: gameeventsDeathDirection;
}

public native class questCharacterManagerCombat_SetWeaponState extends questICharacterManagerCombat_NodeSubType {
  native let areaType: gameCityAreaType;
}

public native class questCharacterManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questICharacterManager_NodeType>;
}

public native class questCharacterManagerParameters_EnableBumps extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let enable: Bool;
  native let policy: AIinfluenceEBumpPolicy;
}

public native class questCharacterManagerParameters_HealPlayer extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let heal: Bool;
  native let removeStatusEffects: Bool;
  native let removeBuffs: Bool;
  native let removeDebuffs: Bool;
  native let resetCyberdeckRAM: Bool;
}

public native class questCharacterManagerParameters_NodeType extends questICharacterManager_NodeType {
  native let subtype: ref<questICharacterManagerParameters_NodeSubType>;
}

public native class questCharacterManagerParameters_SetAnimset extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let variableName: CName;
  native let value: Float;
}

public native class questCharacterManagerParameters_SetAsCrowdObstacle extends questICharacterManagerParameters_NodeSubType {
  native let params: array<questSetAsCrowdObstacle_NodeTypeParams>;
}

public native class questCharacterManagerParameters_SetAttitudeGroupForPuppet extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let groupName: CName;
}

public native class questCharacterManagerParameters_SetCombatSpace extends questICharacterManagerCombat_NodeSubType {
  native let puppetRef: EntityReference;
  native let combatSpaceSize: AICombatSpaceSize;
}

public native class questCharacterManagerParameters_SetGender extends questICharacterManagerParameters_NodeSubType {
  native let params: array<questSetGender_NodeTypeParams>;
}

public native class questCharacterManagerParameters_SetGroupsAttitude extends questICharacterManagerParameters_NodeSubType {
  native let set: Bool;
  native let group1Name: CName;
  native let group2Name: CName;
  native let attitude: EAIAttitude;
}

public native class questCharacterManagerParameters_SetLifePath extends questICharacterManagerParameters_NodeSubType {
  native let lifePathID: TweakDBID;
}

public native class questCharacterManagerParameters_SetLowGravity extends questICharacterManagerParameters_NodeSubType {
  native let enable: Bool;
}

public native class questCharacterManagerParameters_SetMortality extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let state: gameGodModeType;
  native let resetToDefault: Bool;
  native let source: CName;
}

public native class questCharacterManagerParameters_SetProgressionBuild extends questICharacterManagerParameters_NodeSubType {
  native let buildID: TweakDBID;
}

public native class questCharacterManagerParameters_SetReactionPreset extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let recordSelector: ref<questReactionPresetRecordSelector>;
}

public native class questCharacterManagerParameters_SetSensePreset extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let presetID: TweakDBID;
  native let main: Bool;
  native let resetToMain: Bool;
}

public native class questCharacterManagerParameters_SetStatusEffect extends questICharacterManagerParameters_NodeSubType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let statusEffectID: TweakDBID;
  native let isPlayerStatusEffectSource: Bool;
  native let statusEffectSourceObject: EntityReference;
  native let recordSelector: ref<questRecordSelector>;
  native let set: Bool;
}

public native class questCharacterManagerVisuals_BreastSizeController extends questICharacterManagerVisuals_NodeSubType {
  native let bodyGroupName: CName;
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let customizedSize: Bool;
}

public native class questCharacterManagerVisuals_ChangeEntityAppearance extends questCharacterManagerVisuals_EntityAppearanceOperationBase {}

public abstract native class questCharacterManagerVisuals_EntityAppearanceOperationBase extends questICharacterManagerVisuals_NodeSubType {
  native let appearanceEntries: array<questCharacterManagerVisuals_EntityAppearanceOperationBaseEntityAppearanceEntry>;
}

public native struct questCharacterManagerVisuals_EntityAppearanceOperationBaseEntityAppearanceEntry {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let appearanceName: CName;
}

public native class questCharacterManagerVisuals_GenitalsManager extends questICharacterManagerVisuals_NodeSubType {
  native let bodyGroupName: CName;
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let enable: Bool;
}

public native class questCharacterManagerVisuals_NodeType extends questICharacterManager_NodeType {
  native let subtype: ref<questICharacterManagerVisuals_NodeSubType>;
}

public native class questCharacterManagerVisuals_OverridePlayerCustomizations extends questICharacterManagerVisuals_NodeSubType {
  native let customizationData: array<gameuiForcePlayerCustomizationData>;
}

public native class questCharacterManagerVisuals_OverridePlayerHairstyleAppearance extends questICharacterManagerVisuals_NodeSubType {
  native let hairstyleIndex: Uint32;
  native let hairstyleDefinitionName: CName;
  native let beardIndex: Uint32;
  native let beardPartIndex: Uint32;
  native let beardDefinitionName: CName;
}

public native class questCharacterManagerVisuals_PrefetchEntityAppearance extends questCharacterManagerVisuals_EntityAppearanceOperationBase {}

public native class questCharacterManagerVisuals_SetBrokenNoseStage extends questICharacterManagerVisuals_NodeSubType {
  native let brokenNoseStage: gameuiCharacterCustomization_BrokenNoseStage;
}

public native class questCharacterMount_ConditionType extends questICharacterConditionType {
  native let anyParent: Bool;
  native let parentRef: EntityReference;
  native let parentIsPlayer: Bool;
  native let anyChild: Bool;
  native let childRef: EntityReference;
  native let childIsPlayer: Bool;
  native let condition: questMountConditionType;
  native let enterAnimationFinished: Bool;
  native let role: gameMountingSlotRole;
  native let usePlayersVehicle: Bool;
  native let playerVehicleName: String;
  native let vehicleType: questMountVehicleType;
  native let vehicleOrigin: questMountVehicleOrigin;
  native let vehicleAfiliation: gamedataAffiliation;
}

public native class questCharacterMountedTogether_ConditionType extends questICharacterConditionType {
  native let vehicleType: questMountVehicleType;
  native let vehicleOrigin: questMountVehicleOrigin;
  native let characters: array<ref<questMountedObjectInfo>>;
}

public native class questCharacterQuickHacked_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let quickHacked: Bool;
}

public native class questCharacterQuickHackUploadBegin_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
}

public native class questCharacterReaction_ConditionType extends questICharacterConditionType {
  native let puppetRef: EntityReference;
  native let isAnyReaction: Bool;
  native let reactionBehaviorID: TweakDBID;
}

public native class questCharacterRoleFinished_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let role: AIFiniteRoleType;
}

public native class questCharacterSceneSpot_ConditionType extends questICharacterConditionType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let workName: CName;
  native let waitForEnd: Bool;
}

public native class questCharacterSpawned_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let comparisonParams: ref<questComparisonParam>;
}

public native class questCharacterState_ConditionType extends questICharacterConditionType {
  native let subType: ref<questICharacterConditionSubType>;
}

public native class questCharacterState_PlayerSubType extends questICharacterConditionSubType {
  native let locomotionComparisonType: questEComparisonTypeEquality;
  native let locomotionState: gamePSMLocomotionStates;
  native let upperBodyComparisonType: questEComparisonTypeEquality;
  native let upperBodyState: gamePSMUpperBodyStates;
  native let weaponComparisonType: questEComparisonTypeEquality;
  native let weaponState: gamePSMRangedWeaponStates;
  native let timeDilationComparisonType: questEComparisonTypeEquality;
  native let timeDilationState: gamePSMTimeDilation;
  native let vehicleComparisonType: questEComparisonTypeEquality;
  native let vehicleState: gamePSMVehicle;
  native let takedownStateComparisonType: questEComparisonTypeEquality;
  native let takedownState: gamePSMTakedown;
  native let swimmingStateComparisonType: questEComparisonTypeEquality;
  native let swimmingState: gamePSMSwimming;
}

public native class questCharacterState_PuppetSubType extends questICharacterConditionSubType {
  native let puppetRef: EntityReference;
  native let upperBodyComparisonType: questEComparisonTypeEquality;
  native let upperBodyState: Int32;
  native let highLevelComparisonType: questEComparisonTypeEquality;
  native let highLevelState: Int32;
  native let stanceComparisonType: questEComparisonTypeEquality;
  native let stanceState: Int32;
}

public native class questCharacterStatPool_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let percent: Float;
  native let comparisonType: EComparisonType;
  native let statPoolType: gamedataStatPoolType;
}

public native class questCharacterStatusEffect_CondtionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let statusEffectID: String;
  native let inverted: Bool;
}

public abstract native class questCharacterStatusEffectsListener extends IStatusEffectListener {}

public native class questCharacterTriggeredCombatInSecuritySystem_ConditionType extends questICharacterConditionType {
  native let objectRef: EntityReference;
}

public native class questCharacterWorkspot_ConditionType extends questICharacterConditionType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let spotRef: NodeRef;
  native let animationName: CName;
  native let waitForAnimEnd: Bool;
}

public native class questCheckpointNodeDefinition extends questSignalStoppingNodeDefinition {
  native let saveLock: Bool;
  native let ignoreSaveLocks: Bool;
  native let pointOfNoReturn: Bool;
  native let endGameSave: Bool;
  native let retryOnFailure: Bool;
  native let additionalEndGameRewardsTweak: array<TweakDBID>;
  native let debugString: String;
}

public native class questChoiceSection_ConditionType extends questISceneConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
  native let choiceSectionId: scnNodeId;
  native let choiceSectionName: CName;
  native let optionName: CName;
  native let mode: questChoiceSection_ConditionTypeMode;
}

enum questChoiceSection_ConditionTypeMode {
  Highlight = 0,
  Selection = 1,
}

public native class questCleanupNotifications_NodeType extends questIUIManagerNodeType {}

public native class questClearForcedBehavioursNodeDefinition extends questSignalStoppingNodeDefinition {
  native let puppet: EntityReference;
}

public native class questCloseMessage_NodeType extends questIPhoneManagerNodeType {
  native let msg: ref<gameJournalPath>;
}

public native class questCombatNodeDefinition extends questConfigurableAICommandNode {
  native let entityReference: EntityReference;
  native let function: CName;
  native let params: ref<AICommandParams>;
}

enum questCombatNodeFunctions {
  CombatTarget = 0,
  ShootAt = 1,
  LookAtTarget = 2,
  ThrowGrenade = 3,
  UseCover = 4,
  SwitchWeapon = 5,
  PrimaryWeapon = 6,
  SecondaryWeapon = 7,
  RestrictMovementToArea = 8,
}

public native class questCombatNodeParams_CombatTarget extends questCombatNodeParams {
  native let targetNode: NodeRef;
  native let targetPuppet: EntityReference;
  native let duration: Float;
  native let immediately: Bool;
}

public native class questCombatNodeParams_LookAtTarget extends questCombatNodeParams {
  native let targetNode: NodeRef;
  native let targetPuppet: EntityReference;
  native let duration: Float;
  native let immediately: Bool;
}

public native class questCombatNodeParams_PrimaryWeapon extends questCombatNodeParams {
  native let unEquip: Bool;
}

public native class questCombatNodeParams_RestrictMovementToArea extends questCombatNodeParams {
  native let area: NodeRef;
}

public native class questCombatNodeParams_SecondaryWeapon extends questCombatNodeParams {
  native let unEquip: Bool;
}

public native class questCombatNodeParams_ShootAt extends questCombatNodeParams {
  native let targetOverrideNode: NodeRef;
  native let targetOverridePuppet: EntityReference;
  native let duration: Float;
  native let once: Bool;
  native let immediately: Bool;
}

public native class questCombatNodeParams_SwitchWeapon extends questCombatNodeParams {
  native let mode: questSwitchWeaponModes;
}

public native class questCombatNodeParams_ThrowGrenade extends questCombatNodeParams {
  native let targetOverrideNode: NodeRef;
  native let targetOverridePuppet: EntityReference;
  native let duration: Float;
  native let once: Bool;
  native let force: Bool;
  native let immediately: Bool;
}

public native class questCombatNodeParams_UseCover extends questCombatNodeParams {
  native let cover: NodeRef;
  native let oneTimeSelection: Bool;
  native let forceStance: array<AICoverExposureMethod>;
  native let forcedEntryAnimation: CName;
  native let immediately: Bool;
}

public abstract native class questCombatNodeParams extends AICommandParams {}

public native class questCommunityTemplate_NodeType extends questSpawnManagerNodeType {
  native let spawnerReference: NodeRef;
  native let communityEntryName: CName;
  native let communityEntryPhaseName: CName;
}

enum questCompanionPositions {
  Behind = 0,
  InFront = 1,
}

public native class questComparisonParam extends ISerializable {
  native let entireCommunity: Bool;
  native let count: Uint32;
  native let comparisonType: EComparisonType;
}

public native struct questComponentCollisionMapArrayElement {
  native let componentNameKey: CName;
  native let enableCollision: Bool;
  native let enableQueries: Bool;
}

public abstract native class questCondition extends questIBaseCondition {}

public native struct questConditionItem {
  native let condition: ref<questIBaseCondition>;
  native let socketId: Uint32;
}

public native class questConditionNodeDefinition extends questDisableableNodeDefinition {
  native let condition: ref<questIBaseCondition>;
}

public abstract native class questConfigurableAICommandNode extends questAICommandNodeBase {}

public native class questConstAICommandParams extends AICommandParams {
  native let command: ref<AICommand>;
}

public native class questContentBlockTriggerAreaNotifier extends worldITriggerAreaNotifer {
  native let resetTokenSpawnTimer: Bool;
}

public native class questContentBlockTriggerAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class questContentCondition extends questTypedCondition {
  native let type: ref<questIContentConditionType>;
}

public native class questContentLock_ConditionType extends questIContentConditionType {
  native let isContentBlocked: Bool;
}

public native class questContentSwitch_ConditionType extends questISystemConditionType {
  native let switchName: CName;
}

public native class questContentToken_ConditionType extends questIContentConditionType {
  native let type: questQuestContentType;
}

public native class questContentTokenManager_NodeType extends questIGameManagerNonSignalStoppingNodeType {
  native let subtype: ref<questIContentTokenManager_NodeSubType>;
}

enum questControlCrowdAction {
  Disable = 0,
  Enable = 1,
}

public native class questControlObject_NodeType extends questIGameManagerNonSignalStoppingNodeType {
  native let objectRef: EntityReference;
}

public native class questCountdownTimer_NodeType extends questIUIManagerNodeType {
  native let duration: Float;
}

public native class questCreditsForceStopped_ConditionType extends questIUIConditionType {}

public native class questCreditsRolling_ConditionType extends questIUIConditionType {}

public native class questCrowdManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questICrowdManager_NodeType>;
}

public native class questCrowdManagerNodeType_ControlCrowd extends questICrowdManager_NodeType {
  native let action: questControlCrowdAction;
  native let debugSource: CName;
  native let distantCrowdOnly: Bool;
}

public native class questCrowdManagerNodeType_EnableNullArea extends questICrowdManager_NodeType {
  native let areaReference: NodeRef;
  native let enable: Bool;
}

enum questCustomStyle {
  PlacidePhone = 0,
  VideoCallInterupt = 1,
}

public native class questCutControlNodeDefinition extends questDisableableNodeDefinition {
  native let permanent: Bool;
}

public native class questCyberdrill_NodeType extends questIInteractiveObjectManagerNodeType {
  native let params: array<questCyberdrill_NodeTypeParams>;
}

public native struct questCyberdrill_NodeTypeParams {
  native let objectRef: NodeRef;
  native let enable: Bool;
}

public native struct questdbgCallstackBlock {
  native let id: Uint64;
  native let parentId: Uint64;
}

public native struct questdbgCallstackData {
  native let resourceHash: Uint64;
  native let phases: array<questdbgCallstackPhase>;
  native let blocks: array<questdbgCallstackBlock>;
  native let executed: array<Uint64>;
  native let executedHistory: array<Uint64>;
  native let failed: array<Uint64>;
  native let callstackRevision: Uint32;
}

public native struct questdbgRuntimeData {
  native let version: Uint64;
  native let questResourcePathHash: Uint64;
  native let selectedBlockId: Uint64;
  native let objects: array<ref<ISerializable>>;
}

public native class questDebugShowMessageNodeDefinition extends questDisableableNodeDefinition {}

public native class questDeletionMarkerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let deletedNodeIds: array<Uint16>;
}

public native class questDestruction_ConditionType extends questIObjectConditionType {
  native let objectRef: EntityReference;
  native let threshold: Float;
}

public native struct questDevice_ConditionFunctionParameter {
  native let name: CName;
  native let value: Variant;
}

public native class questDevice_ConditionType extends questIObjectConditionType {
  native let objectRef: NodeRef;
  native let deviceControllerClass: CName;
  native let deviceConditionFunction: CName;
  native let functionParameters: array<questDevice_ConditionFunctionParameter>;
}

public native struct questDeviceManager_ActionProperty {
  native let name: CName;
  native let value: Variant;
  native let min: Float;
  native let max: Float;
}

public native class questDeviceManager_NodeType extends questIInteractiveObjectManagerNodeType {
  native let params: array<ref<questDeviceManager_NodeTypeParams>>;
}

public native class questDeviceManager_NodeTypeParams extends ISerializable {
  native let objectRef: NodeRef;
  native let slotName: CName;
  native let entityRef: EntityReference;
  native let deviceControllerClass: CName;
  native let deviceAction: CName;
  native let actionProperties: array<questDeviceManager_ActionProperty>;
}

public native class questDifficulty_ConditionType extends questIStatsConditionType {
  native let difficulty: gameDifficulty;
}

public abstract native class questDisableableNodeDefinition extends questNodeDefinition {}

public native class questDisableTeleportingMonitoring_NodeType extends questIWorldDataManagerNodeType {}

public native class questDiscoverBraindanceClue_NodeType extends questIUIManagerNodeType {
  native let clueName: CName;
}

public native class questDisplayMessageBox_NodeType extends questIUIManagerNodeType {
  native let title: String;
  native let message: String;
  native let localizedTitle: LocalizationString;
  native let localizedMessage: LocalizationString;
}

public native class questDistanceComparison_ConditionType extends questIDistanceConditionType {
  native let distanceDefinition1: ref<questObjectDistance>;
  native let distanceDefinition2: ref<questValueDistance>;
  native let comparisonType: EComparisonType;
}

public native class questDistanceCondition extends questTypedCondition {
  native let type: ref<questIDistanceConditionType>;
}

enum questDistanceType {
  Nearest = 0,
  Furthest = 1,
}

public native class questDistanceVsDistanceComparison_ConditionType extends questIDistanceConditionType {
  native let distanceDefinition1: ref<questObjectDistance>;
  native let distanceDefinition2: ref<questObjectDistance>;
  native let comparisonType: EComparisonType;
}

public native class questDrillingState_ConditionType extends questIObjectConditionType {
  native let objectRef: NodeRef;
  native let state: questDrillingState;
}

enum questDrillingState {
  Undefined = 0,
  Started = 1,
  Finished = 2,
}

public native class questDropItemFromSlot_NodeType extends questIItemManagerNodeType {
  native let params: array<questDropItemFromSlot_NodeTypeParams>;
}

public native struct questDropItemFromSlot_NodeTypeParams {
  native let objectRef: EntityReference;
  native let slotId: TweakDBID;
  native let useGravity: Bool;
}

public native class questDynamicSpawnSystemCondition extends questTypedCondition {
  native let type: ref<questIDynamicSpawnSystemConditionType>;
}

public native class questDynamicSpawnSystemEnemies_ConditionType extends questIDistanceConditionType {
  native let distanceDefinition1: ref<questDynamicSpawnSystemEnemyDistance>;
  native let distanceDefinition2: ref<questValueDistance>;
  native let comparisonType: EComparisonType;
}

public native class questDynamicSpawnSystemEnemyDistance extends questIDistance {
  native let waveTag: CName;
  native let checkAllEnemies: Bool;
  native let distanceType: questDistanceType;
}

public native class questDynamicSpawnSystemNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIDynamicSpawnSystemType>;
}

public native class questDynamicVehicleDespawn_NodeType extends questIDynamicSpawnSystemType {
  native let ImmediateDespawn: Bool;
  native let waveTag: CName;
}

public native class questDynamicVehicleDespawnAll_NodeType extends questIDynamicSpawnSystemType {
  native let ImmediateDespawn: Bool;
}

public native class questDynamicVehicleSpawn_NodeType extends questIDynamicSpawnSystemType {
  native let VehicleData: array<TweakDBID>;
  native let waveTag: CName;
  native let spawnDirectionPreference: questSpawnDirectionPreference;
  native let distanceRange: Vector2;
}

enum questEAddRemoveItemType {
  AddItem = 0,
  RemoveByItemID = 1,
  RemoveByTag = 2,
  RemoveAll = 3,
}

enum questEComparisonTypeEquality {
  Equal = 0,
  NotEqual = 1,
}

enum questEDebugViewMode {
  NONE = 0,
  CLAY = 1,
  PURE_GRAY = 2,
  PURE_WHITE = 3,
  SHADOWS = 4,
  BASE_COLOR = 5,
  NORMALS = 6,
  ROUGHNESS = 7,
  METALNESS = 8,
  EMISSIVE = 9,
  MATERIAL_ID = 10,
  WIREFRAME = 11,
  OVERDRAW = 12,
}

public native class questElevator_ManageNPCAttachment_NodeType extends questIInteractiveObjectManagerNodeType {
  native let params: array<questElevator_ManageNPCAttachment_NodeTypeParams>;
}

public native struct questElevator_ManageNPCAttachment_NodeTypeParams {
  native let elevatorRef: NodeRef;
  native let npcRef: EntityReference;
  native let action: questElevator_ManageNPCAttachment_NodeTypeParamsAction;
}

enum questElevator_ManageNPCAttachment_NodeTypeParamsAction {
  Attach = 0,
  Detach = 1,
}

public abstract native class questEmbeddedGraphNodeDefinition extends questSignalStoppingNodeDefinition {}

public native class questEnableBraindanceFinish_NodeType extends questIUIManagerNodeType {}

public native class questEnablePlayerGameplayLookAt_NodeType extends questISceneManagerNodeType {
  native let enable: Bool;
}

public native class questEnablePlayerVehicle_NodeType extends questIVehicleManagerNodeType {
  native let vehicle: String;
  native let enable: Bool;
  native let despawn: Bool;
  native let makePlayerActiveVehicle: Bool;
}

public native class questEnableScanning_NodeType extends questIVisionModeNodeType {
  native let objectRef: EntityReference;
  native let enable: Bool;
}

public native class questEnableVehicleSummon_NodeType extends questIVehicleManagerNodeType {
  native let enable: Bool;
}

public native class questEndNodeDefinition extends questStartEndNodeDefinition {}

public native class questEnforceScreenSpaceReflectionsUberQuality_NodeType extends questIRenderFxManagerNodeType {
  native let enabled: Bool;
}

public native class questEnterVisionMode_NodeType extends questIVisionModeNodeType {
  native let objectRef: EntityReference;
  native let visionModeType: gameVisionModeType;
}

public native class questEntityAppearance_ConditionType extends questIEntityConditionType {
  native let entityRef: EntityReference;
  native let appearance: CName;
}

public native class questEntityCondition extends questTypedCondition {
  native let type: ref<questIEntityConditionType>;
}

public native class questEntityManagerAddDevelopmentPoint_NodeType extends questIEntityManager_NodeType {
  native let value: Int32;
  native let type: gamedataDevelopmentPointType;
}

public native class questEntityManagerChangeAppearance_NodeType extends questIEntityManager_NodeType {
  native let entityRef: EntityReference;
  native let prefetchOnly: Bool;
  native let appearanceName: CName;
}

public native class questEntityManagerDestroyCarriedObject extends questIEntityManagerSetAttachment_NodeSubType {
  native let attachmentRef: NodeRef;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
}

public native class questEntityManagerEnablePlayerTPPRepresentation_NodeType extends questIEntityManager_NodeType {
  native let enable: Bool;
}

public native class questEntityManagerForceStat_NodeType extends questIEntityManager_NodeType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let statType: gamedataStatType;
  native let value: Float;
  native let unforce: Bool;
  native let debugSource: CName;
}

public native class questEntityManagerLevelUpProficiency_NodeType extends questIEntityManager_NodeType {
  native let type: gamedataProficiencyType;
}

public native class questEntityManagerManageBinkComponent_NodeType extends questIEntityManager_NodeType {
  native let params: array<questEntityManagerManageBinkComponent_NodeTypeParams>;
}

public native struct questEntityManagerManageBinkComponent_NodeTypeParams {
  native let objectRef: EntityReference;
  native let videoPath: String;
  native let action: gameBinkVideoAction;
}

public native class questEntityManagerMountPuppet_NodeType extends questIEntityManager_NodeType {
  native let parentRef: EntityReference;
  native let childRef: EntityReference;
  native let isParentPlayer: Bool;
  native let slotName: CName;
  native let assign: Bool;
  native let isInstant: Bool;
  native let forcedCarryStyle: gamePSMBodyCarryingStyle;
  native let removePitchRollRotation: Bool;
}

public native class questEntityManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIEntityManager_NodeType>;
}

public native class questEntityManagerRemoteControlVehicle_NodeType extends questIEntityManager_NodeType {
  native let parentRef: EntityReference;
  native let enable: Bool;
  native let shouldUnseatPassengers: Bool;
  native let shouldModifyInteractionState: Bool;
}

public native class questEntityManagerSendAnimationEvent_NodeType extends questIEntityManager_NodeType {
  native let objectRef: EntityReference;
  native let eventName: CName;
}

public native class questEntityManagerSetAttachment_NodeType extends questIEntityManager_NodeType {
  native let subtype: ref<questIEntityManagerSetAttachment_NodeSubType>;
}

public native class questEntityManagerSetAttachment_ToActor extends questIEntityManagerSetAttachment_NodeSubType {
  native let attachmentRef: NodeRef;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let slot: CName;
  native let offsetMode: questAttachmentOffsetMode;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
}

public native class questEntityManagerSetAttachment_ToNode extends questIEntityManagerSetAttachment_NodeSubType {
  native let attachmentRef: NodeRef;
  native let objectRef: NodeRef;
  native let slot: CName;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
}

public native class questEntityManagerSetAttachment_ToWorld extends questIEntityManagerSetAttachment_NodeSubType {
  native let attachmentRef: NodeRef;
  native let offsetMode: questAttachmentOffsetMode;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
}

public native class questEntityManagerSetDestructionState_NodeType extends questIEntityManager_NodeType {
  native let action: questSetDestructionStateAction;
  native let params: array<questEntityManagerSetDestructionState_NodeTypeParams>;
}

public native struct questEntityManagerSetDestructionState_NodeTypeParams {
  native let objectRef: EntityReference;
  native let tag: CName;
}

public native class questEntityManagerSetMeshAppearance_NodeType extends questIEntityManager_NodeType {
  native let params: array<questEntityManagerSetMeshAppearance_NodeTypeParams>;
}

public native struct questEntityManagerSetMeshAppearance_NodeTypeParams {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let componentName: CName;
  native let appearanceName: CName;
}

public native class questEntityManagerSetStat_NodeType extends questIEntityManager_NodeType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let statType: gamedataStatType;
  native let value: Float;
  native let setExactValue: Bool;
}

public native class questEntityManagerToggleComponent_NodeType extends questIEntityManager_NodeType {
  native let params: array<questEntityManagerToggleComponent_NodeTypeParams>;
}

public native struct questEntityManagerToggleComponent_NodeTypeParams {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let componentName: CName;
  native let enable: Bool;
}

public native class questEntityManagerToggleMirrorsArea_NodeType extends questIEntityManager_NodeType {
  native let objectRef: EntityReference;
  native let isInMirrorsArea: Bool;
}

public native class questEntryScanned_ConditionType extends questIObjectConditionType {
  native let objectRef: EntityReference;
  native let entryID: TweakDBID;
}

public native class questEnvironmentManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIEnvironmentManagerNodeType>;
}

public native class questEquipItemNodeDefinition extends questAICommandNodeBase {
  native let entityReference: ref<questObservableUniversalRef>;
  native let params: ref<questEquipItemParams>;
}

public native class questEquipItemParams extends AICommandParams {
  native let slotId: TweakDBID;
  native let type: questNodeType;
  native let itemId: TweakDBID;
  native let equipDurationOverride: Float;
  native let unequipDurationOverride: Float;
  native let failIfItemNotFound: Bool;
  native let instant: Bool;
  native let equipLastWeapon: Bool;
  native let forceFirstEquip: Bool;
  native let ignoreStateMachine: Bool;
  native let isPlayer: Bool;
  native let equipTypes: gameItemEquipContexts;
  native let unequipTypes: gameItemUnequipContexts;
  native let byItem: Bool;
}

enum questESwitchBehaviourType {
  First_Fulfilled = 0,
  All_Fulfilled = 1,
}

enum questETimeDilationOverride {
  None = 0,
  Ignore = 1,
  Inherit = 2,
}

enum questETimeShiftType {
  ShiftByTime = 0,
  ShiftToHour = 1,
}

enum questEUIMenuState {
  Open = 0,
  Closed = 1,
}

enum questEUseWeapon_MissileOffsetsSource {
  None = 0,
  Predefined_Narrow = 1,
  Predefined_Wide = 2,
  TweakDB = 3,
  List = 4,
}

public native class questEventManagerNodeDefinition extends questDisableableNodeDefinition {
  native let isUiEvent: Bool;
  native let isObjectPlayer: Bool;
  native let objectRef: EntityReference;
  native let managerName: String;
  native let event: ref<IScriptable>;
  native let PSClassName: CName;
  native let componentName: CName;
}

enum questExitType {
  Terminating = 0,
  NonTerminating = 1,
}

public native class questFactsDBCondition extends questTypedCondition {
  native let type: ref<questIFactsDBConditionType>;
}

public native class questFactsDBManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIFactsDBManagerNodeType>;
}

public native class questFinalBoardsEnableSkipCredits_NodeType extends questIUIManagerNodeType {
  native let enableSkipping: Bool;
}

public native class questFinalBoardsLoadPonRSave_NodeType extends questIUIManagerNodeType {
  native let loadPointOfNoReturnSave: Bool;
}

public native class questFinalBoardsOpenSpeakerScreen_NodeType extends questIUIManagerNodeType {
  native let openSpeakerScreen: Bool;
  native let speakerName: String;
}

public native class questFinalBoardsVideosFinished_NodeType extends questIUIManagerNodeType {}

public native class questFlowControlNodeDefinition extends questDisableableNodeDefinition {
  native let isOpen: Bool;
  native let opensAt: Uint16;
  native let closesAt: Uint16;
}

public native class questFlushAutopilot_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let playerVehicle: Bool;
}

public native class questFollowObject_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let followObjectRef: EntityReference;
  native let offset: Vector3;
  native let positionLerpSpeed: Float;
  native let rotationLerpSpeed: Float;
}

public native class questFollowParams extends AICommandParams {
  native let companionRef: ref<questUniversalRef>;
  native let companionDistance: Float;
  native let destinationPointTolerance: Float;
  native let stopWhenDestinationReached: Bool;
  native let movementType: moveMovementType;
  native let matchSpeed: Bool;
  native let useTeleport: Bool;
  native let repeatCommandOnInterrupt: Bool;
}

public native class questForbiddenTrigger_NodeType extends questIVehicleManagerNodeType {
  native let triggerNodeRef: NodeRef;
  native let activate: Bool;
  native let dismount: Bool;
  native let blockCombat: Bool;
}

public native class questForcedBehaviorReference extends AIResourceReference {}

public native class questForcedBehaviourNodeDefinition extends questSignalStoppingNodeDefinition {
  native let puppet: EntityReference;
  native let tree: ref<questForcedBehaviorReference>;
  native let behavior: ref<AIbehaviorParameterizedBehavior>;
}

public native class questForceModule_NodeType extends questIVisionModeNodeType {
  native let params: array<questForceVMModule_NodeTypeParams>;
}

public native struct questForceModule_NodeTypeParams {
  native let objectRef: NodeRef;
  native let module: String;
  native let components: array<CName>;
}

public native class questForcePhysicsWakeUp_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
}

public native class questForceTokenActivation_NodeSubType extends questIContentTokenManager_NodeSubType {
  native let forceCreatingToken: Bool;
}

public native struct questForceVMModule_NodeTypeParams {
  native let reference: EntityReference;
  native let module: String;
  native let components: array<CName>;
}

public native class questFormConvoy_NodeType extends questIVehicleManagerNodeType {
  native let leaderRef: EntityReference;
  native let formationType: vehicleFormationType;
}

public abstract native struct questFulfillInfo {}

public native class questFXManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIFXManagerNodeType>;
}

public native class questGameManagerNodeDefinition extends questTypedSignalStoppingNodeDefinition {
  native let type: ref<questIGameManagerNodeType>;
}

enum questGameplayRestrictionAction {
  AddRestriction = 0,
  RemoveRestriction = 1,
  RemoveAllRestrictions = 2,
}

public native class questGameplayRestrictions_NodeType extends questIGameManagerNonSignalStoppingNodeType {
  native let action: questGameplayRestrictionAction;
  native let source: CName;
  native let restrictionIDs: array<TweakDBID>;
}

public native class questGameTimeDelay_ConditionType extends questITimeConditionType {
  native let days: Uint32;
  native let hours: Uint32;
  native let minutes: Uint32;
  native let seconds: Uint32;
}

public native class questGatherTriggerCondition extends questTriggerCondition {}

public native class questGatherTriggerNotifier_Quest extends worldITriggerAreaNotifer {}

public native class questGatherTriggerNotifier_QuestInstance extends questTriggerNotifier_QuestInstance {}

public native class questGiveReward_NodeType extends questIRewardManagerNodeType {
  native let rewards: array<TweakDBID>;
}

public native class questGlitchLoadingScreen_NodeType extends questIUIManagerNodeType {}

public native class questGlobalTvScheduler_NodeType extends questIUIManagerNodeType {
  native let channelId: TweakDBID;
  native let overlayResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let videoResource: ResourceAsyncRef; // raRef<Bink>
  native let VOScene: ResourceAsyncRef; // raRef<scnSceneResource>
  native let audioEvent: CName;
  native let newsTitleTweak: TweakDBID;
  native let randomNewsFeedPack: TweakDBID;
}

public native class questGoBackToRace_NodeType extends questIVehicleManagerNodeType {}

public native class questGOGReward_ConditionType extends questISystemConditionType {
  native let rewardRecordId: TweakDBID;
}

public native class questGraphDefinition extends graphGraphDefinition {}

public abstract native class questHackingManager_ActionType extends ISerializable {}

public native class questHackingManager_NodeType extends questIInteractiveObjectManagerNodeType {
  native let params: array<questHackingManager_NodeTypeParams>;
}

public native struct questHackingManager_NodeTypeParams {
  native let objectRef: NodeRef;
  native let actions: array<ref<questHackingManager_ActionType>>;
}

public native class questHackingManager_SetEnabled extends questHackingManager_ActionType {
  native let enabled: Bool;
}

public native class questHackingManager_SetHacked extends questHackingManager_ActionType {
  native let hacked: Bool;
}

public abstract native class questHolocallStateListener extends worldIQuestPrefabStateListener {}

public native struct questHUDEntryAnimationEvent {
  native let hudEntry: CName;
  native let animationName: CName;
  native let dependsOnTimeDilation: Bool;
}

public native struct questHUDEntryAnimationFinished {
  native let hudEntry: CName;
  native let animationName: CName;
  native let finished: Bool;
}

public native struct questHUDEntryVisibilityData {
  native let hudEntryName: CName;
  native let visibility: worlduiEntryVisibility;
}

public native class questHUDEntryVisibilityEvent extends Event {
  native let dataEntries: array<questHUDEntryVisibilityData>;
}

public native class questHUDVideo_NodeType extends questIUIManagerNodeType {
  native let video: ResourceAsyncRef; // raRef<Bink>
  native let skippable: Bool;
  native let audioEvent: CName;
  native let syncToAudio: Bool;
  native let retriggerAudioOnLoop: Bool;
  native let looped: Bool;
  native let forceVideoFrameRate: Bool;
  native let playOnHud: Bool;
  native let fullScreen: Bool;
  native let useFullscreenVideoState: Bool;
  native let keepWidescreenAspectRatio: Bool;
  native let position: Vector2;
  native let size: Vector2;
}

public abstract native class questIAchievementManagerNodeType extends ISerializable {}

public abstract native class questIAudioCharacterManager_NodeSubType extends questINodeType {
  native let characterEntries: array<questIAudioCharacterManager_NodeSubTypeCharacterEntry>;
}

public native struct questIAudioCharacterManager_NodeSubTypeCharacterEntry {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let enableSubSystem: Bool;
}

public abstract native class questIAudioCharacterManager_NodeType extends questINodeType {}

public abstract native class questIAudioNodeType extends ISerializable {}

public abstract native class questIBaseCondition extends graphIGraphNodeCondition {}

public abstract native class questIBaseNodeType extends ISerializable {}

public abstract native class questIBehaviourManager_NodeType extends questIRetNodeType {
  native let puppetRef: EntityReference;
}

public abstract native class questICharacterConditionSubType extends ISerializable {}

public abstract native class questICharacterConditionType extends questIConditionType {}

public abstract native class questICharacterManager_NodeSubType extends questPuppetNodeType {}

public abstract native class questICharacterManager_NodeType extends questIRetNodeType {}

public abstract native class questICharacterManagerCombat_NodeSubType extends questICharacterManager_NodeSubType {}

public abstract native class questICharacterManagerParameters_NodeSubType extends questICharacterManager_NodeSubType {}

public abstract native class questICharacterManagerVisuals_NodeSubType extends questICharacterManager_NodeSubType {}

public abstract native class questIConditionType extends ISerializable {}

public abstract native class questIContentConditionType extends questIConditionType {}

public abstract native class questIContentTokenManager_NodeSubType extends ISerializable {}

public abstract native class questICrowdManager_NodeType extends questINodeType {}

public abstract native class questIDistance extends ISerializable {}

public abstract native class questIDistanceConditionType extends questIConditionType {}

public abstract native class questIDynamicSpawnSystemConditionType extends questIConditionType {}

public abstract native class questIDynamicSpawnSystemType extends ISerializable {}

public abstract native class questIEntityConditionType extends questIConditionType {}

public abstract native class questIEntityManager_NodeSubType extends questObjectNodeType {}

public abstract native class questIEntityManager_NodeType extends questINodeType {}

public abstract native class questIEntityManagerSetAttachment_NodeSubType extends questIEntityManager_NodeSubType {}

public abstract native class questIEntityManagerSetDestructionState_NodeSubType extends questIEntityManager_NodeSubType {}

public abstract native class questIEnvironmentManagerNodeType extends questObjectNodeType {}

public abstract native class questIFactsDBConditionType extends questIConditionType {}

public abstract native class questIFactsDBManagerNodeType extends ISerializable {}

public abstract native class questIFXManagerNodeType extends questObjectNodeType {}

public abstract native class questIGameManagerNodeType extends questISignalStoppingNodeType {}

public abstract native class questIGameManagerNonSignalStoppingNodeType extends questIGameManagerNodeType {}

public abstract native class questIInt32ValueProvider extends ISerializable {}

public abstract native class questIInteractiveObjectManagerNodeType extends questObjectNodeType {}

public abstract native class questIItemManagerNodeType extends questObjectNodeType {}

public abstract native class questIJournal_NodeType extends questIRetNodeType {}

public abstract native class questIJournalConditionType extends questIConditionType {}

enum questImpulseMagnitude {
  Any = 0,
  Low = 1,
  Medium = 2,
  High = 3,
}

public abstract native class questIMultiplayerHeistNodeType extends questINodeType {}

public native class questInjectLoot_NodeType extends questIItemManagerNodeType {
  native let params: array<ref<questInjectLoot_NodeTypeParams>>;
}

public native class questInjectLoot_NodeTypeParams_OperationData extends ISerializable {
  native let operationType: questInjectLootOperationType;
  native let itemTDBID: TweakDBID;
  native let quantity: Int32;
}

public native class questInjectLoot_NodeTypeParams extends ISerializable {
  native let objectRef: ref<questUniversalRef>;
  native let lootOperations: array<ref<questInjectLoot_NodeTypeParams_OperationData>>;
}

enum questInjectLootOperationType {
  Inject = 0,
  Remove = 1,
  RemoveAll = 2,
}

public abstract native class questINodeType extends questIBaseNodeType {}

public native class questInputAction_ConditionType extends questISystemConditionType {
  native let anyInputAction: Bool;
  native let inputAction: CName;
  native let checkIfButtonAlreadyPressed: Bool;
  native let axisAction: Bool;
  native let valueLessThan: Float;
  native let valueMoreThan: Float;
}

public native class questInputController_ConditionType extends questISystemConditionType {
  native let inputController: questInputDevice;
}

enum questInputDevice {
  Undefined = 0,
  KeyboardMouse = 1,
  XBoxGamepad = 2,
  PS4Gamepad = 3,
  StadiaGamepad = 4,
  NintendoGamepad = 5,
}

public native class questInputHint_NodeType extends questIUIManagerNodeType {
  native let show: Bool;
  native let action: CName;
  native let groupId: CName;
  native let source: CName;
  native let localizedLabel: String;
  native let queuePriority: Int32;
}

public native class questInputHintGroup_NodeType extends questIUIManagerNodeType {
  native let show: Bool;
  native let iconID: TweakDBID;
  native let groupId: CName;
  native let localizedTitle: String;
  native let localizedDescription: String;
}

public native class questInputNodeDefinition extends questIONodeDefinition {}

public native class questInputScheme_ConditionType extends questISystemConditionType {
  native let scheme: questInputScheme;
}

enum questInputScheme {
  Legacy = 0,
  Agile = 1,
  Alternative = 2,
}

public native class questInspect_ConditionType extends questIObjectConditionType {
  native let objectID: String;
  native let inverted: Bool;
}

public native class questInstancedCrowdControlNodeDefinition extends questDisableableNodeDefinition {
  native let crowdVariantTag: CName;
  native let enable: Bool;
}

public native class questInt32FactDBProvider extends questIInt32ValueProvider {
  native let factName: CName;
}

public native class questInt32FixedValueProvider extends questIInt32ValueProvider {
  native let value: Int32;
}

public native struct questInt32ValueWrapper {
  native let valueProvider: ref<questIInt32ValueProvider>;
}

public native class questInteraction_ConditionType extends questIObjectConditionType {
  native let objectRef: NodeRef;
  native let eventType: questObjectInteractionEventType;
}

public native class questInteractiveObjectManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIInteractiveObjectManagerNodeType>;
}

public native class questInventory_ConditionType extends questIObjectConditionType {
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let itemID: TweakDBID;
  native let itemTag: CName;
  native let quantity: Uint32;
  native let comparisonType: EComparisonType;
}

public abstract native class questIObjectConditionType extends questIConditionType {}

public abstract native class questIONodeDefinition extends questDisableableNodeDefinition {
  native let socketName: CName;
}

public native class questIPayment_ConditionType extends questIConditionType {
  native let scriptCondition: ref<IScriptable>;
}

public abstract native class questIPhoneConditionType extends questIUIConditionType {
  native let inverted: Bool;
}

public abstract native class questIPhoneManagerNodeType extends questIRetOutputNodeType {}

public abstract native class questIQuestsHelper extends IGameSystem {}

public abstract native class questIRecordingNodeType extends questINodeType {}

public abstract native class questIRenderFxManagerNodeType extends questINodeType {}

public abstract native class questIRetNodeType extends questIBaseNodeType {}

public abstract native class questIRetOutputNodeType extends questIBaseNodeType {}

public abstract native class questIRewardManagerNodeType extends ISerializable {}

public native class questIsAnyAlive_ConditionType extends questIDynamicSpawnSystemConditionType {
  native let waveTag: CName;
  native let inverted: Bool;
}

public abstract native class questISceneConditionType extends questIConditionType {}

public abstract native class questISceneManagerNodeType extends questIRetNodeType {}

public abstract native class questISensesConditionType extends questIConditionType {}

public abstract native class questISignalStoppingNodeType extends questIRetNodeType {}

public native struct questIsInMirrorsAreaMapArrayElement {
  native let objectRef: NodeRef;
  native let isInMirrorsArea: Bool;
}

public abstract native class questISpawnerConditionType extends questIConditionType {}

public abstract native class questIStatsConditionType extends questIConditionType {
  native let entityRef: ref<questUniversalRef>;
}

public abstract native class questIStatsScriptConditionType extends questIStatsConditionType {
  native let scriptCondition: ref<IScriptable>;
}

public abstract native class questISystemConditionType extends questIConditionType {}

public native class questItemManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIItemManagerNodeType>;
}

public abstract native class questITimeConditionType extends questIConditionType {}

public abstract native class questITimeManagerNodeType extends questObjectNodeType {}

public abstract native class questITriggerManagerNodeType extends questObjectNodeType {}

public abstract native class questITutorial_NodeSubType extends questIRetNodeType {}

public abstract native class questIUIConditionType extends questIConditionType {}

public abstract native class questIUIManagerNodeType extends questIRetNodeType {}

public abstract native class questIVehicleConditionType extends questIConditionType {}

public abstract native class questIVehicleManagerNodeType extends questIRetNodeType {}

public abstract native class questIVehicleMoveOnSpline_Overrides extends ISerializable {}

public abstract native class questIVisionModeNodeType extends questObjectNodeType {}

public abstract native class questIVoicesetManager_NodeType extends questObjectNodeType {}

public abstract native class questIWorldDataManagerNodeType extends questIRetNodeType {}

public abstract native class questIWorldStateSystem extends IGameSystem {}

public native class questJoinCrowdParams extends AICommandParams {
  native let repeatCommandOnInterrupt: Bool;
}

public native class questJoinTraffic_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
}

public native class questJournalBulkUpdate_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let requiredEntryType: CName;
  native let requiredEntryState: CName;
  native let newEntryState: CName;
  native let sendNotification: Bool;
  native let propagateChange: Bool;
}

public native class questJournalChangeMappinPhase_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let phase: gamedataMappinPhase;
  native let notifyUI: Bool;
}

public native class questJournalCondition extends questTypedCondition {
  native let type: ref<questIJournalConditionType>;
}

public native class questJournalContact_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
}

public native class questJournalEntry_ConditionType extends questIJournalConditionType {
  native let path: ref<gameJournalPath>;
  native let state: gameJournalEntryUserState;
}

public native class questJournalEntry_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let sendNotification: Bool;
}

public native class questJournalEntryState_ConditionType extends questIJournalConditionType {
  native let path: ref<gameJournalPath>;
  native let state: gameJournalEntryState;
  native let inverted: Bool;
}

public native class questJournalEntryVisited_ConditionType extends questIJournalConditionType {
  native let path: ref<gameJournalPath>;
  native let visited: Bool;
}

public native class questJournalNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questIJournal_NodeType>;
}

public native class questJournalNotification_ConditionType extends questIUIConditionType {
  native let journalPath: ref<gameJournalPath>;
}

public native class questJournalPushPopQuestObjective_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let restore: Bool;
}

public native class questJournalQuestEntry_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let sendNotification: Bool;
  native let trackQuest: Bool;
  native let optional: Bool;
  native let version: questJournalQuestEntry_NodeTypeNodeVersion;
}

enum questJournalQuestEntry_NodeTypeNodeVersion {
  Initial = 0,
  OptionalProperty = 1,
}

public native class questJournalQuestObjectiveCounter_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
}

public native class questJournalQuestSetObjectiveOptional_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let optional: Bool;
}

public native class questJournalSetLockQuestObjective_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
  native let lock: Bool;
}

public native class questJournalTrackQuest_NodeType extends questIJournal_NodeType {
  native let path: ref<gameJournalPath>;
}

public native class questJumpWorkspotAnim_NodeType extends questIBehaviourManager_NodeType {
  native let allowCurrAnimToFinish: Bool;
  native let entryIdToJumpTo: Int32;
}

public native class questLanguage_ConditionType extends questISystemConditionType {
  native let mode: questLanguageMode;
  native let languageCode: String;
  native let inverted: Bool;
}

enum questLanguageMode {
  Undefined = 0,
  VoLang = 1,
  SubsLang = 2,
  TextLang = 3,
}

public native class questLegacy_NodeType extends questSpawnManagerNodeType {
  native let spawnerReference: NodeRef;
  native let communityEntryName: CName;
  native let communityEntryPhaseName: CName;
}

public native class questLifePath_ConditionType extends questIStatsScriptConditionType {}

enum questLocationAction {
  Entered = 0,
  Exited = 1,
}

public native class questLogicalAndNodeDefinition extends questLogicalBaseNodeDefinition {}

public abstract native class questLogicalBaseNodeDefinition extends questSignalStoppingNodeDefinition {
  native let inputSocketCount: Uint32;
  native let outputSocketCount: Uint32;
}

public native class questLogicalCondition extends questCondition {
  native let operation: questLogicalOperation;
  native let conditions: array<ref<questIBaseCondition>>;
}

public native class questLogicalHubNodeDefinition extends questLogicalBaseNodeDefinition {}

enum questLogicalOperation {
  AND = 0,
  OR = 1,
  XOR = 2,
  NAND = 3,
  NOR = 4,
  NXOR = 5,
}

public native class questLogicalXorNodeDefinition extends questLogicalBaseNodeDefinition {}

enum questLookAtAction {
  Nothing = 0,
  Reset = 1,
  Set = 2,
}

enum questLookAtDrivenTurnsMode {
  Start = 0,
  Pause = 1,
  Resume = 2,
  Stop = 3,
  ForceStop = 4,
}

public native class questLookAtDrivenTurnsNode extends questSignalStoppingNodeDefinition {
  native let mode: questLookAtDrivenTurnsMode;
  native let puppetRef: EntityReference;
  native let targetRef: EntityReference;
  native let canLookAtDrivenTurnsInterruptGesture: Bool;
}

public native class questLootPurge_NodeType extends questIGameManagerNonSignalStoppingNodeType {}

public native class questLootTokenManager_NodeType extends questIItemManagerNodeType {
  native let params: array<questLootTokenManager_NodeTypeParams>;
}

public native struct questLootTokenManager_NodeTypeParams {
  native let tokenNodeRef: NodeRef;
  native let lootTokenState: questLootTokenState;
}

enum questLootTokenState {
  Enabled = 0,
  Disabled = 1,
  Sealed = 2,
  Unsealed = 3,
}

public native class questManageCollision_NodeType extends questIWorldDataManagerNodeType {
  native let params: array<questManageCollision_NodeTypeParams>;
}

public native struct questManageCollision_NodeTypeParams {
  native persistent let objectRef: NodeRef;
  native persistent let enableCollision: Bool;
  native persistent let enableQueries: Bool;
  native persistent let components: array<CName>;
}

public native class questMappinGPSComparison_ConditionType extends questIDistanceConditionType {
  native let distanceDefinition1: ref<questMappinGPSDistance>;
  native let distanceDefinition2: ref<questValueDistance>;
  native let comparisonType: EComparisonType;
}

public native class questMappinGPSDistance extends questIDistance {
  native let mappinPath: ref<gameJournalPath>;
}

public native class questMappinManagerNodeDefinition extends questDisableableNodeDefinition {
  native let path: ref<gameJournalPath>;
  native let disablePreviousMappins: Bool;
}

public native class questMappinState_ConditionType extends questIJournalConditionType {
  native let mappinPath: ref<gameJournalPath>;
  native let active: Bool;
}

public native class questMenuState_ConditionType extends questIUIConditionType {
  native let state: questEUIMenuState;
}

public native class questMinigameNodeDefinition extends questSignalStoppingNodeDefinition {
  native let start: Bool;
  native let skipSummaryScreen: Bool;
  native let networkRef: EntityReference;
}

public native class questMinigameSateListenerNodeDefinition extends questSignalStoppingNodeDefinition {}

public native class questMinimize_NodeType extends questIPhoneManagerNodeType {
  native let minimize: Bool;
}

public native class questMiscAICommandNode extends questConfigurableAICommandNode {
  native let entityReference: EntityReference;
  native let function: CName;
  native let params: ref<AICommandParams>;
}

enum questMountConditionType {
  OnMount = 0,
  OnUnmount = 1,
}

public native class questMountedObjectInfo extends ISerializable {
  native let isFirst: Bool;
  native let isPlayer: Bool;
  native let ref: EntityReference;
  native let onMount: Bool;
  native let role: gameMountingSlotRole;
}

enum questMountVehicleOrigin {
  Any = 0,
  NotStolen = 1,
  Stolen = 2,
}

enum questMountVehicleType {
  Any = 0,
  Car = 1,
  Motorcycle = 2,
}

public native class questMoveOnSpline_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let splineRef: NodeRef;
  native let startFrom: Float;
  native let blendType: vehiclePlayerToAIInterpolationType;
  native let blendTime: Float;
  native let reverseGear: Bool;
  native let arriveWithPivot: Bool;
  native let trafficDeletionMode: vehicleAIPathTrafficDeletionMode;
  native let sceneBlendInDistance: Float;
  native let sceneBlendOutDistance: Float;
  native let overrides: ref<questIVehicleMoveOnSpline_Overrides>;
  native let audioCurves: ResourceRef; // rRef<vehicleAudioVehicleCurveSet>
}

public native class questMoveOnSplineAdditionalParams extends ISerializable {
  native let type: questMoveOnSplineType;
  native let simpleParams: questSimpleMoveOnSplineParams;
  native let animParams: questAnimMoveOnSplineParams;
  native let withCompanionParams: questWithCompanionMoveOnSplineParams;
}

public native class questMoveOnSplineAndKeepDistance_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let keepDistanceFromRef: EntityReference;
  native let splineRef: NodeRef;
  native let distance: Float;
  native let blendTime: Float;
  native let minSpeed: Float;
  native let reduceSpeedOnTurns: Bool;
}

public native class questMoveOnSplineControlRubberbanding_NodeType extends questIVehicleManagerNodeType {
  native let enable: Bool;
  native let vehicleRef: EntityReference;
  native let keepDistanceFromRef: EntityReference;
  native let distance: Float;
  native let minSpeed: Float;
  native let reduceSpeedOnTurns: Bool;
}

public native class questMoveOnSplineParams extends AICommandParams {
  native let splineNodeRef: NodeRef;
  native let useStart: Bool;
  native let useStop: Bool;
  native let reverse: Bool;
  native let startFromClosestPoint: Bool;
  native let splineRecalculation: Bool;
  native let additionalParams: ref<questMoveOnSplineAdditionalParams>;
  native let useAlertedState: Bool;
  native let useCombatState: Bool;
  native let executeWhileDespawned: Bool;
  native let repeatCommandOnInterrupt: Bool;
  native let noWaitToEndDistance: Float;
  native let noWaitToEndCompanionDistance: Float;
  native let removeAfterCombat: Bool;
  native let ignoreInCombat: Bool;
  native let alwaysUseStealth: Bool;
  native let disableFootIK: Bool;
}

enum questMoveOnSplineType {
  Simple = 0,
  Anim = 1,
  WithCompanion = 2,
}

public native class questMovePuppetNodeDefinition extends questConfigurableAICommandNode {
  native let entityReference: EntityReference;
  native let moveType: CName;
  native let nodeParams: ref<AICommandParams>;
}

public native class questMovePuppetNodeParams extends AICommandParams {
  native let moveType: questMoveType;
  native let moveOnSplineParams: ref<questMoveOnSplineParams>;
  native let moveToParams: ref<questMoveToParams>;
  native let otherParams: ref<AICommandParams>;
  native let repeatCommandOnInterrupt: Bool;
}

public native class questMoveToParams extends AICommandParams {
  native let movementTargetRef: ref<questUniversalRef>;
  native let facingTargetRef: ref<questUniversalRef>;
  native let rotateEntityTowardsFacingTarget: Bool;
  native let movementType: moveMovementType;
  native let ignoreNavigation: Bool;
  native let useStart: Bool;
  native let useStop: Bool;
  native let desiredDistanceFromTarget: Float;
  native let finishWhenDestinationReached: Bool;
  native let repeatCommandOnInterrupt: Bool;
  native let executeWhileDespawned: Bool;
  native let removeAfterCombat: Bool;
  native let ignoreInCombat: Bool;
  native let alwaysUseStealth: Bool;
}

enum questMoveType {
  MoveOnSpline = 0,
  MoveTo = 1,
  RotateTo = 2,
  Patrol = 3,
  Follow = 4,
  JoinCrowd = 5,
}

enum questMultiplayerAIDirectorFunction {
  SetStatus = 0,
  SetCurrentPath = 1,
  OverrideScheduleEntry = 2,
  SetCurrentShedule = 3,
}

public native class questMultiplayerAIDirectorNodeDefinition extends questSignalStoppingNodeDefinition {
  native let params: ref<questMultiplayerAIDirectorParams>;
}

public native class questMultiplayerAIDirectorParams extends ISerializable {
  native let function: questMultiplayerAIDirectorFunction;
  native let status: questMultiplayerAIDirectorStatus;
  native let pathRef: NodeRef;
  native let scheduleEntryName: String;
  native let scheduleName: String;
}

enum questMultiplayerAIDirectorStatus {
  Enabled = 0,
  Disabled = 1,
}

public native class questMultiplayerChoiceTokenNodeDefinition extends questSignalStoppingNodeDefinition {
  native let params: questMultiplayerChoiceTokenParams;
}

public native struct questMultiplayerChoiceTokenParams {
  native let timeout: Uint32;
  native let compatibleDeviceName: CName;
}

public native class questMultiplayerHeistNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIMultiplayerHeistNodeType>;
}

enum questMultiplayerHeistState {
  Invalid = 0,
  Failure = 1,
  Victory = 2,
}

public native class questMultiplayerJunctionDialogNodeDefinition extends questDisableableNodeDefinition {}

public native class questMultiplayerTeleportPuppetNodeDefinition extends questSignalStoppingNodeDefinition {
  native let params: questMultiplayerTeleportPuppetParams;
}

public native struct questMultiplayerTeleportPuppetParams {
  native let teleportAllPlayers: Bool;
  native let spawnPointTag: CName;
  native let destinationRef: EntityReference;
  native let destinationOffset: Vector3;
  native let areaNodeTriggerRef: EntityReference;
}

public native class questNewPlayerPuppetAttached_ConditionType extends questISceneConditionType {}

public native struct questNodeCollisionMapArrayElement {
  native let objectRef: NodeRef;
  native let componentsCollisionMapArray: array<questComponentCollisionMapArrayElement>;
}

public abstract native class questNodeDefinition extends graphGraphNodeDefinition {
  native let id: Uint16;
}

public native class questNodeLoadingCondition extends questCondition {
  native let objectRef: NodeRef;
  native let inverted: Bool;
}

enum questNodeType {
  Equip = 0,
  Unequip = 1,
}

public native struct questNodeVisibilityMapArrayElement {
  native let globalNodeRef: GlobalNodeRef;
  native let visible: Bool;
}

public native class questNPCLookAt_NodeType extends questISceneManagerNodeType {
  native let puppetRef: EntityReference;
  native let lookAtTargetRef: EntityReference;
  native let assignLookAt: Bool;
  native let refPlayer: Bool;
}

public native class questObjectCondition extends questTypedCondition {
  native let type: ref<questIObjectConditionType>;
}

public native class questObjectDistance extends questIDistance {
  native let entityRef: ref<questUniversalRef>;
  native let nodeRef2: EntityReference;
}

enum questObjectInteractionEventType {
  Undefined = 0,
  Entered = 1,
  Exited = 2,
  Executed = 3,
}

public native class questObjectInventoryListener extends InventoryListener {}

public native class questObjectItemListener extends InventoryListener {}

public abstract native class questObjectNodeType extends questINodeType {}

enum questObjectScanEventType {
  Undefined = 0,
  Started = 1,
  Finished = 2,
}

public native class questObservableUniversalRef extends questUniversalRef {}

public native class questOpenBriefing_NodeType extends questIUIManagerNodeType {
  native let briefingPath: ref<gameJournalPath>;
}

public native class questOpenMessage_NodeType extends questIPhoneManagerNodeType {
  native let msg: ref<gameJournalPath>;
}

public native class questOpenPhotoMode_NodeType extends questIUIManagerNodeType {
  native let factName: String;
  native let forceFppMode: Bool;
  native let alwaysAllowTPP: Bool;
  native let lockExitUntilScreenshot: Bool;
}

public native class questOutputNodeDefinition extends questIONodeDefinition {
  native let type: questExitType;
}

public native class questOverrideLoadingScreen_NodeType extends questIUIManagerNodeType {
  native let video: ResourceAsyncRef; // raRef<Bink>
  native let videos: array<ResourceAsyncRef>;
  native let minimumPlayCount: Uint32;
  native let forceVideoFrameRate: Bool;
  native let tooltips: array<String>;
  native let tooltipDuration: Float;
  native let glitchEffectTime: Float;
  native let keepLoadingScreenWhileVideoIsPlaying: Bool;
}

public native class questOverrideSplineSpeed_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let speed: Float;
  native let adjustTime: Float;
}

public native class questParamKeepDistance extends ISerializable {
  native let companionTargetRef: ref<questUniversalRef>;
  native let distance: Float;
}

public native class questParamRubberbanding extends ISerializable {
  native let targetRef: ref<questUniversalRef>;
  native let targetForwardOffset: Float;
  native let minDistance: Float;
  native let maxDistance: Float;
  native let stopAndWait: Bool;
  native let teleportToCatchUp: Bool;
  native let stayInFront: Bool;
}

public native class questPatrolParams extends AICommandParams {
  native let pathParams: ref<AIPatrolPathParameters>;
  native let repeatCommandOnInterrupt: Bool;
}

public native class questPauseConditionNodeDefinition extends questSignalStoppingNodeDefinition {
  native let condition: ref<questIBaseCondition>;
}

public native class questPauseTime_NodeType extends questITimeManagerNodeType {
  native let pause: Bool;
  native let source: CName;
}

public native class questPaymentBalanced_ConditionType extends questIPayment_ConditionType {}

public native class questPaymentCondition extends questTypedCondition {
  native let type: ref<questIPayment_ConditionType>;
}

public native class questPaymentFixedAmount_ConditionType extends questIPayment_ConditionType {}

public native class questPhaseFreezingAreaNotifier extends worldITriggerAreaNotifer {}

public native class questPhaseFreezingAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class questPhaseInstance extends ISerializable {}

public native class questPhaseNodeDefinition extends questEmbeddedGraphNodeDefinition {
  native let saveLock: Bool;
  native let phaseResource: ResourceAsyncRef; // raRef<questQuestPhaseResource>
  native let unfreezingTriggerNodeRef: NodeRef;
  native let phaseInstancePrefabs: array<questQuestPrefabEntry>;
  native let phaseGraph: ref<questGraphDefinition>;
}

enum questPhaseNodeType {
  Quest = 0,
  OpenWorld = 1,
  Combat = 2,
  Audio = 3,
}

public native class questPhone_ConditionType extends questISystemConditionType {
  native let caller: ref<gameJournalPath>;
  native let addressee: ref<gameJournalPath>;
  native let callPhase: questPhoneCallPhase;
}

public native class questPhoneCallMode_ConditionType extends questIPhoneConditionType {
  native let callMode: questPhoneCallMode;
}

public native class questPhoneCallPhase_ConditionType extends questIPhoneConditionType {
  native let callPhase: questPhoneCallPhase;
}

public native class questPhoneManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questIPhoneManagerNodeType>;
}

public native class questPhoneMuted_ConditionType extends questISystemConditionType {
  native let groupName: CName;
  native let inverted: Bool;
}

public native class questPhonePickUp_ConditionType extends questISystemConditionType {
  native let caller: ref<gameJournalPath>;
  native let addressee: ref<gameJournalPath>;
  native let releaseOnRejection: Bool;
}

public native class questPhonePrefabsListener extends worldIQuestPrefabStateListener {}

public native class questPlaceholderNodeDefinition extends questDisableableNodeDefinition {
  native let replacedNodeClassName: CName;
  native let copiedSockets: array<questPlaceholderNodeSocketInfo>;
  native let clipboardHolder: ref<ISerializable>;
}

public native struct questPlaceholderNodeSocketInfo {
  native let name: CName;
  native let type: questSocketType;
}

public native class questPlatform_ConditionType extends questISystemConditionType {
  native let platform: questPlatform;
  native let inverted: Bool;
}

enum questPlatform {
  PC = 0,
  Console = 1,
  LastGenConsole = 2,
  CurrGenConsole = 3,
}

public native class questPlayEnv_ForceRelitEnvProbe extends questIEnvironmentManagerNodeType {}

public native class questPlayEnv_NodeType extends questIEnvironmentManagerNodeType {
  native let params: questPlayEnv_NodeTypeParams;
}

public native struct questPlayEnv_NodeTypeParams {
  native let enable: Bool;
  native let envParams: ResourceRef; // rRef<worldEnvironmentAreaParameters>
  native let blendTime: Float;
}

public native class questPlayEnv_OverrideGlobalLight extends questIEnvironmentManagerNodeType {
  native let params: worldWorldGlobalLightOverrideWithColorParameters;
}

public native class questPlayEnv_SetWeather extends questIEnvironmentManagerNodeType {
  native let reset: Bool;
  native let weatherID: TweakDBID;
  native let blendTime: Float;
  native let priority: Uint32;
  native let source: CName;
}

public native class questPlayerLookAt_NodeType extends questISceneManagerNodeType {
  native let useOffsetToPlayer: Bool;
  native let objectRef: EntityReference;
  native let slotName: CName;
  native let offsetPos: Vector3;
  native let duration: Float;
  native let adjustPitch: Bool;
  native let adjustYaw: Bool;
  native let endOnTargetReached: Bool;
  native let endOnCameraInputApplied: Bool;
  native let endOnTimeExceeded: Bool;
  native let cameraInputMagToBreak: Float;
  native let precision: Float;
  native let maxDuration: Float;
  native let easeIn: Bool;
  native let easeOut: Bool;
}

public native class questPlayerLookAtParams extends ISerializable {
  native let useOffsetToPlayer: Bool;
  native let lookAtTarget: EntityReference;
  native let slotName: CName;
  native let offset: Vector3;
  native let duration: Float;
  native let adjustPitch: Bool;
  native let adjustYaw: Bool;
  native let endOnTargetReached: Bool;
  native let endOnCameraInputApplied: Bool;
  native let endOnTimeExceeded: Bool;
  native let cameraInputMagToBreak: Float;
  native let precision: Float;
  native let maxDuration: Float;
  native let easeIn: Bool;
  native let easeOut: Bool;
}

public native class questPlayFX_NodeType extends questIFXManagerNodeType {
  native let params: array<questPlayFX_NodeTypeParams>;
}

public native struct questPlayFX_NodeTypeParams {
  native let play: Bool;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let effectName: CName;
  native let effectInstanceName: CName;
  native let sequenceShift: Uint32;
  native let save: Bool;
}

public native class questPlayHUDEntryAnimation_NodeType extends questIUIManagerNodeType {
  native let hudEntryName: CName;
  native let animationName: CName;
  native let dependsOnTimeDilation: Bool;
}

public native class questPlaylistTrackChanged_ConditionType extends questISystemConditionType {
  native let playlistName: CName;
}

public native class questPlaylistTrackNode extends questIAudioNodeType {
  native let playlistEvents: array<audioPlaylistTrackEventStruct>;
}

public native struct questPlayRazerAnimation_NodeTypeParams {
  native let animationName: CName;
  native let loop: Bool;
}

public native class questPlayVoiceset_NodeType extends questIVoicesetManager_NodeType {
  native let params: array<questPlayVoiceset_NodeTypeParams>;
}

public native struct questPlayVoiceset_NodeTypeParams {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let voicesetName: CName;
  native let useVoicesetSystem: Bool;
  native let playOnlyGrunt: Bool;
  native let overridingVoiceoverContext: locVoiceoverContext;
  native let overrideVoiceoverExpression: Bool;
  native let overridingVoiceoverExpression: locVoiceoverExpression;
  native let overrideVisualStyle: Bool;
  native let overridingVisualStyle: scnDialogLineVisualStyle;
}

public native class questPopulactionControllerNodeDefinition extends questBaseObjectNodeDefinition {
  native let enable: Bool;
}

public native class QuestPrefabStateListener extends worldIQuestPrefabStateListener {}

public native struct questPrefabVariantMapArrayElement {
  native let globalNodeRef: GlobalNodeRef;
  native let PrefabVariantsReplicatedInfos: array<questPrefabVariantReplicatedInfo>;
}

public native struct questPrefabVariantReplicatedInfo {
  native let variantNameKey: CName;
  native let show: Bool;
}

public native class questPrefetchStreaming_NodeTypeV2 extends questIWorldDataManagerNodeType {
  native let prefetchPositionRef: NodeRef;
  native let useStreamingOcclusion: Bool;
  native let maxDistance: Float;
  native let forceEnable: Bool;
}

public native class questPreloadFX_NodeType extends questIFXManagerNodeType {
  native let params: array<questPreloadFX_NodeTypeParams>;
}

public native struct questPreloadFX_NodeTypeParams {
  native let preload: Bool;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
  native let effectName: CName;
}

public native class questPrepareBlendCamera_NodeType extends questISceneManagerNodeType {}

public native class questPrereq_ConditionType extends questISystemConditionType {
  native let objectRef: EntityReference;
  native let isObjectPlayer: Bool;
  native let prereq: ref<IPrereq>;
}

public native class questProgressBar_NodeType extends questIUIManagerNodeType {
  native let show: Bool;
  native let duration: Float;
  native let text: LocalizationString;
  native let bottomText: LocalizationString;
  native let type: SimpleMessageType;
}

public native class questProximityProgressBar_ConditionType extends questIUIConditionType {
  native let action: ProximityProgressBarAction;
}

public native class questProximityProgressBar_NodeType extends questIUIManagerNodeType {
  native let show: Bool;
  native let duration: Float;
  native let reset: Bool;
  native let distance: Float;
  native let distanceComparisonType: EComparisonType;
  native let target: EntityReference;
  native let isPlayerActivator: Bool;
  native let activator: EntityReference;
  native let appearance: CName;
}

public native class questPuppetAIManagerNodeDefinition extends questDisableableNodeDefinition {
  native let entries: array<questPuppetAIManagerNodeDefinitionEntry>;
}

public native struct questPuppetAIManagerNodeDefinitionEntry {
  native let entityReference: EntityReference;
  native let aiTier: gameStoryTier;
}

public native class questPuppeteerNodeDefinition extends questDisableableNodeDefinition {
  native let effector: ref<questPuppetsEffector>;
  native let reference: EntityReference;
}

public abstract native class questPuppetNodeType extends questIRetNodeType {}

public abstract native class questPuppetsEffector extends ISerializable {}

public native class questPuppetsKill extends questPuppetsEffector {}

public native class questPuppetsUnconscious extends questPuppetsEffector {
  native let setUnconscious: Bool;
}

enum questQuestContentType {
  EP1_MainQuest = 0,
  EP1_SideQuest = 1,
  EP1_Minor = 2,
  Fixer = 3,
  MainQuest = 4,
  SideQuest_MainPath = 5,
  SideQuest_Romance = 6,
  SideQuest_Standalone = 7,
  MinorQuestAndSts = 8,
}

public native class questQuestPhaseResource extends graphGraphResource {
  native let phasePrefabs: array<questQuestPrefabEntry>;
  native let inplacePhases: array<ResourceRef>;
}

public native struct questQuestPrefabEntry {
  native let prefabNodeRef: NodeRef;
}

public native struct questQuestPrefabsEntry {
  native let nodeRef: GlobalNodeRef;
  native let loadingMode: worldQuestPrefabLoadingMode;
}

public native class questQuestPrefabsHandler extends worldIQuestPrefabStateListener {}

public native class questQuestResource extends questQuestPhaseResource {}

public native class questQuestsHelper extends questIQuestsHelper {}

public native class questQuestsSystemReplicatedState extends gameIGameSystemReplicatedState {
  native let replicatedQuestPrefabs: array<questQuestPrefabsEntry>;
}

public native class questQuestStatPoolListener extends IStatPoolsListener {}

public native class questQuickItemsManager_NodeType extends questIUIManagerNodeType {
  native let set: questQuickItemsSet;
}

enum questQuickItemsSet {
  Q001_Kereznikov_Heal_Phone = 0,
  Q003_All = 1,
}

public native class questRadio_ConditionType extends questISystemConditionType {
  native let inverted: Bool;
  native let limitToSpecifiedSpeakersStations: Bool;
  native let speakerType: audioRadioSpeakerType;
}

public native class questRadioAnnouncementNodeType extends questIAudioNodeType {
  native let radioStationEvents: array<questRadioStationAnnouncementEventStruct>;
}

public native class questRadioSongNodeType extends questIAudioNodeType {
  native let radioStationEvents: array<audioRadioStationSongEventStruct>;
}

public native struct questRadioStationAnnouncementEventStruct {
  native let announcementScene: ResourceAsyncRef; // raRef<scnSceneResource>
  native let sceneInput: CName;
  native let queueAnnouncement: Bool;
  native let radioStationName: CName;
  native let blockSignal: Bool;
  native let speaker: audioRadioSpeakerType;
}

public native class questRadioTrack_ConditionType extends questISystemConditionType {
  native let radioTrack: CName;
  native let inverted: Bool;
}

enum questRandomizerMode {
  Random = 0,
  IgnoreLastUsed = 1,
  IgnoreAllUsed = 2,
}

public native class questRandomizerNodeDefinition extends questDisableableNodeDefinition {
  native let mode: questRandomizerMode;
  native let outputWeights: array<Uint8>;
}

public native class questRazerAnimation_NodeType extends questIFXManagerNodeType {
  native let playParams: array<questPlayRazerAnimation_NodeTypeParams>;
  native let stopParams: array<questStopRazerAnimation_NodeTypeParams>;
  native let idleParams: array<questSetIdleRazerAnimation_NodeTypeParams>;
}

public native class questReactionPresetRecordSelector extends ISerializable {
  native let setDefault: Bool;
  native let isGanger: Bool;
  native let gangerRecordID: TweakDBID;
  native let isCivilian: Bool;
  native let civilianRecordID: TweakDBID;
  native let isCorpo: Bool;
  native let corpoRecordID: TweakDBID;
  native let isPolice: Bool;
  native let policeRecordID: TweakDBID;
  native let isMechanical: Bool;
  native let mechanicalRecordID: TweakDBID;
  native let isNoReaction: Bool;
  native let noReactionRecordID: TweakDBID;
}

public native class questRealtimeDelay_ConditionType extends questITimeConditionType {
  native let hours: Uint32;
  native let minutes: Uint32;
  native let seconds: Uint32;
  native let miliseconds: Uint32;
}

public native class questRecordingNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIRecordingNodeType>;
}

public native class questRecordSelector extends ISerializable {
  native let isCharacter: Bool;
  native let characterRecordID: TweakDBID;
  native let isDevice: Bool;
  native let deviceRecordID: TweakDBID;
  native let isItem: Bool;
  native let itemRecordID: TweakDBID;
}

public native class questReInitContainers_NodeType extends questIItemManagerNodeType {
  native let params: array<questReInitContainers_NodeTypeParams>;
}

public native struct questReInitContainers_NodeTypeParams {
  native let containerNodeRef: NodeRef;
  native let lootTables: array<TweakDBID>;
  native let useAreaLoot: Bool;
}

public native class questRemoveAllContacts_NodeType extends questIPhoneManagerNodeType {
  native let excludedContacts: array<ref<gameJournalPath>>;
}

public native class questRemoveToken_NodeSubType extends questIContentTokenManager_NodeSubType {
  native let removeAll: Bool;
}

public native class questRenderFxManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIRenderFxManagerNodeType>;
}

public native class questRenderPlane_NodeType extends questIRenderFxManagerNodeType {
  native let puppetRef: EntityReference;
  native let renderPlane: ERenderingPlane;
}

public native class questRepair_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let playerVehicle: Bool;
}

public native class questReplacer_NodeType extends questIGameManagerNonSignalStoppingNodeType {
  native let enable: Bool;
  native let objectRef: EntityReference;
  native let audioOverrideAppearanceName: CName;
}

public native class questRequestVehicleCameraPerspective_NodeType extends questIVehicleManagerNodeType {
  native let cameraPerspective: questVehicleCameraPerspective;
}

public native class questResetContainers_NodeType extends questIItemManagerNodeType {
  native let params: array<questResetContainers_NodeTypeParams>;
}

public native struct questResetContainers_NodeTypeParams {
  native let containerNodeRef: NodeRef;
  native let clearReinitData: Bool;
}

public native class questResetMovement_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
}

public native class questResetScanningAngleThreshold_NodeType extends questIVisionModeNodeType {}

public native class questRewardManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIRewardManagerNodeType>;
}

public native class questRewindableSectionTimeJump_NodeType extends questISceneManagerNodeType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let jumpTargetTime: Uint32;
  native let jumpSpeed: Float;
  native let postJumpPlayDirection: scnPlayDirection;
  native let postJumpPlaySpeed: scnPlaySpeed;
}

public native class questRootInstance extends questPhaseInstance {}

public native class questRotateToNodeDefinition extends questSignalStoppingNodeDefinition {
  native let entityReference: EntityReference;
  native let params: ref<questRotateToParams>;
}

public native class questRotateToParams extends AICommandParams {
  native let facingTargetRef: ref<questUniversalRef>;
  native let angleOffset: Float;
  native let speed: Float;
}

public native class questRumble_NodeType extends questIGameManagerNonSignalStoppingNodeType {
  native let rumbleEvent: CName;
  native let objectRef: EntityReference;
  native let isPlayer: Bool;
}

public native class questSaveLock_ConditionType extends questISystemConditionType {
  native let inverted: Bool;
}

public native class questScan_ConditionType extends questIObjectConditionType {
  native let objectRef: EntityReference;
  native let eventType: questObjectScanEventType;
}

enum questScanningState {
  NotScanned = 0,
  Scanned = 1,
}

public native class questScene_NodeType extends questSpawnManagerNodeType {
  native let entityReference: EntityReference;
}

public native class questSceneCondition extends questTypedCondition {
  native let type: ref<questISceneConditionType>;
}

enum questSceneConditionType {
  Undefined = 0,
  IsInside = 1,
  IsOutside = 2,
  Entered = 3,
  Exited = 4,
}

public native class questSceneInterrupt_ConditionType extends questISceneConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let onlyInSafeMoment: Bool;
  native let interruptConditions: array<ref<scnIInterruptCondition>>;
}

public native struct questSceneLocation {
  native let sceneWorldMarkerTag: CName;
}

public native class questSceneManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questISceneManagerNodeType>;
}

public native class questSceneNode_ConditionType extends questISceneConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
  native let ActorName: CName;
  native let type: questSceneConditionType;
}

public native class questSceneNodeDefinition extends questSignalStoppingNodeDefinition {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let sceneLocation: scnWorldMarker;
  native let interruptionOperations: array<ref<scnIInterruptionOperation>>;
  native let syncToMusic: Bool;
  native let notAllowedToBeFrozen: Bool;
  native let reapplyInterruptionOperationsAfterGameLoad: Bool;
}

public native class questSceneReturn_ConditionType extends questISceneConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
  native let returnConditions: array<ref<scnIReturnCondition>>;
}

public native class questSceneTalking_ConditionType extends questISceneConditionType {
  native let GlobalEntityRef: EntityReference;
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
  native let SectionName: CName;
  native let ActorName: String;
  native let isInverted: Bool;
}

public native class questSceneTier_ConditionType extends questISceneConditionType {
  native let tier: GameplayTier;
  native let isInverted: Bool;
}

public native class questSectionNode_ConditionType extends questISceneConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
  native let sectionName: CName;
  native let type: questSceneConditionType;
}

public native class questSendAICommandNodeDefinition extends questAICommandNodeBase {
  native let puppet: EntityReference;
  native let commandParams: ref<AICommandParams>;
}

public native class questSendMessage_NodeType extends questIPhoneManagerNodeType {
  native let msg: ref<gameJournalPath>;
  native let sendNotification: Bool;
}

public native class questSensesCondition extends questTypedCondition {
  native let type: ref<questISensesConditionType>;
}

public native struct questSetAsCrowdObstacle_NodeTypeParams {
  native let puppetRef: EntityReference;
  native let enable: Bool;
}

public native class questSetAutopilot_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let val: Bool;
}

public native class questSetBriefingAlignment_NodeType extends questIUIManagerNodeType {
  native let briefingAlignment: questJournalAlignmentEventType;
}

public native class questSetBriefingSize_NodeType extends questIUIManagerNodeType {
  native let briefingSize: questJournalSizeEventType;
}

public native class questSetCanVehicleBeRemoteControlled_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let val: Bool;
}

public native class questSetConveyorState_NodeType extends questIInteractiveObjectManagerNodeType {
  native let objectRef: NodeRef;
  native let enable: Bool;
}

public native class questSetCustomStyle_NodeType extends questIPhoneManagerNodeType {
  native let style: questCustomStyle;
  native let isActive: Bool;
}

public native class questSetCyberspacePostFX_NodeType extends questIRenderFxManagerNodeType {
  native let enabled: Bool;
  native let fullScreen: Bool;
  native let vfx: Bool;
  native let initialDatamosh: Float;
  native let targetDatamosh: Float;
  native let initialTreshold: Float;
  native let targetTreshold: Float;
  native let timeBlend: Float;
}

public native class questSetDebugView_NodeType extends questIRenderFxManagerNodeType {
  native let mode: questEDebugViewMode;
}

enum questSetDestructionStateAction {
  Undefined = 0,
  Trigger = 1,
}

public native class questSetFadeInOut_NodeType extends questIRenderFxManagerNodeType {
  native let fadeColor: Color;
  native let fadeIn: Bool;
  native let duration: Float;
}

public native class questSetFastTravelBinksGroup_NodeType extends questIUIManagerNodeType {
  native let selectedBinkDataGroup: TweakDBID;
}

public native class questSetFocusClueState_NodeType extends questIVisionModeNodeType {
  native let objectRef: EntityReference;
  native let clueId: Int32;
  native let clueState: Bool;
}

public native class questSetFOV_NodeType extends questISceneManagerNodeType {
  native let FOV: Float;
}

public native struct questSetGender_NodeTypeParams {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let gender: CName;
}

public native class questSetHUDEntryForcedVisibility_NodeType extends questIUIManagerNodeType {
  native let hudEntryName: array<CName>;
  native let usePreset: Bool;
  native let hudVisibilityPreset: TweakDBID;
  native let visibility: worlduiEntryVisibility;
  native let skipAnimation: Bool;
}

public native class questSetHUDEntryVisibility_NodeType extends questIUIManagerNodeType {
  native let hudEntryName: array<CName>;
  native let usePreset: Bool;
  native let hudVisibilityPreset: TweakDBID;
  native let visibility: Bool;
}

public native struct questSetIdleRazerAnimation_NodeTypeParams {
  native let animationName: CName;
  native let use: Bool;
}

public native class questSetImmovable_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let enable: Bool;
}

public native class questSetInspectMode_NodeType extends questIInteractiveObjectManagerNodeType {
  native let objectID: String;
  native let startingOffset: Float;
  native let zoomOffset: Float;
  native let timeInterval: Float;
}

public native class questSetInteractionState_NodeType extends questIInteractiveObjectManagerNodeType {
  native let objectRef: NodeRef;
  native let enable: Bool;
}

public native class questSetInteractionVisualizerOverride extends questIInteractiveObjectManagerNodeType {
  native let objectRef: NodeRef;
  native let applyOverride: Bool;
  native let removeAfterSingleUse: Bool;
}

public native class questSetItemTags_NodeType extends questIItemManagerNodeType {
  native let params: array<questSetItemTags_NodeTypeParams>;
}

public native struct questSetItemTags_NodeTypeParams {
  native let objectRef: ref<questUniversalRef>;
  native let itemId: TweakDBID;
  native let addTags: Bool;
}

public native class questSetLocationName_NodeType extends questIUIManagerNodeType {
  native let locationName: String;
  native let action: questLocationAction;
  native let districtID: TweakDBID;
  native let isNewLocation: Bool;
}

public native class questSetLootIconsVisibility_NodeType extends questIUIManagerNodeType {
  native let lootIconsVisible: Bool;
}

public native class questSetLootInteractionAccess_NodeType extends questIItemManagerNodeType {
  native let objectRef: EntityReference;
  native let accessible: Bool;
}

public native class questSetMetaQuestProgress_NodeType extends questIUIManagerNodeType {
  native let metaQuestId: gamedataMetaQuest;
  native let percent: Uint32;
  native let text: LocalizationString;
}

public native class questSetMultiplayerHeistSpawnPointTag_NodeType extends questIMultiplayerHeistNodeType {
  native let spawnPointTag: CName;
}

public native class questSetMultiplayerHeistState_NodeType extends questIMultiplayerHeistNodeType {
  native let state: questMultiplayerHeistState;
}

public native class questSetPhoneRestriction_NodeType extends questIPhoneManagerNodeType {
  native let applyPhoneRestriction: Bool;
  native let forcedApply: Bool;
  native let forcedApplySource: CName;
}

public native class questSetPhoneStatus_NodeType extends questIPhoneManagerNodeType {
  native let status: questPhoneStatus;
  native let customStatus: CName;
}

public native class questSetPlayerMinimapIconRotationAdjustment_NodeType extends questIUIManagerNodeType {
  native let rotationAdjustment: Float;
}

public native class questSetPossesion_NodeType extends questISceneManagerNodeType {
  native let playerPossesion: gamedataPlayerPossesion;
}

public native class questSetProgress_NodeType extends questIAchievementManagerNodeType {
  native let achievement: TweakDBID;
  native let factName: String;
  native let maxValue: Uint32;
  native let currentValue: Uint32;
}

public native class questSetRenderLayer_NodeType extends questIRenderFxManagerNodeType {
  native let renderSceneLayer: RenderSceneLayer;
}

public native class questSetSaveDataLoadingScreen_NodeType extends questIUIManagerNodeType {
  native let selectedLoading: TweakDBID;
}

public native class questSetScanningAngleThreshold_NodeType extends questIVisionModeNodeType {
  native let angleThreshold: Float;
  native let debugSource: CName;
}

public native class questSetScanningState_NodeType extends questIVisionModeNodeType {
  native let objectRef: EntityReference;
  native let state: questScanningState;
}

public native class questSetScanningTime_NodeType extends questIVisionModeNodeType {
  native let objectRef: EntityReference;
  native let time: Float;
}

public native class questSetTargetingQueryRange_NodeType extends questISceneManagerNodeType {
  native let targetingQueryRange: Float;
  native let resetToDefault: Bool;
}

public native class questSetTier_NodeType extends questISceneManagerNodeType {
  native let tier: GameplayTier;
  native let usePlayerWorkspot: Bool;
  native let useEnterAnim: Bool;
  native let useExitAnim: Bool;
  native let forceEmptyHands: Bool;
  native let motionConstrainedTierDataParams: MotionConstrainedTierDataParams;
}

public native class questSetTier2Params_NodeType extends questISceneManagerNodeType {
  native let playerWalkType: Tier2WalkType;
  native let usePlayerWorkspot: Bool;
  native let useEnterAnim: Bool;
  native let useExitAnim: Bool;
}

public native class questSetTier3Params_NodeType extends questISceneManagerNodeType {
  native let yawLeftLimit: Float;
  native let yawRightLimit: Float;
  native let pitchUpLimit: Float;
  native let pitchDownLimit: Float;
  native let yawSpeedMultiplier: Float;
  native let pitchSpeedMultiplier: Float;
  native let objectRef: EntityReference;
  native let slotName: CName;
  native let offsetPos: Vector3;
  native let rotationTime: Float;
  native let rotateHeadOnly: Bool;
  native let usePlayerWorkspot: Bool;
  native let useEnterAnim: Bool;
  native let useExitAnim: Bool;
}

public native class questSetTier4Params_NodeType extends questISceneManagerNodeType {
  native let objectRef: NodeRef;
  native let adjustTime: Float;
  native let usePlayerWorkspot: Bool;
  native let useEnterAnim: Bool;
  native let useExitAnim: Bool;
}

public native class questSetTime_NodeType extends questITimeManagerNodeType {
  native let hours: Int32;
  native let minutes: Int32;
  native let seconds: Int32;
  native let source: CName;
}

public native class questSetTimer_NodeType extends questIGameManagerNodeType {
  native let enable: Bool;
  native let duration: Float;
}

public native class questSetTriggerState_NodeType extends questITriggerManagerNodeType {
  native let params: array<questSetTriggerState_NodeTypeParams>;
}

public native struct questSetTriggerState_NodeTypeParams {
  native let objectRef: NodeRef;
  native let enable: Bool;
}

public native class questSetUIGameContext_NodeType extends questIUIManagerNodeType {
  native let requestType: questUIGameContextRequestType;
  native let context: UIGameContext;
}

public native class questSetVar_NodeType extends questIFactsDBManagerNodeType {
  native let factName: String;
  native let value: Int32;
  native let setExactValue: Bool;
}

public native class questSetVehicleCamera_NodeType extends questIVehicleManagerNodeType {
  native let cameraType: questVehicleCameraType;
  native let blockOtherCameras: Bool;
}

public native class questShiftTime_NodeType extends questITimeManagerNodeType {
  native let timeShiftType: questETimeShiftType;
  native let preventVisualGlitch: Bool;
  native let hours: Uint32;
  native let minutes: Uint32;
  native let seconds: Uint32;
}

public native class questShowBracket_NodeSubType extends questITutorial_NodeSubType {
  native let bracketID: CName;
  native let visible: Bool;
  native let visibleOnUILayer: inkELayerType;
  native let bracketType: gameTutorialBracketType;
  native let anchor: inkEAnchor;
  native let offset: Vector2;
  native let size: Vector2;
  native let ignoreDisabledTutorials: Bool;
}

public native class questShowCustomQuestNotification_NodeType extends questIUIManagerNodeType {
  native let customQuestNotificationData: CustomQuestNotificationData;
}

public native class questShowCustomTooltip_NodeType extends questIUIManagerNodeType {
  native let setTooltip: Bool;
  native let text: LocalizationString;
  native let inputAction: String;
  native let holdIndicationType: inkInputHintHoldIndicationType;
  native let queuePriority: Int32;
}

public native class questShowDialogIndicator_NodeType extends questIUIManagerNodeType {
  native let params: array<questShowDialogIndicator_NodeTypeParams>;
}

public native struct questShowDialogIndicator_NodeTypeParams {
  native let objectRef: EntityReference;
  native let show: Bool;
}

public native class questShowHighlight_NodeSubType extends questITutorial_NodeSubType {
  native let entityReference: EntityReference;
  native let enable: Bool;
}

public native class questShowLevelUpNotification_NodeType extends questIUIManagerNodeType {
  native let levelUpData: LevelUpData;
}

public native class questShowNarrativeEvent_NodeType extends questIUIManagerNodeType {
  native let eventText: String;
  native let textColor: Color;
  native let durationSec: Float;
}

public native class questShowOnscreen_NodeType extends questIUIManagerNodeType {
  native let message: String;
  native let localizedMessage: LocalizationString;
  native let duration: Float;
  native let show: Bool;
}

public native class questShowOverlay_NodeSubType extends questITutorial_NodeSubType {
  native let overlayLibrary: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let libraryItemName: CName;
  native let visible: Bool;
  native let pauseGame: Bool;
  native let lockPlayerMovement: Bool;
  native let hideOnInput: Bool;
}

public native class questShowPointOfNoReturnPrompt_NodeType extends questIUIManagerNodeType {}

public native class questShowPopup_NodeSubType extends questITutorial_NodeSubType {
  native let path: ref<gameJournalPath>;
  native let open: Bool;
  native let closeAtInput: Bool;
  native let pauseGame: Bool;
  native let hideInMenu: Bool;
  native let margin: inkMargin;
  native let screenMode: questTutorialScreenMode;
  native let position: PopupPosition;
  native let lockPlayerMovement: Bool;
  native let closeCurrentPopup: Bool;
  native let videoType: VideoType;
  native let video: ResourceAsyncRef; // raRef<Bink>
  native let ignoreDisabledTutorials: Bool;
}

public native class questShowWorldNode_NodeType extends questIWorldDataManagerNodeType {
  native let objectRef: NodeRef;
  native let isPlayer: Bool;
  native let show: Bool;
  native let componentName: CName;
}

public abstract native class questSignalStoppingNodeDefinition extends questDisableableNodeDefinition {}

public native struct questSimpleMoveOnSplineParams {
  native let movementType: moveMovementType;
  native let facingTargetRef: ref<questUniversalRef>;
  native let rotateEntityTowardsFacingTarget: Bool;
  native let snapToTerrain: Bool;
  native let useOffMeshLinkReservation: Bool;
  native let allowCrowdOnPath: Bool;
}

public native class questSocketDefinition extends graphGraphSocketDefinition {
  native let type: questSocketType;
}

enum questSocketType {
  Undefined = 0,
  Input = 1,
  Output = 2,
  CutSource = 3,
  CutDestination = 4,
}

enum questSpawnDirectionPreference {
  Behind = 0,
  InFront = 1,
}

enum questSpawnedVehicleType {
  EntityReferenced = 0,
  AnyCar = 1,
  AnyMotorcycle = 2,
  SpecificVehicle = 3,
}

public native class questSpawner_NodeType extends questSpawnManagerNodeType {
  native let spawnerReference: NodeRef;
}

public native class questSpawnerCondition extends questTypedCondition {
  native let type: ref<questISpawnerConditionType>;
}

public native class questSpawnerNotReady_ConditionType extends questISpawnerConditionType {
  native let spawnerReference: NodeRef;
  native let communityEntryNames: array<CName>;
}

public native class questSpawnerReady_ConditionType extends questISpawnerConditionType {
  native let spawnerReference: NodeRef;
  native let communityEntryNames: array<CName>;
}

public native struct questSpawnManagerNodeActionEntry {
  native let type: ref<questSpawnManagerNodeType>;
}

public native class questSpawnManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let actions: array<questSpawnManagerNodeActionEntry>;
}

public abstract native class questSpawnManagerNodeType extends questIRetNodeType {
  native let action: populationSpawnerObjectCtrlAction;
}

public native class questSpawnPlayerVehicle_NodeType extends questIVehicleManagerNodeType {
  native let despawn: Bool;
  native let positionRef: ref<questUniversalRef>;
  native let offset: Vector3;
  native let driveIn: Bool;
  native let vehicle: String;
  native let vehicleGlobalName: CName;
  native let despawnAllEnabledVehicles: Bool;
  native let retryUntilStubCreated: Bool;
}

public native class questSpawnSet_NodeType extends questSpawnManagerNodeType {
  native let reference: NodeRef;
  native let entryName: CName;
  native let phaseName: CName;
}

public native class questSpawnToken_NodeSubType extends questIContentTokenManager_NodeSubType {
  native let immediate: Bool;
}

public abstract native class questStartEndNodeDefinition extends questDisableableNodeDefinition {}

public native class questStartNodeDefinition extends questStartEndNodeDefinition {}

public native class questStartRace_NodeType extends questIVehicleManagerNodeType {}

public native class questStartRecording_NodeType extends questIRecordingNodeType {
  native let enabled: Bool;
  native let sectionName: String;
}

public native class questStartVehicle_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let blendTime: Float;
}

public native class questStat_ConditionType extends questIStatsConditionType {
  native let statType: gamedataStatType;
  native let value: Float;
  native let comparisonType: EComparisonType;
}

public native class questStatsCondition extends questTypedCondition {
  native let type: ref<questIStatsConditionType>;
}

public native class questStimuli_ConditionType extends questISensesConditionType {
  native let instigatorRef: EntityReference;
  native let isPlayerInstigator: Bool;
  native let targetRef: EntityReference;
  native let type: gamedataStimType;
}

public native class questStopRace_NodeType extends questIVehicleManagerNodeType {}

public native struct questStopRazerAnimation_NodeTypeParams {
  native let animationName: CName;
}

public native class questStopRecording_NodeType extends questIRecordingNodeType {}

public native class questStopVehicle_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let time: Float;
  native let detachFromSpline: Bool;
}

public native class questStopWorkspot_NodeType extends questIBehaviourManager_NodeType {
  native let allowCurrAnimToFinish: Bool;
  native let exitAnim: CName;
}

enum questStorage {
  Slow = 0,
  Fast = 1,
}

public native class questStorageType_ConditionType extends questISystemConditionType {
  native let storage: questStorage;
}

public native class questStreamingTestCheckpoint_NodeType extends questIWorldDataManagerNodeType {
  native let checkpointType: worldStreamingTestCheckpointType;
}

public native class questStreamingTestMovePlayerOnSpline_NodeType extends questIWorldDataManagerNodeType {
  native let splineRef: NodeRef;
}

public native class questStreetCredTier_ConditionType extends questIStatsConditionType {
  native let tierID: TweakDBID;
  native let comparisonType: EComparisonType;
}

public native class questSwitchNameplate_NodeType extends questIUIManagerNodeType {
  native let puppetRef: EntityReference;
  native let isPlayer: Bool;
  native let enable: Bool;
  native let alternativeName: Bool;
}

public native class questSwitchNodeDefinition extends questDisableableNodeDefinition {
  native let behaviour: questESwitchBehaviourType;
  native let conditions: array<questConditionItem>;
}

public native class questSwitchToScenario_NodeType extends questIUIManagerNodeType {
  native let startScenarioName: CName;
  native let endScenarioName: CName;
  native let userData: ref<inkUserData>;
  native let forceOpenDuringFadeout: Bool;
}

enum questSwitchWeaponModes {
  PrimaryWeapon = 0,
  SecondaryWeapon = 1,
}

public native class questSystemCondition extends questTypedCondition {
  native let type: ref<questISystemConditionType>;
}

public native class questTagged_ConditionType extends questIObjectConditionType {
  native let objectRef: EntityReference;
  native let inverted: Bool;
}

public native class questTeleport_NodeType extends questIVehicleManagerNodeType {
  native let entityReference: EntityReference;
  native let params: questTeleportPuppetParams;
}

public native class questTeleportPuppetNodeDefinition extends questAICommandNodeBase {
  native let entityReference: ref<questUniversalRef>;
  native let params: ref<questTeleportPuppetParamsV1>;
  native let lookAtAction: questLookAtAction;
  native let playerLookAt: ref<questPlayerLookAtParams>;
}

public native struct questTeleportPuppetParams {
  native let destinationRef: ref<questUniversalRef>;
  native let destinationOffset: Vector3;
}

public native class questTeleportPuppetParamsV1 extends AICommandParams {
  native let destinationRef: ref<questUniversalRef>;
  native let destinationOffset: Vector3;
  native let doNavTest: Bool;
  native let useFastTravelMechanism: Bool;
  native let healAtTeleport: Bool;
}

public native class questTeleportVehicleNodeDefinition extends questDisableableNodeDefinition {
  native let entityReference: EntityReference;
  native let params: questTeleportPuppetParams;
  native let resetVelocities: Bool;
}

public native class questTestNodeDefinition extends questDisableableNodeDefinition {}

public native class questTickDelay_ConditionType extends questITimeConditionType {
  native let tickCount: Uint32;
}

public native class questTimeCondition extends questTypedCondition {
  native let type: ref<questITimeConditionType>;
}

public native class questTimeDilation_Entity extends questTimeDilation_NodeTypeParam {
  native let operation: ref<questTimeDilation_Operation>;
  native let globalTimeDilationOverride: questETimeDilationOverride;
  native let parentTimeDilationOverride: questETimeDilationOverride;
  native let entities: array<NodeRef>;
}

public native class questTimeDilation_NodeType extends questIGameManagerNonSignalStoppingNodeType {
  native let params: array<ref<questTimeDilation_NodeTypeParam>>;
}

public abstract native class questTimeDilation_NodeTypeParam extends ISerializable {}

public native class questTimeDilation_Operation extends ISerializable {}

public native class questTimeDilation_Player extends questTimeDilation_NodeTypeParam {
  native let operation: ref<questTimeDilation_Operation>;
  native let globalTimeDilationOverride: questETimeDilationOverride;
}

public native class questTimeDilation_Puppet extends questTimeDilation_NodeTypeParam {
  native let operation: ref<questTimeDilation_Operation>;
  native let globalTimeDilationOverride: questETimeDilationOverride;
  native let puppets: EntityReference;
}

public native class questTimeDilation_Start extends questTimeDilation_Operation {
  native let dilation: Float;
  native let duration: Float;
  native let easeInCurve: CName;
  native let easeOutCurve: CName;
}

public native class questTimeDilation_Stop extends questTimeDilation_Operation {
  native let easeOutCurve: CName;
}

public native class questTimeDilation_World extends questTimeDilation_NodeTypeParam {
  native let reason: CName;
  native let operation: ref<questTimeDilation_Operation>;
}

public native class questTimeManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questITimeManagerNodeType>;
}

public native class questTimePeriod_ConditionType extends questITimeConditionType {
  native let begin: GameTime;
  native let end: GameTime;
}

enum questTimeSkipMode {
  PreSkip = 0,
  PostSkip = 1,
}

public native class questTimeSkipped_ConditionType extends questIUIConditionType {
  native let mode: questTimeSkipMode;
}

public native class questToggleBrokenTire_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let val: Bool;
  native let tire: Uint32;
}

public native class questToggleCombatForPlayer_NodeType extends questIVehicleManagerNodeType {
  native let startCombat: Bool;
}

public native class questToggleDoor_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let doorAction: EQuestVehicleDoorState;
  native let door: EVehicleDoor;
  native let forceScene: Bool;
  native let toOpen: Bool;
  native let doorID: CName;
}

public native class questToggleEventExecutionTag_NodeType extends questISceneManagerNodeType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let eventExecutionTag: CName;
  native let mute: Bool;
}

public native class questToggleForceBrake_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let playerVehicle: Bool;
  native let val: Bool;
}

public native class questToggleMinimapVisibility_NodeSubType extends questIUIManagerNodeType {
  native let entityReference: EntityReference;
  native let show: Bool;
}

public native class questTogglePrefabVariant_NodeType extends questIWorldDataManagerNodeType {
  native let params: array<questTogglePrefabVariant_NodeTypeParams>;
}

public native struct questTogglePrefabVariant_NodeTypeParams {
  native persistent let prefabNodeRef: NodeRef;
  native persistent let variantStates: array<questVariantState>;
}

public native class questToggleStealthMappinVisibility_NodeSubType extends questIUIManagerNodeType {
  native let entityReference: EntityReference;
  native let show: Bool;
}

public native class questToggleSwitchSeatsForPlayer_NodeType extends questIVehicleManagerNodeType {}

public native class questToggleTankCustomFPPLockOff_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let playerVehicle: Bool;
  native let val: Bool;
}

public native class questToggleVisionMode_NodeType extends questIVisionModeNodeType {
  native let objectRef: EntityReference;
  native let enable: Bool;
}

public native class questToggleWeaponEnabled_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let playerVehicle: Bool;
  native let val: Bool;
  native let weapon: questVehicleWeaponQuestID;
}

public native class questToggleWindow_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let windowState: EQuestVehicleWindowState;
  native let door: EVehicleDoor;
}

public native class questTransferItem_NodeType extends questIItemManagerNodeType {
  native let params: array<questTransferItems_NodeTypeParams>;
}

public native struct questTransferItems_NodeTypeParams_OperationData {
  native let itemTDBID: TweakDBID;
  native let quantity: Int32;
}

public native struct questTransferItems_NodeTypeParams_TagOperationData {
  native let tagToTransfer: CName;
  native let itemIDsToIgnore: array<TweakDBID>;
  native let tagsToIgnore: array<CName>;
}

public native class questTransferItems_NodeTypeParams_TransferAllOperationData extends ISerializable {
  native let itemIDsToIgnore: array<TweakDBID>;
  native let tagsToIgnore: array<CName>;
}

public native struct questTransferItems_NodeTypeParams {
  native let giver: ref<questUniversalRef>;
  native let receiver: ref<questUniversalRef>;
  native let transferAllOperation: ref<questTransferItems_NodeTypeParams_TransferAllOperationData>;
  native let itemOperations: array<questTransferItems_NodeTypeParams_OperationData>;
  native let tagOperations: array<questTransferItems_NodeTypeParams_TagOperationData>;
}

public native class questTransformAnimatorNode_Action_Pause extends questTransformAnimatorNode_ActionType {}

public native class questTransformAnimatorNode_Action_Play extends questTransformAnimatorNode_ActionType {
  native let timesPlayed: Int32;
  native let timeScale: Float;
  native let reverse: Bool;
  native let useEntitySetup: Bool;
}

public native class questTransformAnimatorNode_Action_Reset extends questTransformAnimatorNode_ActionType {}

public native class questTransformAnimatorNode_Action_Skip extends questTransformAnimatorNode_ActionType {
  native let skipTo: Float;
  native let skipToEnd: Bool;
}

public abstract native class questTransformAnimatorNode_ActionType extends questIBaseNodeType {}

public native class questTransformAnimatorNodeDefinition extends questSignalStoppingNodeDefinition {
  native let objectRef: EntityReference;
  native let animationName: CName;
  native let action: ref<questTransformAnimatorNode_ActionType>;
}

public native struct questTriggerCondition_FulfillInfo {}

public native class questTriggerCondition extends questCondition {
  native let type: questTriggerConditionType;
  native let triggerAreaRef: NodeRef;
  native let activatorRef: EntityReference;
  native let isPlayerActivator: Bool;
}

enum questTriggerConditionType {
  Undefined = 0,
  Entered = 1,
  Exited = 2,
  IsInside = 3,
  IsOutside = 4,
  AllInsideMP = 5,
  AllOutsideMP = 6,
}

public native class questTriggerIconGeneration_NodeType extends questIUIManagerNodeType {}

public native class questTriggerManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questITriggerManagerNodeType>;
}

public native class questTriggerNotifier_Quest extends worldITriggerAreaNotifer {}

public native class questTriggerNotifier_QuestInstance extends worldITriggerAreaNotiferInstance {}

public native class questTutorial_NodeType extends questIUIManagerNodeType {
  native let subtype: ref<questITutorial_NodeSubType>;
}

enum questTutorialScreenMode {
  Undefined = 0,
  Fullscreen = 1,
  Popup = 2,
}

public abstract native class questTypedCondition extends questIBaseCondition {}

public abstract native class questTypedSignalStoppingNodeDefinition extends questSignalStoppingNodeDefinition {}

public native class questUICondition extends questTypedCondition {
  native let type: ref<questIUIConditionType>;
}

public native class questUIContextState_ConditionType extends questIUIConditionType {
  native let active: Bool;
}

public native class questUIElement_ConditionType extends questIUIConditionType {
  native let element: TweakDBID;
  native let condition: gamedataUICondition;
  native let value: Bool;
}

enum questUIGameContextRequestType {
  Push = 0,
  Pop = 1,
  Reset = 2,
}

public native class questUIManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questIUIManagerNodeType>;
}

public native class questUnassignAll_NodeType extends questIVehicleManagerNodeType {
  native let vehicleRef: EntityReference;
  native let isInstant: Bool;
  native let clearAssignedVehicleId: Bool;
}

public native class questUnequipItemNodeDefinition extends questSignalStoppingNodeDefinition {
  native let entityReference: EntityReference;
  native let params: questUnequipItemParams;
}

public native struct questUnequipItemParams {
  native let slotId: TweakDBID;
  native let unequipDurationOverride: Float;
}

public native class questUniversalRef extends ISerializable {
  native let entityReference: EntityReference;
  native let refLocalPlayer: Bool;
  native let mainPlayerObject: Bool;
}

public native class questUpdateEntityHealthListeners_NodeType extends questIUIManagerNodeType {
  native let entityRef: EntityReference;
}

public native class questUseWeapon_ChimeraMetalstorm_NodeType extends questUseWeapon_NodeType {}

public native class questUseWeapon_MissileRainGrid_NodeType extends questUseWeapon_NodeType {
  native let source: questEUseWeapon_MissileOffsetsSource;
  native let missileOffsets: array<Vector3>;
  native let targetRefs: array<EntityReference>;
  native let recordID: TweakDBID;
}

public native class questUseWeapon_NodeType extends questIItemManagerNodeType {
  native let usageType: questWeaponUsageType;
  native let objectRef: ref<questUniversalRef>;
  native let overrideShootEffect: CName;
  native let weaponSlotName: CName;
  native let attackTDBID: TweakDBID;
}

public native class questUseWorkspotCommandParams extends AICommandParams {
  native let workspotNode: NodeRef;
  native let moveToWorkspot: Bool;
  native let forceEntryAnimName: CName;
}

public native class questUseWorkspotNodeDefinition extends questAICommandNodeBase {
  native persistent let entityReference: EntityReference;
  native persistent let paramsV1: ref<questUseWorkspotParamsV1>;
}

enum questUseWorkspotNodeFunctions {
  UseWorkspot = 0,
  JumpWorkspot = 1,
  StopWorkspot = 2,
  IdleOnlyMode = 3,
}

public native struct questUseWorkspotParams {
  native persistent let workspotNode: NodeRef;
  native persistent let forceEntryAnimName: CName;
}

public native class questUseWorkspotParamsV1 extends AICommandParams {
  native persistent let function: questUseWorkspotNodeFunctions;
  native persistent let workspotNode: NodeRef;
  native persistent let teleport: Bool;
  native persistent let finishAnimation: Bool;
  native persistent let forceEntryAnimName: CName;
  native persistent let jumpToEntry: Bool;
  native persistent let entryId: WorkEntryId;
  native persistent let entryTag: CName;
  native persistent let changeWorkspot: Bool;
  native persistent let enableIdleMode: Bool;
  native persistent let exitEntryId: WorkEntryId;
  native persistent let exitAnimName: CName;
  native persistent let instant: Bool;
  native persistent let isWorkspotInfinite: Bool;
  native persistent let isPlayer: Bool;
  native persistent let playerParams: questUseWorkspotPlayerParams;
  native persistent let repeatCommandOnInterrupt: Bool;
  native persistent let workExcludedGestures: array<WorkEntryId>;
  native persistent let movementType: moveMovementType;
  native persistent let continueInCombat: Bool;
  native persistent let maxAnimTimeLimit: Float;
  native persistent let meshDissolvingEnabled: Bool;
  native persistent let dangleResetSimulation: Bool;
}

public native struct questUseWorkspotPlayerParams {
  native persistent let tier: questUseWorkspotTier;
  native persistent let cameraSettings: Tier3CameraSettings;
  native persistent let emptyHands: Bool;
  native persistent let cameraUseTrajectorySpace: Bool;
  native persistent let applyCameraParams: Bool;
  native persistent let vehicleProceduralCameraWeight: Float;
  native persistent let parallaxWeight: Float;
  native persistent let parallaxSpace: questCameraParallaxSpace;
}

enum questUseWorkspotTier {
  Tier3 = 0,
  Tier4 = 1,
}

public native class questValueDistance extends questIDistance {
  native let distanceValue: Float;
}

public native class questVarComparison_ConditionType extends questIFactsDBConditionType {
  native let factName: String;
  native let value: Int32;
  native let comparisonType: EComparisonType;
}

public native struct questVariantState {
  native persistent let name: CName;
  native persistent let show: Bool;
}

public native class questVarVsVarComparison_ConditionType extends questIFactsDBConditionType {
  native let factName1: String;
  native let factName2: String;
  native let comparisonType: EComparisonType;
}

public native class questVehicleAirtime_ConditionType extends questIVehicleConditionType {
  native let seconds: Float;
}

public native class questVehicleAvailable_ConditionType extends questIVehicleConditionType {
  native let vehicleType: questAvailableVehicleType;
  native let vehicleName: String;
}

public native class questVehicleAVArrived_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
}

enum questVehicleCameraPerspective {
  FPP = 1,
  TPP = 0,
}

enum questVehicleCameraType {
  Undefined = 0,
  PuppetFPP = 1,
  TPP = 2,
  DriverFPP = 3,
  FPP = 1,
}

public native class questvehicleChaseParams extends questVehicleSpecificCommandParams {
  native let targetEntRef: EntityReference;
  native let isPlayer: Bool;
  native let distanceMin: Float;
  native let distanceMax: Float;
  native let forceStartSpeed: Float;
  native let aggressiveRammingEnabled: Bool;
  native let ignoreChaseVehiclesLimit: Bool;
  native let boostDrivingStats: Bool;
}

public native class questVehicleCollision_ConditionType extends questIVehicleConditionType {
  native let magnitude: questImpulseMagnitude;
}

public native class questVehicleCommandParams extends AICommandParams {
  native let type: questVehicleCommandType;
  native let additionalParamsOnSpline: ref<questvehicleOnSplineParams>;
  native let additionalParamsFollow: ref<questvehicleFollowParams>;
  native let additionalParamsToNode: ref<questvehicleToNodeParams>;
  native let additionalParamsRacing: ref<questvehicleRacingParams>;
  native let additionalParamsJoinTraffic: ref<questvehicleJoinTrafficParams>;
  native let additionalParamsPanic: ref<questvehiclePanicParams>;
  native let additionalParamsChase: ref<questvehicleChaseParams>;
}

enum questVehicleCommandType {
  Move_On_Spline = 0,
  Follow = 1,
  Move_To = 2,
  Racing = 3,
  Join_Traffic = 4,
  Panic = 5,
  Chase = 6,
}

public native class questVehicleCondition extends questTypedCondition {
  native let type: ref<questIVehicleConditionType>;
}

public native class questVehicleCorrectlyPlaced_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
  native let timeInterval: Float;
  native let checkIsUpsideDown: Bool;
  native let checkIsOnTheSide: Bool;
  native let checkAreAllWheelsOnGround: Bool;
  native let inverted: Bool;
}

public native class questVehicleCrowdHit_ConditionType extends questIVehicleConditionType {
  native let lethal: Bool;
}

public native class questVehicleDestruction_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
  native let destruction: Float;
  native let comparisonType: EComparisonType;
}

public native class questVehicleDoor_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
  native let door: EVehicleDoor;
  native let state: VehicleDoorState;
}

public native class questvehicleFollowParams extends questVehicleSpecificCommandParams {
  native let targetEntRef: EntityReference;
  native let distanceMin: Float;
  native let distanceMax: Float;
  native let isPlayer: Bool;
  native let stopWhenTargetReached: Bool;
  native let useTraffic: Bool;
  native let trafficTryNeighborsForStart: Bool;
  native let trafficTryNeighborsForEnd: Bool;
}

public native class questvehicleJoinTrafficParams extends questVehicleSpecificCommandParams {}

public native class questVehicleNodeCommandDefinition extends questAICommandNodeBase {
  native let vehicle: EntityReference;
  native let commandParams: ref<questVehicleCommandParams>;
}

public native class questVehicleNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questIVehicleManagerNodeType>;
}

public native class questvehicleOnSplineParams extends questVehicleSpecificCommandParams {
  native let splineRef: NodeRef;
  native let reverseSpline: Bool;
  native let backwards: Bool;
  native let closest: Bool;
  native let forcedStartSpeed: Float;
  native let stopAtEnd: Bool;
  native let keepDistance: Bool;
  native let keepDistanceParam: ref<questParamKeepDistance>;
  native let rubberBanding: Bool;
  native let rubberBandingParam: ref<questParamRubberbanding>;
  native let audioCurvesParam: ref<vehicleAudioCurvesParam>;
}

public native class questvehiclePanicParams extends questVehicleSpecificCommandParams {
  native let allowSimplifiedMovement: Bool;
  native let ignoreTickets: Bool;
  native let disableStuckDetection: Bool;
  native let useSpeedBasedLookupRange: Bool;
  native let tryDriveAwayFromPlayer: Bool;
}

public native class questVehicleQuickHack_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
  native let checkAccelerate: Bool;
  native let checkForceBrakes: Bool;
  native let checkRemoteControl: Bool;
}

public native class questvehicleRacingParams extends questVehicleSpecificCommandParams {
  native let splineRef: NodeRef;
  native let preciseLevel: Float;
  native let reverseSpline: Bool;
  native let backwards: Bool;
  native let closest: Bool;
  native let rubberBanding: Bool;
  native let rubberBandingParam: ref<questParamRubberbanding>;
}

public native class questVehicleSpawned_ConditionType extends questIVehicleConditionType {
  native let vehicleType: questSpawnedVehicleType;
  native let vehicleRef: EntityReference;
  native let count: Uint32;
  native let comparisonType: EComparisonType;
  native let vehicleName: String;
  native let vehicleGlobalName: CName;
}

public abstract native class questVehicleSpecificCommandParams extends ISerializable {
  native let pushOtherVehiclesAside: Bool;
  native let needDriver: Bool;
  native let secureTimeOut: Float;
}

public native class questVehicleSpeed_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
  native let speed: Float;
  native let comparisonType: vehicleEVehicleSpeedConditionType;
}

public native class questVehicleSummoned_ConditionType extends questIVehicleConditionType {
  native let type: vehicleESummonedVehicleType;
}

public native class questvehicleToNodeParams extends questVehicleSpecificCommandParams {
  native let stopAtEnd: Bool;
  native let nodeRef: NodeRef;
  native let isPlayer: Bool;
  native let useTraffic: Bool;
  native let speedInTraffic: Float;
  native let forceGreenLights: Bool;
  native let portals: ref<vehiclePortalsList>;
  native let trafficTryNeighborsForStart: Bool;
  native let trafficTryNeighborsForEnd: Bool;
  native let ignoreNoAIDrivingLanes: Bool;
}

public native class questVehicleTrunk_ConditionType extends questIVehicleConditionType {
  native let anyVehicle: Bool;
  native let playerVehicle: Bool;
  native let vehicleRef: EntityReference;
  native let anyObject: Bool;
  native let objectRef: EntityReference;
  native let inverted: Bool;
  native let isInside: Bool;
}

public native class questVehicleWater_ConditionType extends questIVehicleConditionType {
  native let anyVehicle: Bool;
  native let vehicleRef: EntityReference;
  native let submergedOnly: Bool;
  native let onEnter: Bool;
}

enum questVehicleWeaponQuestID {
  Primary = 0,
  Secondary = 1,
  Tertiary = 2,
  Quaternary = 3,
  Quinary = 4,
  Senary = 5,
  Septenary = 6,
  Octonary = 7,
  All = 8,
}

public native class questVehicleWeaponUsed_ConditionType extends questIVehicleConditionType {
  native let vehicleRef: EntityReference;
  native let weapon: questVehicleWeaponQuestID;
}

public native class questVendorPanel_NodeType extends questIUIManagerNodeType {
  native let scenarioName: CName;
  native let openVendorPanel: Bool;
  native let vendorId: String;
  native let objectRef: EntityReference;
  native let assetsLibrary: String;
  native let rootItemName: CName;
}

public native class questVision_ConditionType extends questISensesConditionType {
  native let observerPuppetRef: EntityReference;
  native let observedTargetRef: EntityReference;
  native let isObservedTargetPlayer: Bool;
  native let inverted: Bool;
  native let isInstant: Bool;
}

public native class questVisionMode_ConditionType extends questISystemConditionType {
  native let timeInterval: Float;
  native let visionModeType: questVisionModeType;
}

public native class questVisionModesManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIVisionModeNodeType>;
}

enum questVisionModeType {
  Undefined = 0,
  FocusMode = 1,
  EnhancedMode = 2,
}

public native class questVoicesetManagerNodeDefinition extends questDisableableNodeDefinition {
  native let type: ref<questIVoicesetManager_NodeType>;
}

public native class questWaitForAnyKeyLoadingScreen_NodeType extends questIUIManagerNodeType {}

public native class questWarningMessage_NodeType extends questIUIManagerNodeType {
  native let message: String;
  native let localizedMessage: LocalizationString;
  native let duration: Float;
  native let show: Bool;
  native let instant: Bool;
  native let type: SimpleMessageType;
}

enum questWeaponUsageType {
  Shoot = 0,
  StopShooting = 1,
  Reload = 2,
  StartAttack = 3,
  StopAttack = 4,
}

public native class questWeather_ConditionType extends questISystemConditionType {
  native let weather: CName;
  native let inverted: Bool;
}

public native struct questWithCompanionMoveOnSplineParams {
  native let movementType: AIMovementTypeSpec;
  native let facingTargetRef: ref<questUniversalRef>;
  native let rotateEntityTowardsFacingTarget: Bool;
  native let snapToTerrain: Bool;
  native let shootingTargetRef: ref<questUniversalRef>;
  native let companionRef: ref<questUniversalRef>;
  native let companionDistancePreset: gamedataCompanionDistancePreset;
  native let companionPosition: questCompanionPositions;
  native let catchUpWithCompanion: Bool;
  native let teleportToCompanion: Bool;
  native let useMatchForSpeedForPlayer: Bool;
  native let ignoreNavigation: Bool;
  native let ignoreLineOfSightCheck: Bool;
  native let useOffMeshLinkReservation: Bool;
  native let lookAtTargetRef: ref<questUniversalRef>;
  native let minSearchAngle: Float;
  native let maxSearchAngle: Float;
  native let interruptCapability: scnInterruptCapability;
  native let maxCompanionDistanceOnSpline: Float;
}

public native class questWorldDataManagerNodeDefinition extends questSignalStoppingNodeDefinition {
  native let type: ref<questIWorldDataManagerNodeType>;
}

public native class questWorldStateSystem extends questIWorldStateSystem {}

public native struct questWorldStateSystemReplicatedState {
  native let nodeVisibilityMapArray: array<questNodeVisibilityMapArrayElement>;
  native let isInMirrorsAreaMapArray: array<questIsInMirrorsAreaMapArrayElement>;
  native let nodeCollisionMapArray: array<questNodeCollisionMapArrayElement>;
  native let prefabVariants: array<questPrefabVariantMapArrayElement>;
}

public native class RagdollComponent extends IComponent {
  native let isEnabled: Bool;
}

public native class RainAreaSettings extends IAreaSettings {
  native let numParticles: Uint32;
  native let radius: Float;
  native let heightRange: Float;
  native let globalLightResponse: Float;
  native let tiling: CurveDataFloat;
  native let porosityThresholdStart: Float;
  native let porosityThresholdEnd: Float;
  native let glossinessFactor: Float;
  native let baseColorFactor: Float;
  native let moistureAccumulationSpeed: Float;
  native let puddlesAccumulationSpeed: Float;
  native let moistureEvaporationSpeed: Float;
  native let puddlesEvaporationSpeed: Float;
  native let rainIntensity: CurveDataFloat;
  native let rainOverride: CurveDataFloat;
  native let rainMoistureOverride: CurveDataFloat;
  native let rainPuddlesOverride: CurveDataFloat;
  native let waterRainIntensity: Float;
  native let rainleaksMask: ResourceRef; // rRef<CBitmapTexture>
  native let raindropsMask: ResourceRef; // rRef<CBitmapTexture>
  native let rainRipplesMask: ResourceRef; // rRef<CBitmapTexture>
}

public importonly native class ReactionComponent extends IComponent {
  native let reactions: array<ReactionData>;
  native let triggerAutomatically: Bool;
  public final native func GetReactionIndex()
  public final native func GetRequiredItems()
  public final native func PerformReaction()
  public final native func PerformReactionWithIK()
  public final native func SetCanceled()
  public final native func SetFinished()
}

public native struct Rect {
  native let left: Int32;
  native let top: Int32;
  native let right: Int32;
  native let bottom: Int32;
}

public importonly native class RecycleEventAdvanced extends Event {}

public native struct redConvexHullEx {}

public native struct redErrorResult {
  native let message: String;
  native let userData: Variant;
}

public abstract native struct redICommandlet {}

public abstract native struct redPackageCustomTypeSerializer {}

public native class redResourceListResource extends CResource {
  native let resources: array<ResourceAsyncRef>;
  native let descriptions: array<String>;
}

public native struct redStageMessage {
  native let parent: Uint32;
  native let reset: Bool;
  native let names: array<String>;
  native let ids: array<Uint32>;
}

public native struct redTagList {
  native let tags: array<CName>;
}

public native struct redTagSystem {}

public native struct redTaskNameMessage {
  native let id: Uint32;
  native let parent: Uint32;
  native let title: String;
  native let uniqueName: CName;
}

public native struct redTaskProgressMessage {
  native let id: Uint32;
  native let parent: Uint32;
  native let progress: Float;
  native let processingTime: Float;
}

public native struct redTaskTextMessage {
  native let taskId: Uint32;
  native let parent: Uint32;
  native let text: String;
  native let type: redTaskTextMessageType;
}

enum redTaskTextMessageType {
  Info = 0,
  Error = 1,
}

public native class redTOMLArrayBool extends redTOMLBaseValue {}

public native class redTOMLArrayFloat extends redTOMLBaseValue {}

public native class redTOMLArrayInt64 extends redTOMLBaseValue {}

public native class redTOMLArrayString extends redTOMLBaseValue {}

public native class redTOMLArrayTable extends redTOMLBaseValue {}

public native class redTOMLArrayTransform extends redTOMLBaseValue {}

public native class redTOMLBaseValue extends ISerializable {}

public native class redTOMLKeyValue extends redTOMLBaseValue {}

public native class redTOMLTable extends redTOMLBaseValue {}

public native class RemovedAsHostileThreat extends AIEvent {
  native let threateningEntity: wref<TargetTrackerComponent>;
  native let threateningEntityCanTriggersCombat: Bool;
}

enum rendCaptureContextType {
  SceneGamedef = 0,
  AnimViewer = 1,
}

public native struct rendCaptureParameters {
  native let enable: Bool;
  native let mode: rendScreenshotMode;
  native let videoRecordingMode: Bool;
  native let audioRecordingMode: Bool;
  native let emmModes: array<EEnvManagerModifier>;
  native let initialFrameNumber: Uint32;
  native let outputDirectoryIndex: Uint32;
  native let outputDirectoryName: String;
  native let outputDirectoryNameSuffix: String;
  native let recordingFPS: Uint32;
  native let customResolution: Point;
  native let resolutionMultiplier: rendResolutionMultiplier;
  native let outputPath: AbsolutePathSerializable;
  native let fovMultiplier: Float;
  native let captureContextType: rendCaptureContextType;
  native let saveFormat: ESaveFormat;
}

public native struct rendChunk {
  native let chunkVertices: rendVertexBufferChunk;
  native let chunkIndices: rendIndexBufferChunk;
  native let numVertices: Uint16;
  native let numIndices: Uint32;
  native let materialId: array<CName>;
  native let vertexFactory: Uint8;
  native let baseRenderMask: Uint16;
  native let mergedRenderMask: Uint16;
  native let lodMask: Uint8;
}

enum rendContactShadowReciever {
  CSR_None = 0,
  CSR_All = 3,
  CSR_CharacterOnly = 2,
}

enum renddimEPreset {
  _228x128 = 0,
  _456x256 = 1,
  _480x270 = 2,
  _640x480 = 3,
  _960x540 = 4,
  _1280x720 = 5,
  _1600x900 = 6,
  _1920x1080 = 7,
  _2560x1080 = 8,
  _2560x1440 = 9,
  _3440x1440 = 11,
  _3840x1600 = 12,
  _3840x2160 = 13,
  _688x388 = 14,
  _776x436 = 15,
  Console_Base = 7,
  Console_Pro_Prospero_Lockhart = 9,
  Console_Scorpio = 13,
  Console_Anaconda = 13,
}

public native struct rendEmitterDelaySettings {
  native let emitterDelay: Float;
  native let emitterDelayLow: Float;
  native let useEmitterDelayRange: Bool;
  native let useEmitterDelayOnce: Bool;
}

public native struct rendEmitterDurationSettings {
  native let emitterDuration: Float;
  native let emitterDurationLow: Float;
  native let useEmitterDurationRange: Bool;
}

public native struct rendEmitterLOD {
  native let lodSwitchDistance: Float;
  native let burstList: array<rendParticleBurst>;
  native let birthRate: array<Float>;
  native let emitterDurationSettings: rendEmitterDurationSettings;
  native let emitterDelaySettings: rendEmitterDelaySettings;
  native let sortingMode: rendEParticleSortingMode;
  native let isEnabled: Bool;
}

public native struct rendEmitterSimulationShaders {}

enum rendEParticleSortingMode {
  PSM_None = 0,
  PSM_Billboard = 1,
  PSM_Regular = 2,
}

enum rendEPathTracingLightUsage {
  PTLU_Everywhere = 0,
  PTLU_OnlyInPathTracing = 1,
  PTLU_ExcludeFromPathTracing = 2,
}

enum RenderDecalNormalsBlendingMode {
  AlphaBlending = 0,
  Reorient = 1,
}

enum RenderDecalOrderPriority {
  Priority0 = 0,
  Priority1 = 1,
  Priority2 = 2,
  Priority3 = 3,
}

enum renderDevEnvProbeView {
  RADIANCE = 0,
  ALBEDO = 1,
  NORMAL = 2,
  ROUGHNESS = 3,
  METALNESS = 4,
  EMISSIVE = 5,
  SKY_MASK = 6,
}

enum renderDevGIProbeView {
  RADIANCE = 0,
  SKY_VISIBILITY = 1,
  ENV_ID = 2,
  FLAG_0 = 3,
  FLAG_1 = 4,
  FLAG_2 = 5,
  CURRENT_ID = 6,
}

enum renderDevSurfelView {
  ALBEDO = 0,
  NORMAL = 1,
  SHADOWS = 2,
  CLOSEST_PROBE = 3,
  EMISSIVE = 4,
  LIGHTING = 5,
  BOUNCE = 6,
  INSIDE = 7,
  SHADOW = 8,
}

enum renderDevTXAADebugMode {
  TXAA_NoDebug = 0,
  TXAA_ShowHistoryBlendFactor = 1,
}

public native class RenderFeaturesAreaSettings extends IAreaSettings {
  native let allowGlobalIllumination: Bool;
  native let allowScreenSpaceReflections: Bool;
  native let allowVolumetricFog: Bool;
}

public native class RenderingFunctionalTests extends IScriptable {
  public final native func GetEMMFilter()
  public final native func GetViewportResolution()
  public final native func SetEMMFilter()
  public final native func SetFpsClamp()
}

enum RenderSceneLayer {
  Default = 0,
  Cyberspace = 1,
  WorldMap = 2,
}

public native struct RenderSettingFactors {
  native let resolutionAberrationScale: CurveDataFloat;
  native let resolutionAberrationDispersal: CurveDataFloat;
  native let resolutionFilmGrainScale: CurveDataFloat;
  native let resolutionFilmGrainStrength: CurveDataFloat;
}

enum rendEStreamingObserverMode {
  Point = 0,
  Box = 1,
}

public native class rendFont extends CResource {}

enum rendGIGroup {
  GI_Group0 = 0,
  GI_Group1 = 1,
}

enum rendGIVolume {
  GI_Exterior = 0,
  GI_Interior1 = 1,
  GI_Interior2 = 2,
  GI_Interior3 = 3,
  GI_Interior4 = 4,
}

public native class rendGradientEntry extends ISerializable {
  native let value: Float;
  native let color: Color;
}

public native struct rendGridGeneratorData {
  native let startingPosition: Vector3;
  native let rotation: EulerAngles;
  native let xStep: Float;
  native let yStep: Float;
  native let numberOfXSteps: Uint32;
  native let numberOfYSteps: Uint32;
  native let orbitDistance: Float;
  native let zoom: Float;
}

public native class rendHairProfileGradientEntry extends ISerializable {
  native let value: Float;
  native let color: Color;
}

public native struct rendHistogramBias {
  native let mulCoef: Vector3;
  native let addCoef: Vector3;
}

public abstract native struct rendIDebugDrawHistorySystem {}

public native struct rendIndexBufferChunk {
  native let pe: GpuWrapApieIndexBufferChunkType;
  native let teOffset: Uint32;
}

public native class rendIRenderTextureBlob extends IRenderResourceBlob {
  native let header: rendRenderTextureBlobHeader;
}

enum rendLightAttenuation {
  LA_InverseSquare = 0,
  LA_Linear = 1,
}

enum rendLightGroup {
  LG_Group0 = 0,
  LG_Group1 = 1,
  LG_Group2 = 2,
  LG_Group3 = 3,
  LG_Group4 = 4,
  LG_Group5 = 5,
  LG_Group6 = 6,
  LG_Group7 = 7,
}

public native struct rendOpacityMicromapChunk {
  native let mChunkIndex: Uint32;
  native let unkIndex: Uint32;
  native let terialIdentifier: Uint64;
  native let terialName: CName;
  native let mDigest: Uint64;
  native let mIndexBufferSize: Uint32;
  native let mIndexBuffer16bit: Uint32;
  native let mIndexBufferOffset: Uint64;
  native let mArrayBufferOffset: Uint64;
  native let mDescsBufferOffset: Uint64;
  native let mDescArrayHistogramData: array<rendOpacityMicromapUsageCounts>;
  native let mIndexHistogramData: array<rendOpacityMicromapUsageCounts>;
}

public native struct rendOpacityMicromapDatabase {
  native let ommChunks: array<rendOpacityMicromapChunk>;
  native let dataBuffer: array<Uint8>;
}

public native struct rendOpacityMicromapUsageCounts {
  native let bdivisionLevel: Uint32;
  native let rmat: Uint32;
  native let unt: Uint32;
}

public native struct rendParticleBurst {
  native let burstTime: Float;
  native let spawnCount: Uint32;
  native let spawnTimeRange: Float;
  native let repeatTime: Float;
}

enum rendPostFx_ScanningState {
  Off = 0,
  Scanning = 2,
  Cancelled = 3,
  Complete = 4,
}

enum rendRayTracedShadowsPlatform {
  RLSP_All = 0,
  RLSP_PC = 1,
  RLSP_Consoles = 2,
}

public native class rendRenderMeshBlob extends IRenderResourceBlob {
  native let header: rendRenderMeshBlobHeader;
}

public native struct rendRenderMeshBlobHeader {
  native let version: Uint32;
  native let dataProcessing: Uint32;
  native let bonePositions: array<Vector4>;
  native let renderLODs: array<Float>;
  native let renderChunks: array<Uint8>;
  native let renderChunkInfos: array<rendChunk>;
  native let speedTreeWind: array<Uint8>;
  native let opacityMicromaps: array<Uint8>;
  native let customData: array<Uint8>;
  native let customDataElemStride: Uint32;
  native let topologyData: array<Uint8>;
  native let topologyDataStride: Uint32;
  native let topologyMetadata: array<Uint8>;
  native let topologyMetadataStride: Uint32;
  native let topology: array<rendTopologyData>;
  native let quantizationScale: Vector4;
  native let quantizationOffset: Vector4;
  native let vertexBufferSize: Uint32;
  native let indexBufferSize: Uint32;
  native let indexBufferOffset: Uint32;
}

public native class rendRenderMorphTargetMeshBlob extends IRenderResourceBlob {
  native let header: rendRenderMorphTargetMeshBlobHeader;
  native let baseBlob: ref<IRenderResourceBlob>;
}

public native struct rendRenderMorphTargetMeshBlobHeader {
  native let version: Uint32;
  native let numDiffs: Uint32;
  native let numDiffsMapping: Uint32;
  native let numTargets: Uint32;
  native let targetStartsInVertexDiffs: array<Uint32>;
  native let targetStartsInVertexDiffsMapping: array<Uint32>;
  native let targetPositionDiffScale: array<Vector4>;
  native let targetPositionDiffOffset: array<Vector4>;
  native let numVertexDiffsInEachChunk: array<array<Uint32>>;
  native let numVertexDiffsMappingInEachChunk: array<array<Uint32>>;
  native let targetTextureDiffsData: array<rendRenderMorphTargetMeshBlobTextureData>;
}

public native struct rendRenderMorphTargetMeshBlobTextureData {}

public abstract native class rendRenderMultilayerMaskBlob extends IRenderResourceBlob {
  native let header: rendRenderMultilayerMaskBlobHeader;
}

public native struct rendRenderMultilayerMaskBlobHeader {
  native let version: Uint32;
  native let atlasWidth: Uint32;
  native let atlasHeight: Uint32;
  native let numLayers: Uint32;
  native let maskWidth: Uint32;
  native let maskHeight: Uint32;
  native let maskWidthLow: Uint32;
  native let maskHeightLow: Uint32;
  native let maskTileSize: Uint32;
  native let flags: Uint32;
}

public native class rendRenderMultilayerMaskBlobPC extends rendRenderMultilayerMaskBlob {}

public native class rendRenderMultilayerMaskBlobProspero extends rendRenderMultilayerMaskBlob {}

public native class rendRenderMultilayerMaskBlobPS4 extends rendRenderMultilayerMaskBlob {}

public native class rendRenderMultilayerMaskBlobScarlett extends rendRenderMultilayerMaskBlob {}

public native class rendRenderMultilayerMaskBlobXboxOne extends rendRenderMultilayerMaskBlob {}

public native struct rendRenderMultilayerMaskResource {
  native let renderResourceBlobPC: ref<IRenderResourceBlob>;
}

public native class rendRenderParticleBlob extends IRenderResourceBlob {
  native let header: rendRenderParticleBlobHeader;
  native let updaterData: rendRenderParticleUpdaterData;
  native let gpuSimShaders: rendEmitterSimulationShaders;
}

public native struct rendRenderParticleBlobEmitterInfo {
  native let emitterHash: Uint64;
  native let diffuseWrapFactor: Float;
  native let backLightingFactor: Float;
  native let lightingMipBias: Uint32;
  native let maskInsideCar: Bool;
  native let maskInsideInterior: Bool;
  native let maskAboveWater: Bool;
  native let maskUnderWater: Bool;
  native let maxParticles: Uint32;
  native let emitterLoops: Int8;
  native let internalPriority: Uint8;
  native let keepSimulationLocal: Bool;
  native let killOnCollision: Bool;
  native let initialParticleCount: Uint8;
  native let useSubFrameEmission: Bool;
  native let windInfluence: Float;
  native let particleType: Uint32;
  native let vertexDrawerType: Uint32;
  native let simulationType: Uint32;
  native let envColorGroup: Uint32;
  native let emitterGroup: Uint32;
  native let renderObjectType: ERenderObjectType;
  native let numModifiers: Uint32;
  native let modifierSetMask: Uint64;
  native let numInitializers: Uint32;
  native let initializerSetMask: Uint64;
  native let simulationHash: Uint64;
  native let eventSetMask: Uint16;
  native let seeds: array<Uint32>;
  native let lods: array<rendEmitterLOD>;
  native let volumetricParticleEnabled: Bool;
  native let volumetricParticleRelative: Bool;
  native let volumetricParticleUseFogColor: Bool;
  native let volumetricParticleColor: HDRColor;
  native let volumetricParticleSize: Float;
  native let volumetricParticleDensity: Float;
  native let volumetricParticleFalloff: Float;
  native let volumetricParticleNoiseScale: Float;
  native let volumetricParticleNoiseThreshold: Float;
  native let volumetricParticleNoiseVelocity: Vector3;
}

public native struct rendRenderParticleBlobHeader {
  native let version: Uint32;
  native let emitterInfo: rendRenderParticleBlobEmitterInfo;
}

public native struct rendRenderParticleUpdaterData {
  native let modifOffset: Uint32;
  native let animFrameInit: array<Float>;
  native let turbulenceNoiseInterval: Float;
  native let turbulenceDuration: Float;
  native let collisionMask: Uint64;
  native let collisionDynamicFriction: Float;
  native let collisionStaticFriction: Float;
  native let collisionRestitution: Float;
  native let collisionVelocityDamp: Float;
  native let collisionDisableGravity: Bool;
  native let collisionRadius: Float;
  native let collisionEffectMask: Uint32;
  native let maxCollisions: Uint8;
  native let eventGenerate: CName;
  native let eventReceive: CName;
  native let eventFrequency: Float;
  native let eventProbability: Float;
  native let noiseType: Uint8;
  native let randomPerChannel: Bool;
  native let eventSpawnObject: Uint8;
}

public native struct rendRenderTextureBlobHeader {
  native let version: Uint32;
  native let sizeInfo: rendRenderTextureBlobSizeInfo;
  native let textureInfo: rendRenderTextureBlobTextureInfo;
  native let mipMapInfo: array<rendRenderTextureBlobMipMapInfo>;
  native let histogramData: array<rendHistogramBias>;
  native let flags: Uint32;
}

public native struct rendRenderTextureBlobMemoryLayout {
  native let rowPitch: Uint32;
  native let slicePitch: Uint32;
}

public native struct rendRenderTextureBlobMipMapInfo {
  native let layout: rendRenderTextureBlobMemoryLayout;
  native let placement: rendRenderTextureBlobPlacement;
}

public native class rendRenderTextureBlobPC extends rendIRenderTextureBlob {}

public native struct rendRenderTextureBlobPlacement {
  native let offset: Uint32;
  native let size: Uint32;
}

public native class rendRenderTextureBlobProspero extends rendIRenderTextureBlob {}

public native class rendRenderTextureBlobPS4 extends rendIRenderTextureBlob {}

public native class rendRenderTextureBlobScarlett extends rendIRenderTextureBlob {}

public native struct rendRenderTextureBlobSizeInfo {
  native let width: Uint16;
  native let height: Uint16;
  native let depth: Uint16;
}

public native class rendRenderTextureBlobStreamable extends rendIRenderTextureBlob {}

public native struct rendRenderTextureBlobTextureInfo {
  native let type: GpuWrapApieTextureType;
  native let textureDataSize: Uint32;
  native let sliceSize: Uint32;
  native let dataAlignment: Uint32;
  native let sliceCount: Uint16;
  native let mipCount: Uint8;
}

public native class rendRenderTextureBlobXboxOne extends rendIRenderTextureBlob {}

public native struct rendRenderTextureResource {
  native let renderResourceBlobPC: ref<IRenderResourceBlob>;
}

enum rendResolutionMultiplier {
  X1 = 1,
  X2 = 2,
  X4 = 4,
}

public native struct rendScreenshotBatchData {
  native let batchPositionsPath: AbsolutePathSerializable;
  native let delayTime: Float;
  native let numberOfCoordinatesToDump: Uint32;
  native let mergeScreenshots: Bool;
  native let streamingObserverMode: rendEStreamingObserverMode;
}

enum rendScreenshotMode {
  NONE = 0,
  NORMAL = 1,
  NORMAL_MULTISAMPLE = 2,
  LAYERED = 4,
  HIGH_RESOLUTION = 5,
  HIGH_RESOLUTION_LAYERED = 6,
}

public native class rendSingleScreenShotData extends ISerializable {
  native let mode: rendScreenshotMode;
  native let outputPath: AbsolutePathSerializable;
  native let resolution: renddimEPreset;
  native let resolutionMultiplier: rendResolutionMultiplier;
  native let emmModes: array<EEnvManagerModifier>;
  native let forceLOD0: Bool;
  native let saveFormat: ESaveFormat;
}

public native struct rendSLightFlickering {
  native let positionOffset: Float;
  native let flickerStrength: Float;
  native let flickerPeriod: Float;
}

public native class rendTextureRegion extends ISerializable {
  native let name: CName;
  native let isStretch: Bool;
  native let regionParts: array<rendTextureRegionPart>;
}

public native class rendTextureRegionPart extends ISerializable {
  native let innerRegion: Vector4;
  native let outerRegion: Vector4;
}

public native struct rendTopologyData {
  native let data: array<Uint8>;
  native let metadata: array<Uint8>;
  native let dataStride: Uint32;
  native let metadataStride: Uint32;
}

public native struct rendVertexBufferChunk {
  native let vertexLayout: GpuWrapApiVertexLayoutDesc;
}

enum rendWindShapeAnchorPointDepth {
  AP_CENTER = 0,
  AP_FRONT = 1,
  AP_BACK = 2,
}

enum rendWindShapeAnchorPointHorz {
  AP_CENTER = 0,
  AP_RIGHT = 1,
  AP_LEFT = 2,
}

enum rendWindShapeAnchorPointVert {
  AP_CENTER = 0,
  AP_TOP = 1,
  AP_BOTTOM = 2,
}

public native class RequestNewHudEvent extends Event {
  native let entriesResource: ResourceRef; // rRef<inkHudEntriesResource>
}

public native class resDlcManifest extends CResource {
  native let tweakBlob: ResourceAsyncRef; // raRef<CResource>
  native let quest: ResourceAsyncRef; // raRef<CResource>
  native let journal: ResourceAsyncRef; // raRef<CResource>
  native let factories: ResourceAsyncRef; // raRef<CResource>
  native let weaponAppearances: ResourceAsyncRef; // raRef<CResource>
  native let vehicleAppearances: ResourceAsyncRef; // raRef<CResource>
  native let communitySpawnsets: ResourceAsyncRef; // raRef<CResource>
  native let archetypeSet: ResourceAsyncRef; // raRef<CResource>
  native let vehicleCovers: ResourceAsyncRef; // raRef<CResource>
  native let cookedAudioMetadata: ResourceAsyncRef; // raRef<CResource>
  native let voiceTags: ResourceAsyncRef; // raRef<CResource>
  native let widgetsLibrariesOverrides: ResourceAsyncRef; // raRef<CResource>
  native let gameDefsList: ResourceAsyncRef; // raRef<CResource>
  native let cookedMultilayerSetup: ResourceAsyncRef; // raRef<CResource>
  native let visualTagsToAppearanceNames: ResourceAsyncRef; // raRef<CResource>
  native let appearanceNameToVisualTags: ResourceAsyncRef; // raRef<CResource>
  native let defaultAppearances: ResourceAsyncRef; // raRef<CResource>
  native let colorVariantsMap: ResourceAsyncRef; // raRef<CResource>
}

public native class ResetStickersEvent extends Event {}

public abstract native struct resIStreamedResourceDataExtractor {}

public native class resResourceSnapshot extends CResource {
  native let resources: array<ResourceAsyncRef>;
}

public abstract native class resStreamedResource extends CResource {}

public native class RichPresenceSystem extends IRichPresenceSystem {
  public final native func SetRichPresence()
}

public importonly native struct RoachRaceChunk {
  native let obstacles: array<RoachRaceObstacle>;
}

public importonly native struct RoachRaceChunkLayer {
  native let chunks: array<RoachRaceChunk>;
}

public native class RoachRaceMinigameDynObject extends MinigameDynObject {
  native let minSpawnY: Float;
  native let maxSpawnY: Float;
  native let extraSpeed: Float;
  native let availableY: array<Float>;
}

public importonly native struct RoachRaceObstacle {
  native let interval: Float;
  native let dynObjectType: CName;
}

public native class RPGPrereqState extends PrereqState {}

public native class RTAOAreaSettings extends IAreaSettings {
  native let RangeNear: CurveDataFloat;
  native let RangeFar: CurveDataFloat;
  native let RadiusNear: CurveDataFloat;
  native let RadiusFar: CurveDataFloat;
  native let coneAoDiffuseStrength: CurveDataFloat;
  native let coneAoSpecularStrength: CurveDataFloat;
  native let coneAoSpecularTreshold: CurveDataFloat;
  native let lightAoDiffuseStrength: CurveDataFloat;
  native let lightAoSpecularStrength: CurveDataFloat;
}

public native class RTXDIAreaSettings extends IAreaSettings {
  native let diffuseSkyScale: Float;
  native let specularSkyScale: Float;
}

public native class RunAwayEvent extends AIEvent {}

public native struct Sample_All_Supported_Replicated_Types {
  native let bool: Bool;
  native let uint8: Uint8;
  native let int8: Int8;
  native let uint16: Uint16;
  native let int16: Int16;
  native let uint32: Uint32;
  native let int32: Int32;
  native let uint64: Uint64;
  native let int64: Int64;
  native let float: Float;
  native let double: Double;
  native let name: CName;
  native let string: String;
  native let enum: Sample_Replicated_Enum;
  native let struct: Sample_Replicated_Struct;
  native let dynamicArray: array<Sample_Replicated_Struct>;
  native let THandle: ref<Sample_Replicated_Serializable>;
}

public native struct Sample_Basic_Replicated_Property {
  native let property: Bool;
}

public native struct Sample_Replicated_Double_Property {
  native let property: Double;
}

public native struct Sample_Replicated_Dynamic_Array_Property {
  native let property: array<String>;
}

public native struct Sample_Replicated_Dynamic_Map_Array_Property {
  native let property: array<SampleMapArrayElement>;
}

enum Sample_Replicated_Enum {
  One = 0,
  Two = 1,
  Three = 2,
}

public native struct Sample_Replicated_Float_Property {
  native let property: Float;
}

public native struct Sample_Replicated_Int_Property {
  native let property: Int32;
}

public native struct Sample_Replicated_Pointed_Class {
  native let property: Bool;
}

public native struct Sample_Replicated_Root_Object {
  native let bool: Bool;
}

public native class Sample_Replicated_Serializable extends ISerializable {
  native let property: Bool;
}

public native struct Sample_Replicated_String_Property {
  native let property: String;
}

public native struct Sample_Replicated_Struct {
  native let a: Bool;
  native let b: Bool;
  native let c: Bool;
  native let d_not_replicated_still_OK: Bool;
}

public native struct Sample_Replicated_THandle_Property {
  native let property: ref<Sample_Replicated_Serializable>;
}

public native struct Sample_Replicated_Unique_Pointer_Property {}

public native class Sample_RPC_Class extends IScriptable {
  public final native func SampleRPCMethod()
}

public native struct SampleMapArrayElement {
  native let myKey: Uint32;
  native let someStringProperty: String;
  native let someArrayProperty: array<String>;
}

public native struct SamplerStateInfo {
  native let filteringMin: ETextureFilteringMin;
  native let filteringMag: ETextureFilteringMag;
  native let filteringMip: ETextureFilteringMip;
  native let addressU: ETextureAddressing;
  native let addressV: ETextureAddressing;
  native let addressW: ETextureAddressing;
  native let comparisonFunc: ETextureComparisonFunction;
  native let register: Uint8;
}

enum SAnimationBufferBitwiseCompression {
  ABBC_None = 0,
  ABBC_24b = 1,
  ABBC_16b = 2,
}

enum SAnimationBufferBitwiseCompressionPreset {
  ABBCP_Custom = 0,
  ABBCP_VeryHighQuality = 1,
  ABBCP_HighQuality = 2,
  ABBCP_NormalQuality = 3,
  ABBCP_LowQuality = 4,
  ABBCP_VeryLowQuality = 5,
  ABBCP_Raw = 6,
}

enum SAnimationBufferDataCompressionMethod {
  ABDCM_Invalid = 0,
  ABDCM_Plain = 1,
  ABDCM_Quaternion = 2,
  ABDCM_QuaternionXYZSignedW = 3,
  ABDCM_QuaternionXYZSignedWLastBit = 4,
  ABDCM_Quaternion48b = 5,
  ABDCM_Quaternion40b = 6,
  ABDCM_Quaternion32b = 7,
  ABDCM_Quaternion64bW = 8,
  ABDCM_Quaternion48bW = 9,
  ABDCM_Quaternion40bW = 10,
}

enum SAnimationBufferOrientationCompressionMethod {
  ABOCM_PackIn64bitsW = 0,
  ABOCM_PackIn48bitsW = 1,
  ABOCM_PackIn40bitsW = 2,
  ABOCM_AsFloat_XYZW = 3,
  ABOCM_AsFloat_XYZSignedW = 4,
  ABOCM_AsFloat_XYZSignedWInLastBit = 5,
  ABOCM_PackIn48bits = 6,
  ABOCM_PackIn40bits = 7,
  ABOCM_PackIn32bits = 8,
}

enum SAnimationBufferStreamingOption {
  ABSO_NonStreamable = 0,
  ABSO_PartiallyStreamable = 1,
  ABSO_FullyStreamable = 2,
}

public native struct saveGameMetadata {
  native let gameDefinition: String;
  native let activeQuests: String;
  native let trackedQuestEntry: String;
  native let trackedQuest: String;
  native let mainQuest: String;
  native let debugString: String;
  native let locationName: String;
  native let playerPosition: Vector3;
  native let playTime: Double;
  native let playthroughTime: Double;
  native let nextSavableEntityID: Uint32;
  native let nextNonSavableEntityID: Uint32;
  native let lifePath: gamedataLifePath;
  native let bodyGender: String;
  native let brainGender: String;
  native let level: Float;
  native let streetCred: Float;
  native let gunslinger: Float;
  native let assault: Float;
  native let demolition: Float;
  native let athletics: Float;
  native let brawling: Float;
  native let coldBlood: Float;
  native let stealth: Float;
  native let engineering: Float;
  native let crafting: Float;
  native let hacking: Float;
  native let combatHacking: Float;
  native let strength: Float;
  native let intelligence: Float;
  native let reflexes: Float;
  native let technicalAbility: Float;
  native let cool: Float;
  native let initialBuildID: String;
  native let finishedQuests: String;
  native let playthroughID: String;
  native let pointOfNoReturnId: String;
  native let visitID: String;
  native let buildSKU: String;
  native let buildPatch: String;
  native let difficulty: gameDifficulty;
  native let facts: array<String>;
}

public native class saveMetadataContainer extends ISerializable {
  native let metadata: saveMetadata;
}

public native class SaveSanitizationForbiddenAreaSystem extends gameISaveSanitizationForbiddenAreaSystem {}

public importonly native class ScanningActivatorComponent extends IComponent {}

public native struct scnActorDef {
  native let actorId: scnActorId;
  native let voicetagId: scnVoicetagId;
  native let acquisitionPlan: scnEntityAcquisitionPlan;
  native let findActorInContextParams: scnFindEntityInContextParams;
  native let findActorInWorldParams: scnFindEntityInWorldParams;
  native let spawnDespawnParams: scnSpawnDespawnEntityParams;
  native let spawnSetParams: scnSpawnSetParams;
  native let communityParams: scnCommunityParams;
  native let spawnerParams: scnSpawnerParams;
  native let animSets: array<scnSRRefId>;
  native let lipsyncAnimSet: scnLipsyncAnimSetSRRefId;
  native let facialAnimSets: array<scnRidFacialAnimSetSRRefId>;
  native let cyberwareAnimSets: array<scnRidCyberwareAnimSetSRRefId>;
  native let deformationAnimSets: array<scnRidDeformationAnimSetSRRefId>;
  native let bodyCinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let facialCinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let cyberwareCinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let dynamicAnimSets: array<scnDynamicAnimSetSRRefId>;
  native let holocallInitScn: ResourceAsyncRef; // raRef<CResource>
  native let actorName: String;
  native let specCharacterRecordId: TweakDBID;
  native let specAppearance: CName;
}

public native struct scnActorId {
  native let id: Uint32;
}

public native struct scnActorRid {
  native let tag: scnRidTag;
  native let animations: array<scnAnimationRid>;
  native let facialAnimations: array<scnAnimationRid>;
  native let cyberwareAnimations: array<scnAnimationRid>;
}

public native class scnAddIdleAnimEvent extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let actorComponent: CName;
  native let weight: Float;
}

public native class scnAddIdleWithBlendAnimEvent extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let actorComponent: CName;
  native let targetWeight: Float;
}

public native struct scnAdditionalSpeaker {
  native let actorId: scnActorId;
  native let type: scnAdditionalSpeakerType;
}

enum scnAdditionalSpeakerRole {
  Full = 0,
  OnlyLipsync = 1,
}

public native struct scnAdditionalSpeakers {
  native let executionTag: Uint8;
  native let role: scnAdditionalSpeakerRole;
  native let speakers: array<scnAdditionalSpeaker>;
}

enum scnAdditionalSpeakerType {
  Normal = 0,
  Holocall = 1,
}

public native class scnAndNode extends scnSceneGraphNode {
  native let numInSockets: Uint32;
}

enum scnAnimationCategory {
  Body = 0,
  Facial = 1,
  Cyberware = 2,
}

public native struct scnAnimationMotionSample {
  native let time: Float;
  native let transform: Transform;
}

public native struct scnAnimationRid {
  native let tag: scnRidTag;
  native let animation: ref<animAnimation>;
  native let events: ref<animEventsContainer>;
  native let motionExtracted: Bool;
  native let offset: Transform;
  native let bonesCount: Uint32;
  native let trajectoryBoneIndex: Int32;
}

public native class scnAnimationRidAudioData extends ISerializable {
  native let events: array<ref<animAnimEvent>>;
}

public native class scnAnimName extends ISerializable {
  native let type: scnAnimNameType;
}

enum scnAnimNameType {
  direct = 0,
  reference = 1,
  container = 2,
  dynamic = 3,
}

public native struct scnAnimSetAnimNames {
  native let animationNames: array<CName>;
}

public native struct scnAnimSetDynAnimNames {
  native let animNames: array<CName>;
}

public native struct scnAnimTargetBasicData {
  native let performerId: scnPerformerId;
  native let isStart: Bool;
  native let targetPerformerId: scnPerformerId;
  native let targetSlot: CName;
  native let targetOffsetEntitySpace: Vector4;
  native let staticTarget: Vector4;
  native let targetActorId: scnActorId;
  native let targetPropId: scnPropId;
  native let targetType: scnLookAtTargetType;
}

public native class scnAudioDurationEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let audioEventName: CName;
  native let playbackDirectionSupport: scnAudioPlaybackDirectionSupportFlag;
}

public native class scnAudioEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let audioEventName: CName;
  native let ambientUniqueName: CName;
  native let emitterName: CName;
  native let fastForwardSupport: scnAudioFastForwardSupport;
}

enum scnAudioFastForwardSupport {
  MuteDuringFastForward = 1,
  DontMuteDuringFastForward = 2,
}

enum scnAudioPlaybackDirectionSupportFlag {
  Forward = 1,
  Backward = 2,
}

enum scnblocLocaleId {
  db_db = 0,
  pl_pl = 1,
  en_us = 2,
}

public native class scnBraindanceJumpInProgress_ConditionType extends scnIBraindanceConditionType {
  native let inProgress: Bool;
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

public native class scnBraindanceLayer_ConditionType extends scnIBraindanceConditionType {
  native let layer: scnBraindanceLayer;
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

enum scnBraindanceLayer {
  Visual = 0,
  Audio = 1,
  Thermal = 2,
}

public native class scnBraindancePaused_ConditionType extends scnIBraindanceConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

public native class scnBraindancePerspective_ConditionType extends scnIBraindanceConditionType {
  native let perspective: scnBraindancePerspective;
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

enum scnBraindancePerspective {
  FirstPerson = 0,
  ThirdPerson = 1,
}

public native class scnBraindancePlaying_ConditionType extends scnIBraindanceConditionType {
  native let speed: scnBraindanceSpeed;
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

public native class scnBraindanceResetting_ConditionType extends scnIBraindanceConditionType {
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

public native class scnBraindanceRewinding_ConditionType extends scnIBraindanceConditionType {
  native let speed: scnBraindanceSpeed;
  native let sceneFile: ResourceAsyncRef; // raRef<scnSceneResource>
  native let SceneVersion: scnSceneVersionCheck;
}

enum scnBraindanceSpeed {
  Any = 0,
  Slow = 1,
  Normal = 2,
  Fast = 3,
  VeryFast = 4,
}

public native struct scnCameraAnimationLOD {}

public native struct scnCameraAnimationRid {
  native let tag: scnRidTag;
  native let animation: ref<animIAnimationBuffer>;
  native let cameraAnimationLOD: scnCameraAnimationLOD;
}

public native struct scnCameraRid {
  native let tag: scnRidTag;
  native let animations: array<scnCameraAnimationRid>;
}

public native class scnChangeIdleAnimEvent extends scnPlayAnimEvent {
  native let idleAnimName: CName;
  native let addIdleAnimName: CName;
  native let isEnabled: Bool;
  native let animName: CName;
  native let bakedFacialTransition: animFacialEmotionTransitionBaked;
  native let facialInstantTransition: Bool;
}

public native class scnChatterModuleSharedState extends ISerializable {
  native let chatterHistory: array<ref<scnChatter>>;
}

public native class scnCheckAnyoneDistractedInterruptCondition extends scnIInterruptCondition {}

public native class scnCheckDistractedReturnCondition extends scnIReturnCondition {
  native let params: scnCheckDistractedReturnConditionParams;
}

public native struct scnCheckDistractedReturnConditionParams {
  native let distracted: Bool;
  native let target: scnDistractedConditionTarget;
}

public native class scnCheckFactInterruptCondition extends scnIInterruptCondition {
  native let params: scnCheckFactInterruptConditionParams;
}

public native struct scnCheckFactInterruptConditionParams {
  native let factCondition: ref<scnInterruptFactConditionType>;
}

public native class scnCheckFactReturnCondition extends scnIReturnCondition {
  native let params: scnCheckFactReturnConditionParams;
}

public native struct scnCheckFactReturnConditionParams {
  native let factCondition: ref<scnInterruptFactConditionType>;
}

public native class scnCheckMountedVehicleImpactInterruptCondition extends scnIInterruptCondition {}

public native class scnCheckPlayerCombatInterruptCondition extends scnIInterruptCondition {
  native let params: scnCheckPlayerCombatInterruptConditionParams;
}

public native struct scnCheckPlayerCombatInterruptConditionParams {
  native let isInCombat: Bool;
}

public native class scnCheckPlayerCombatReturnCondition extends scnIReturnCondition {
  native let params: scnCheckPlayerCombatReturnConditionParams;
}

public native struct scnCheckPlayerCombatReturnConditionParams {
  native let isInCombat: Bool;
}

public native class scnCheckPlayerTargetEntityDistanceInterruptCondition extends scnIInterruptCondition {
  native let params: scnCheckPlayerTargetEntityDistanceInterruptConditionParams;
}

public native struct scnCheckPlayerTargetEntityDistanceInterruptConditionParams {
  native let distance: Float;
  native let comparisonType: EComparisonType;
  native let targetEntity: EntityReference;
}

public native class scnCheckPlayerTargetEntityDistanceReturnCondition extends scnIReturnCondition {
  native let params: scnCheckPlayerTargetEntityDistanceReturnConditionParams;
}

public native struct scnCheckPlayerTargetEntityDistanceReturnConditionParams {
  native let distance: Float;
  native let comparisonType: EComparisonType;
  native let targetEntity: EntityReference;
}

public native class scnCheckPlayerTargetNodeDistanceInterruptCondition extends scnIInterruptCondition {
  native let params: scnCheckPlayerTargetNodeDistanceInterruptConditionParams;
}

public native struct scnCheckPlayerTargetNodeDistanceInterruptConditionParams {
  native let distance: Float;
  native let comparisonType: EComparisonType;
  native let targetNode: NodeRef;
}

public native class scnCheckPlayerTargetNodeDistanceReturnCondition extends scnIReturnCondition {
  native let params: scnCheckPlayerTargetNodeDistanceReturnConditionParams;
}

public native struct scnCheckPlayerTargetNodeDistanceReturnConditionParams {
  native let distance: Float;
  native let comparisonType: EComparisonType;
  native let targetNode: NodeRef;
}

public native class scnCheckSpeakerDistractedInterruptCondition extends scnIInterruptCondition {}

public native class scnCheckSpeakerOrAddressDistractedInterruptCondition extends scnIInterruptCondition {}

public native class scnCheckSpeakersDistanceInterruptCondition extends scnIInterruptCondition {
  native let params: scnCheckSpeakersDistanceInterruptConditionParams;
}

public native struct scnCheckSpeakersDistanceInterruptConditionParams {
  native let distance: Float;
  native let comparisonType: EComparisonType;
}

public native class scnCheckSpeakersDistanceReturnCondition extends scnIReturnCondition {
  native let params: scnCheckSpeakersDistanceReturnConditionParams;
}

public native struct scnCheckSpeakersDistanceReturnConditionParams {
  native let distance: Float;
  native let comparisonType: EComparisonType;
}

public native class scnCheckTriggerInterruptCondition extends scnIInterruptCondition {
  native let params: scnCheckTriggerInterruptConditionParams;
}

public native struct scnCheckTriggerInterruptConditionParams {
  native let inside: Bool;
  native let triggerArea: NodeRef;
}

public native class scnCheckTriggerReturnCondition extends scnIReturnCondition {
  native let params: scnCheckTriggerReturnConditionParams;
}

public native struct scnCheckTriggerReturnConditionParams {
  native let inside: Bool;
  native let triggerArea: NodeRef;
}

public native struct scnChoiceHubPartId {
  native let id: Uint32;
}

public native class scnChoiceNode extends scnSceneGraphNode {
  native let displayNameOverride: String;
  native let localizedDisplayNameOverride: LocalizationString;
  native let options: array<scnChoiceNodeOption>;
  native let mode: scnChoiceNodeNsOperationMode;
  native let persistentLineEvents: array<scnSceneEventId>;
  native let customPersistentLine: scnscreenplayItemId;
  native let timedParams: ref<scnChoiceNodeNsTimedParams>;
  native let reminderParams: ref<scnChoiceNodeNsActorReminderParams>;
  native let shapeParams: ref<scnInteractionShapeParams>;
  native let lookAtParams: ref<scnChoiceNodeNsLookAtParams>;
  native let forceAttachToScreenCondition: ref<questIBaseCondition>;
  native let choiceGroup: CName;
  native let cpoHoldInputActionSection: Bool;
  native let doNotTurnOffPreventionSystem: Bool;
  native let ataParams: scnChoiceNodeNsAttachToActorParams;
  native let atpParams: scnChoiceNodeNsAttachToPropParams;
  native let atgoParams: scnChoiceNodeNsAttachToGameObjectParams;
  native let atsParams: scnChoiceNodeNsAttachToScreenParams;
  native let atwParams: scnChoiceNodeNsAttachToWorldParams;
  native let choicePriority: Uint8;
  native let hubPriority: Uint8;
  native let mappinParams: ref<scnChoiceNodeNsMappinParams>;
  native let interruptCapability: scnInterruptCapability;
  native let interruptionSpeakerOverride: scnActorId;
  native let alwaysUseBrainGender: Bool;
  native let timedSectionCondition: ref<scnTimedCondition>;
  native let reminderCondition: ref<scnReminderCondition>;
}

public native class scnChoiceNodeNsActorReminderParams extends ISerializable {
  native let useCustomReminder: Bool;
  native let reminderActor: scnActorId;
  native let waitTimeForReminderA: scnSceneTime;
  native let waitTimeForReminderB: scnSceneTime;
  native let waitTimeForReminderC: scnSceneTime;
  native let waitTimeForLooping: scnSceneTime;
  native let cutReminderEnabled: Bool;
  native let waitTimeToCutReminder: Float;
}

public native class scnChoiceNodeNsAdaptiveLookAtParams extends scnChoiceNodeNsLookAtParams {
  native let nearbySlotName: CName;
  native let distantSlotName: CName;
  native let blendLimit: Float;
  native let referencePointFullEffectAngle: Float;
  native let referencePointNoEffectAngle: Float;
  native let referencePointFullEffectDistance: Float;
  native let referencePointNoEffectDistance: Float;
  native let referencePoints: array<scnChoiceNodeNsAdaptiveLookAtReferencePoint>;
  native let auxiliaryRelativePoint: Vector3;
}

public native struct scnChoiceNodeNsAdaptiveLookAtReferencePoint {
  native let referencePoint: scnReferencePointId;
  native let constantWeight: Float;
}

public native struct scnChoiceNodeNsAttachToActorParams {
  native let actorId: scnActorId;
  native let visualizerStyle: scnChoiceNodeNsVisualizerStyle;
}

public native struct scnChoiceNodeNsAttachToGameObjectParams {
  native let nodeRef: NodeRef;
  native let visualizerStyle: scnChoiceNodeNsVisualizerStyle;
}

public native struct scnChoiceNodeNsAttachToPropParams {
  native let propId: scnPropId;
  native let visualizerStyle: scnChoiceNodeNsVisualizerStyle;
}

public native struct scnChoiceNodeNsAttachToScreenParams {}

public native struct scnChoiceNodeNsAttachToWorldParams {
  native let entityPosition: Vector3;
  native let entityOrientation: Quaternion;
  native let customEntityRadius: Float;
  native let visualizerStyle: scnChoiceNodeNsVisualizerStyle;
}

public native class scnChoiceNodeNsBasicLookAtParams extends scnChoiceNodeNsLookAtParams {
  native let slotName: CName;
  native let offset: Vector3;
}

enum scnChoiceNodeNsChoiceNodeFlags {
  IsFocusClue = 1,
  IsValidInteractionFailsafeDisabled = 2,
}

public native struct scnChoiceNodeNsDeprecatedParams {
  native let actorId: scnActorId;
  native let propId: scnPropId;
}

public abstract native class scnChoiceNodeNsLookAtParams extends ISerializable {}

enum scnChoiceNodeNsMappinLocation {
  None = 0,
  Interaction = 1,
  Nameplate = 2,
  ObjectDefault = 4,
}

public native class scnChoiceNodeNsMappinParams extends ISerializable {
  native let locationType: scnChoiceNodeNsMappinLocation;
  native let mappinSettings: TweakDBID;
}

enum scnChoiceNodeNsOperationMode {
  attachToActor = 0,
  attachToProp = 1,
  attachToGameObject = 2,
  attachToScreen = 3,
  attachToWorld = 4,
}

public native struct scnChoiceNodeNsReminderParams {
  native let reminderEnabled: Bool;
  native let useCustomReminder: Bool;
  native let reminderActor: scnActorId;
  native let waitTimeForReminderA: scnSceneTime;
  native let waitTimeForReminderB: scnSceneTime;
  native let waitTimeForReminderC: scnSceneTime;
  native let waitTimeForLooping: scnSceneTime;
}

enum scnChoiceNodeNsSizePreset {
  small = 0,
  normal = 1,
  big = 2,
  Dialogue = 3,
  Interaction = 4,
  Dialogue360 = 5,
}

enum scnChoiceNodeNsTimedAction {
  appear = 0,
  disappear = 1,
  disappearFading = 2,
}

public native class scnChoiceNodeNsTimedParams extends ISerializable {
  native let action: scnChoiceNodeNsTimedAction;
  native let timeLimitedFinish: Bool;
  native let duration: scnSceneTime;
}

enum scnChoiceNodeNsVisualizerStyle {
  onScreen = 0,
  inWorld = 1,
}

public native struct scnChoiceNodeOption {
  native let screenplayOptionId: scnscreenplayItemId;
  native let caption: CName;
  native let blueline: Bool;
  native let isFixedAsRead: Bool;
  native let isSingleChoice: Bool;
  native let type: ChoiceTypeWrapper;
  native let timedParams: ref<scnChoiceNodeNsTimedParams>;
  native let questCondition: ref<questIBaseCondition>;
  native let triggerCondition: ref<questIBaseCondition>;
  native let bluelineCondition: ref<questIBaseCondition>;
  native let emphasisCondition: ref<questIBaseCondition>;
  native let iconCondition: ref<questIBaseCondition>;
  native let gameplayAction: TweakDBID;
  native let iconTagIds: array<TweakDBID>;
  native let exDataFlags: Uint32;
  native let mappinReferencePointId: scnReferencePointId;
  native let timedCondition: ref<scnTimedCondition>;
}

public native struct scnCinematicAnimSetSRRef {
  native let asyncAnimSet: ResourceAsyncRef; // raRef<animAnimSet>
  native let priority: Uint8;
  native let isOverride: Bool;
}

public native struct scnCinematicAnimSetSRRefId {
  native let id: Uint32;
}

public native struct scnCommunityParams {
  native let reference: NodeRef;
  native let entryName: CName;
  native let forceMaxVisibility: Bool;
}

enum scnContextualActorName {
  Player = 0,
  VoicesetHolder = 1,
  Voice = 2,
  SpecificVoicetagHolder = 3,
  ContextActorName = 4,
}

public native class scnCutControlNode extends scnSceneGraphNode {}

public native struct scnDebugSymbols {
  native let performersDebugSymbols: array<scnPerformerSymbol>;
  native let workspotsDebugSymbols: array<scnWorkspotSymbol>;
  native let sceneEventsDebugSymbols: array<scnSceneEventSymbol>;
  native let sceneNodesDebugSymbols: array<scnNodeSymbol>;
}

public native class scnDeletionMarkerNode extends scnSceneGraphNode {}

public native struct scndevEvent {
  native let nodeId: scnNodeId;
  native let type: scndevEventType;
  native let message: String;
}

enum scndevEventType {
  NodeFailed = 1,
  DebugMessage = 0,
  NodeProgressSet = 2,
}

public native struct scnDialogLineDuplicationParams {
  native let executionTag: Uint8;
  native let additionalSpeakerId: scnActorId;
  native let isHolocallSpeaker: Bool;
}

public native class scnDialogLineEvent extends scnSceneEvent {
  native let screenplayLineId: scnscreenplayItemId;
  native let voParams: scnDialogLineVoParams;
  native let visualStyle: scnDialogLineVisualStyle;
  native let additionalSpeakers: scnAdditionalSpeakers;
}

enum scnDialogLineVisualStyle {
  regular = 0,
  overHead = 1,
  radio = 2,
  globalTV = 3,
  invisible = 4,
  innerDialog = 5,
  overHeadAlwaysVisible = 6,
  alwaysCinematicNoSpeaker = 7,
  globalTVAlwaysVisible = 8,
  narrator = 9,
}

public native struct scnDialogLineVoParams {
  native let voContext: locVoiceoverContext;
  native let voExpression: locVoiceoverExpression;
  native let customVoEvent: CName;
  native let disableHeadMovement: Bool;
  native let isHolocallSpeaker: Bool;
  native let ignoreSpeakerIncapacitation: Bool;
  native let alwaysUseBrainGender: Bool;
}

enum scnDistractedConditionTarget {
  Anyone = 0,
  Speaker = 1,
  SpeakerOrAddressee = 2,
}

public native class scnDummyAlwaysTrueReturnCondition extends scnIReturnCondition {}

public native struct scnDynamicAnimSetSRRef {
  native let asyncAnimSet: ResourceAsyncRef; // raRef<animAnimSet>
}

public native struct scnDynamicAnimSetSRRefId {
  native let id: Uint32;
}

enum scnEasingType {
  Linear = 0,
  SinusoidalEaseInOut = 1,
  QuadraticEaseIn = 2,
  QuadraticEaseOut = 3,
  CubicEaseInOut = 4,
  CubicEaseIn = 5,
  CubicEaseOut = 6,
}

public native struct scnEffectDef {
  native let id: scnEffectId;
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
}

public native struct scnEffectEntry {
  native let effectInstanceId: scnEffectInstanceId;
  native let effectName: CName;
}

public native struct scnEffectId {
  native let id: Uint32;
}

public native struct scnEffectInstance {
  native let effectInstanceId: scnEffectInstanceId;
  native let compiledEffect: worldCompiledEffectInfo;
}

public native struct scnEffectInstanceId {
  native let effectId: scnEffectId;
  native let id: Uint32;
}

public native class scnEndNode extends scnSceneGraphNode {
  native let type: scnEndNodeNsType;
}

enum scnEndNodeNsType {
  Terminating = 0,
  NonTerminating = 1,
}

enum scnEntityAcquisitionPlan {
  findInContext = 1,
  findInWorld = 2,
  spawnDespawn = 3,
  findInEntity = 4,
  spawnSet = 5,
  community = 6,
  spawner = 7,
  findNetworkPlayer = 9,
  findInNode = 8,
}

public native class scnEntityItemsListener extends AttachmentSlotsListener {}

public native struct scnEntryPoint {
  native let name: CName;
  native let nodeId: scnNodeId;
}

public native class scnEventBlendWorkspotSetupParameters extends ISerializable {
  native let workspotId: scnSceneWorkspotInstanceId;
  native let sequenceEntryId: WorkEntryId;
  native let idleOnlyMode: Bool;
  native let workExcludedGestures: array<WorkEntryId>;
  native let itemOverride: workWorkspotItemOverride;
}

public native class scneventsAttachPropToNode extends scnSceneEvent {
  native let propId: scnPropId;
  native let nodeRef: NodeRef;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
}

public native class scneventsAttachPropToPerformer extends scnSceneEvent {
  native let propId: scnPropId;
  native let performerId: scnPerformerId;
  native let slot: CName;
  native let offsetMode: scnOffsetMode;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
  native let fallbackData: array<scneventsAttachPropToPerformerFallbackData>;
}

public native struct scneventsAttachPropToPerformerCachedFallbackBone {
  native let boneName: CName;
  native let modelSpaceTransform: Transform;
}

public native struct scneventsAttachPropToPerformerFallbackData {
  native let owner: scnPerformerId;
  native let fallbackAnimset: ResourceRef; // rRef<animAnimSet>
  native let fallbackAnimationName: CName;
  native let fallbackAnimTime: Float;
}

public native class scneventsAttachPropToWorld extends scnSceneEvent {
  native let propId: scnPropId;
  native let offsetMode: scnOffsetMode;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
  native let referencePerformer: scnPerformerId;
  native let referencePerformerSlotId: TweakDBID;
  native let referencePerformerItemId: TweakDBID;
  native let fallbackData: array<scneventsAttachPropToWorldFallbackData>;
}

public native struct scneventsAttachPropToWorldCachedFallbackBone {
  native let boneName: CName;
  native let modelSpaceTransform: Transform;
}

public native struct scneventsAttachPropToWorldFallbackData {
  native let owner: scnPerformerId;
  native let fallbackAnimset: ResourceRef; // rRef<animAnimSet>
  native let fallbackAnimationName: CName;
  native let fallbackAnimTime: Float;
}

public native class scneventsBraindanceVisibilityEvent extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let customMaterialParam: ECustomMaterialParam;
  native let parameterIndex: Uint32;
  native let override: Bool;
  native let priority: Uint8;
  native let eventStartEndBlend: Float;
  native let perspectiveBlend: Float;
  native let renderSettingsFPP: WorldRenderAreaSettings;
  native let renderSettingsTPP: WorldRenderAreaSettings;
}

public native class scneventsCameraEvent extends scnSceneEvent {
  native let cameraRef: NodeRef;
  native let isBlendIn: Bool;
  native let blendTime: Float;
}

public native struct scneventsCameraOverrideSettings {
  native let overrideFov: Bool;
  native let overrideDof: Bool;
  native let resetFov: Bool;
  native let resetDof: Bool;
}

public native class scneventsCameraParamsEvent extends scnSceneEvent {
  native let cameraRef: NodeRef;
  native let fovValue: Float;
  native let fovWeigh: Float;
  native let dofIntensity: Float;
  native let dofNearBlur: Float;
  native let dofNearFocus: Float;
  native let dofFarBlur: Float;
  native let dofFarFocus: Float;
  native let useNearPlane: Bool;
  native let useFarPlane: Bool;
  native let isPlayerCamera: Bool;
  native let cameraOverrideSettings: scneventsCameraOverrideSettings;
  native let targetActor: scnPerformerId;
  native let targetSlot: CName;
}

public native class scneventsCameraPlacementEvent extends scnSceneEvent {
  native let cameraRef: NodeRef;
  native let cameraTransformLS: Transform;
}

public native class scneventsClueEvent extends scnSceneEvent {
  native let clueEntity: EntityReference;
  native let markedOnTimeline: Bool;
  native let clueName: CName;
  native let layer: gameuiEBraindanceLayer;
  native let overrideFact: Bool;
  native let factName: CName;
}

public native class scneventsDespawnEntityEvent extends scnSceneEvent {
  native let params: scneventsDespawnEntityEventParams;
}

public native struct scneventsDespawnEntityEventParams {
  native let performer: scnPerformerId;
}

public native class scneventsEquipItemToPerformer extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let slotId: TweakDBID;
  native let itemId: TweakDBID;
}

public native class scneventsMountEvent extends scnSceneEvent {
  native let parent: scnPerformerId;
  native let child: scnPerformerId;
  native let slotName: CName;
  native let carryStyle: gamePSMBodyCarryingStyle;
  native let isInstant: Bool;
  native let removePitchRollRotationOnDismount: Bool;
  native let keepTransform: Bool;
  native let isCarrying: Bool;
  native let switchRenderPlane: Bool;
}

public native struct scneventsPlayAnimEventData {
  native let blendIn: Float;
  native let blendOut: Float;
  native let clipFront: Float;
  native let clipEnd: Float;
  native let stretch: Float;
  native let blendInCurve: scnEasingType;
  native let blendOutCurve: scnEasingType;
}

public native struct scneventsPlayAnimEventExData {
  native let basic: scneventsPlayAnimEventData;
  native let weight: Float;
  native let bodyPartMask: CName;
}

public native class scneventsPlayerLookAtEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let nodeRef: NodeRef;
  native let lookAtParams: scneventsPlayerLookAtEventParams;
}

public native struct scneventsPlayerLookAtEventParams {
  native let slotName: CName;
  native let offsetPos: Vector3;
  native let duration: Float;
  native let adjustPitch: Bool;
  native let adjustYaw: Bool;
  native let endOnTargetReached: Bool;
  native let endOnCameraInputApplied: Bool;
  native let endOnTimeExceeded: Bool;
  native let cameraInputMagToBreak: Float;
  native let precision: Float;
  native let maxDuration: Float;
  native let easeIn: Bool;
  native let easeOut: Bool;
}

public native class scneventsPlayRidCameraAnimEvent extends scnSceneEvent {
  native let cameraRef: NodeRef;
  native let cameraPlacement: scneventsRidCameraPlacement;
  native let animData: scneventsPlayAnimEventData;
  native let animSRRefId: scnRidCameraAnimationSRRefId;
  native let animOriginMarker: scnMarker;
  native let activateAsGameCamera: Bool;
  native let controlRenderToTextureState: Bool;
  native let markCamerCut: Bool;
}

public native class scneventsRagdollEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let enableRagdoll: Bool;
}

enum scneventsRidCameraPlacement {
  SceneOrigin = 0,
  Actual = 1,
  Player = 2,
}

public native class scneventsSetAnimFeatureEvent extends scnSceneEvent {
  native let actorId: scnActorId;
  native let animFeatureName: CName;
  native let animFeature: ref<AnimFeature>;
}

public native class scneventsSetAnimsetWeight extends scnSceneEvent {
  native let actorId: scnActorId;
  native let animsetName: CName;
  native let weight: Float;
}

public native class scneventsSocket extends scnSceneEvent {
  native let osockStamp: scnOutputSocketStamp;
}

public native class scneventsSpawnEntityEvent extends scnSceneEvent {
  native let params: scneventsSpawnEntityEventParams;
}

public native struct scneventsSpawnEntityEventCachedFallbackBone {
  native let boneName: CName;
  native let modelSpaceTransform: Transform;
}

public native struct scneventsSpawnEntityEventFallbackData {
  native let owner: scnPerformerId;
  native let fallbackAnimset: ResourceRef; // rRef<animAnimSet>
  native let fallbackAnimationName: CName;
  native let fallbackAnimTime: Float;
}

public native struct scneventsSpawnEntityEventParams {
  native let performer: scnPerformerId;
  native let referencePerformer: scnPerformerId;
  native let referencePerformerSlotId: TweakDBID;
  native let referencePerformerItemId: TweakDBID;
  native let fallbackData: array<scneventsSpawnEntityEventFallbackData>;
}

enum scneventsUIAnimActionType {
  Play = 0,
  Update = 1,
  Resume = 2,
  Pause = 3,
  Stop = 4,
}

public native class scneventsUIAnimationBraindanceEvent extends scnSceneEvent {
  native let animationName: CName;
  native let performerId: scnPerformerId;
  native let nodeRef: NodeRef;
}

public native class scneventsUIAnimationEvent extends scnSceneEvent {
  native let animationName: CName;
  native let performerId: scnPerformerId;
  native let nodeRef: NodeRef;
}

public native class scneventsUnequipItemFromPerformer extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let slotId: TweakDBID;
  native let restoreGameplayItem: Bool;
}

public native class scneventsUnequipItemFromPerformerByItem extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let itemId: TweakDBID;
  native let restoreGameplayItem: Bool;
}

enum scneventsVFXActionType {
  Play = 0,
  Break = 1,
  Kill = 2,
}

public native class scneventsVFXBraindanceEvent extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let nodeRef: NodeRef;
  native let effectEntry: scnEffectEntry;
  native let sequenceShift: Uint32;
  native let glitchEffectEntry: scnEffectEntry;
  native let glitchSequenceShift: Uint32;
  native let fullyRewindable: Bool;
}

public native class scneventsVFXDurationEvent extends scnSceneEvent {
  native let effectEntry: scnEffectEntry;
  native let startAction: scneventsVFXActionType;
  native let endAction: scneventsVFXActionType;
  native let sequenceShift: Uint32;
  native let performerId: scnPerformerId;
  native let nodeRef: NodeRef;
  native let muteSound: Bool;
}

public native class scneventsVFXEvent extends scnSceneEvent {
  native let effectEntry: scnEffectEntry;
  native let action: scneventsVFXActionType;
  native let sequenceShift: Uint32;
  native let performerId: scnPerformerId;
  native let nodeRef: NodeRef;
  native let muteSound: Bool;
}

enum scnEventType {
}

public native struct scnExecutionTag {
  native let flags: Uint8;
}

public native struct scnExecutionTagEntry {
  native let name: CName;
  native let flags: Uint8;
}

public native struct scnExitPoint {
  native let name: CName;
  native let nodeId: scnNodeId;
}

enum scnFastForwardStrategy {
  automatic = 0,
  allow_fully = 1,
  block_on_start = 2,
  block_on_end = 3,
  block_on_start_and_end = 4,
  block_fully = 5,
  block_on_end_if_activator_matched = 6,
}

public native struct scnFindEntityInContextParams {
  native let contextualName: scnContextualActorName;
  native let voiceVagId: scnVoicetagId;
  native let contextActorName: CName;
  native let specRecordId: TweakDBID;
  native let forceMaxVisibility: Bool;
}

public native struct scnFindEntityInEntityParams {
  native let actorId: scnActorId;
  native let performerId: scnPerformerId;
  native let itemID: TweakDBID;
  native let slotID: TweakDBID;
  native let forceMaxVisibility: Bool;
  native let ownershipTransferOptions: scnPropOwnershipTransferOptions;
}

public native struct scnFindEntityInNodeParams {
  native let nodeRef: NodeRef;
  native let forceMaxVisibility: Bool;
}

public native struct scnFindEntityInWorldParams {
  native let actorRef: EntityReference;
  native let forceMaxVisibility: Bool;
}

public native struct scnFindNetworkPlayerParams {
  native let networkId: Uint32;
}

public native class scnFlowControlNode extends scnSceneGraphNode {
  native let isOpen: Bool;
  native let opensAt: Uint32;
  native let closesAt: Uint32;
}

enum scnfppBlendOverride {
  Centering = 0,
  CopyPitch_CenteringYaw = 1,
  CopyPitch_CopyYaw = 2,
  Custom_PitchYaw = 3,
}

public native struct scnfppGenderSpecificParams {
  native let genderMask: scnGenderMask;
  native let transitionBlendInTrajectorySpaceAngles: array<EulerAngles>;
  native let transitionBlendInCameraSpace: array<Float>;
  native let transitionEndInputAngles: array<EulerAngles>;
  native let idleCameraLs: EulerAngles;
  native let idleControlCameraMs: EulerAngles;
}

enum scnfppParallaxSpace {
  Default = 0,
  Camera = 1,
  Trajectory = 2,
  Chest = 3,
}

public native class scnGameplayActionEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let gameplayActionData: ref<scnIGameplayActionData>;
}

public native class scnGameplayActionSetVehicleSuspensionData extends scnIGameplayActionData {
  native let active: Bool;
  native let cooldownTime: Float;
}

public native struct scnGameplayAnimSetSRRef {
  native let asyncAnimSet: ResourceAsyncRef; // raRef<animAnimSet>
}

public native class scnGameplayTransitionEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let vehState: scnPuppetVehicleState;
}

public native struct scnGenderMask {
  native let mask: Uint8;
}

public native class scnHubNode extends scnSceneGraphNode {}

public abstract native class scnIBraindanceConditionType extends questISceneConditionType {}

public abstract native class scnIGameplayActionData extends ISerializable {}

public abstract native class scnIInterruptCondition extends ISerializable {}

public abstract native class scnIInterruptionOperation extends ISerializable {}

public abstract native class scnIInterruptionScenarioOperation extends ISerializable {}

public abstract native class scnIInterruptManager_Operation extends ISerializable {}

public native class scnIKEvent extends scnSceneEvent {
  native let ikData: scnIKEventData;
}

public native struct scnIKEventData {
  native let orientation: Quaternion;
  native let basic: scnAnimTargetBasicData;
  native let chainName: CName;
  native let request: IKTargetRequest;
}

public native struct scnInputSocketId {
  native let nodeId: scnNodeId;
  native let isockStamp: scnInputSocketStamp;
}

public native struct scnInputSocketStamp {
  native let name: Uint16;
  native let ordinal: Uint16;
}

public native class scnInteractionShapeParams extends ISerializable {
  native let preset: scnChoiceNodeNsSizePreset;
  native let offset: Vector3;
  native let rotation: Quaternion;
  native let customIndicationRange: Float;
  native let customActivationRange: Float;
  native let activationYawLimit: Float;
  native let activationBaseLength: Float;
  native let activationHeight: Float;
}

public native struct scnInterestingConversation_DEPRECATED {
  native let sceneFilename: ResourceAsyncRef; // raRef<scnSceneResource>
}

public native class scnInterestingConversationData extends ISerializable {
  native let sceneFilename: ResourceAsyncRef; // raRef<scnSceneResource>
  native let interruptionOperations: array<ref<scnIInterruptionOperation>>;
}

public native class scnInterestingConversationsGroup extends ISerializable {
  native let condition: ref<questIBaseCondition>;
  native let conversations: array<ref<scnInterestingConversationData>>;
}

public native class scnInterestingConversationsResource extends CResource {
  native let conversationGroups: array<ref<scnInterestingConversationsGroup>>;
}

public native class scnInterruptAvailability_Operation extends scnIInterruptManager_Operation {
  native let available: Bool;
}

enum scnInterruptCapability {
  None = 0,
  Interruptable = 1,
  NotInterruptable = 2,
}

public abstract native class scnInterruptFactConditionType extends ISerializable {}

enum scnInterruptionPhase {
  WaitForInterruption = 0,
  WaitForInterrupted = 1,
  Interrupted = 2,
  ClearTier = 3,
  FadeOutLines = 4,
  InterruptionVoiceset = 5,
  WaitForReturn = 6,
  InstallTalkInteraction = 7,
  WaitForTalkInteraction = 8,
  ReturnVoiceset = 9,
  ReturnAnswerVoiceset = 10,
  ShowLines = 11,
  SyncTime = 12,
  RestoreTier = 13,
  Returned = 14,
  FadeOutLookAt = 15,
  FadeInLookAt = 16,
  InterruptSignal = 17,
  PostInterruptSignalTimeDelay = 18,
  ReturnSignal = 19,
  PostReturnSignalTimeDelay = 20,
  ProcessTalkInteraction = 21,
  ClearCommands = 22,
}

public native struct scnInterruptionScenario {
  native let id: scnInterruptionScenarioId;
  native let name: CName;
  native let queueName: CName;
  native let enabled: Bool;
  native let talkOnReturn: Bool;
  native let playInterruptLine: Bool;
  native let forcePlayReturnLine: Bool;
  native let interruptionSpammingSafeguard: Bool;
  native let playingLinesBehavior: scnInterruptReturnLinesBehavior;
  native let postInterruptSignalTimeDelay: Float;
  native let postReturnSignalTimeDelay: Float;
  native let postInterruptSignalFactCondition: ref<scnInterruptFactConditionType>;
  native let postReturnSignalFactCondition: ref<scnInterruptFactConditionType>;
  native let interruptConditions: array<ref<scnIInterruptCondition>>;
  native let returnConditions: array<ref<scnIReturnCondition>>;
}

public native struct scnInterruptionScenarioId {
  native let id: Uint32;
}

public native class scnInterruptManagerNode extends scnSceneGraphNode {
  native let interruptionOperations: array<ref<scnIInterruptionOperation>>;
}

enum scnInterruptReturnLinesBehavior {
  Default = 0,
  Vehicle = 1,
  Holocall = 2,
}

public abstract native class scnIReturnCondition extends ISerializable {}

public native class scnIsAliveListener extends IStatPoolsListener {}

public abstract native class scnIScalingData extends ISerializable {}

public native struct scnLipsyncAnimSetSRRef {
  native let lipsyncAnimSet: ResourceRef; // rRef<animAnimSet>
  native let asyncRefLipsyncAnimSet: ResourceAsyncRef; // raRef<animAnimSet>
}

public native struct scnLipsyncAnimSetSRRefId {
  native let id: Uint32;
}

public native struct scnLocalMarker {
  native let transformLS: Transform;
  native let name: CName;
}

public native struct scnlocLangId {
  native let langId: Uint8;
}

enum scnlocLocaleId {
  db_db = 0,
  pl_pl = 1,
  en_us = 2,
}

public native struct scnlocLocStoreEmbedded {
  native let vdEntries: array<scnlocLocStoreEmbeddedVariantDescriptorEntry>;
  native let vpEntries: array<scnlocLocStoreEmbeddedVariantPayloadEntry>;
}

public native struct scnlocLocStoreEmbeddedVariantDescriptorEntry {
  native let variantId: scnlocVariantId;
  native let locstringId: scnlocLocstringId;
  native let localeId: scnlocLocaleId;
  native let signature: scnlocSignature;
  native let vpeIndex: Uint32;
}

public native struct scnlocLocStoreEmbeddedVariantPayloadEntry {
  native let variantId: scnlocVariantId;
  native let content: String;
}

public native struct scnlocLocstringId {
  native let ruid: CRUID;
}

public native struct scnlocSignature {
  native let val: Uint64;
}

public native struct scnlocVariantId {
  native let ruid: CRUID;
}

public native class scnLookAtAdvancedEvent extends scnSceneEvent {
  native let advancedData: scnLookAtAdvancedEventData;
}

public native struct scnLookAtAdvancedEventData {
  native let basic: scnAnimTargetBasicData;
  native let requests: array<animLookAtRequestForPart>;
}

public native struct scnLookAtBasicEventData {
  native let basic: scnAnimTargetBasicData;
  native let removePreviousAdvancedLookAts: Bool;
  native let requests: array<animLookAtRequestForPart>;
}

public native struct scnLookAtBodyPartProperties {
  native let enableFactor: Float;
  native let override: Float;
  native let mode: Int32;
}

public native struct scnLookAtBodyPartPropertiesAdvanced {
  native let bodyPartName: CName;
}

public native struct scnLookAtChestProperties {
  native let enableFactor: Float;
  native let override: Float;
  native let mode: Int32;
}

public native class scnLookAtEvent extends scnSceneEvent {
  native let basicData: scnLookAtBasicEventData;
}

public native struct scnLookAtEventData {
  native let id: Uint32;
  native let enable: Bool;
  native let singleBodyPartName: CName;
  native let singleTargetSlot: CName;
  native let bodyTargetSlot: CName;
  native let headTargetSlot: CName;
  native let eyesTargetSlot: CName;
  native let singleWeight: Float;
  native let bodyWeight: Float;
  native let headWeight: Float;
  native let eyesWeight: Float;
  native let useSingleWeightCurve: Bool;
  native let useBodyWeightCurve: Bool;
  native let useHeadWeightCurve: Bool;
  native let useEyesWeightCurve: Bool;
  native let singleWeightCurve: CurveDataFloat;
  native let bodyWeightCurve: CurveDataFloat;
  native let headWeightCurve: CurveDataFloat;
  native let eyesWeightCurve: CurveDataFloat;
  native let singleLimits: LookAtLimits;
  native let bodyLimits: LookAtLimits;
  native let headLimits: LookAtLimits;
  native let eyesLimits: LookAtLimits;
}

public native struct scnLookAtEyesProperties {
  native let enableFactor: Float;
  native let override: Float;
  native let mode: Int32;
}

public native struct scnLookAtHeadProperties {
  native let enableFactor: Float;
  native let override: Float;
  native let mode: Int32;
}

enum scnLookAtTargetType {
  Actor = 0,
  Prop = 1,
}

public native struct scnLookAtTwoHandedProperties {
  native let enableFactor: Float;
  native let override: Float;
  native let mode: Int32;
}

public native struct scnMarker {
  native let type: scnMarkerType;
  native let localMarkerId: CName;
  native let nodeRef: NodeRef;
  native let entityRef: EntityReference;
  native let slotName: CName;
  native let isMounted: Bool;
}

enum scnMarkerType {
  Local = 0,
  Global = 1,
  Entity = 2,
}

public native struct scnNodeId {
  native let id: Uint32;
}

public native struct scnNodeSymbol {
  native let nodeId: scnNodeId;
  native let editorNodeId: scnNodeId;
  native let editorEventId: Uint64;
}

public native struct scnNotablePoint {
  native let name: CName;
  native let nodeId: scnNodeId;
}

public abstract native class scnNPCStatusEffectsListener extends IStatusEffectListener {}

enum scnOffsetMode {
  useRealOffset = 0,
  useCustomOffset = 1,
}

public native struct scnOutputSocket {
  native let stamp: scnOutputSocketStamp;
  native let destinations: array<scnInputSocketId>;
}

public native struct scnOutputSocketId {
  native let nodeId: scnNodeId;
  native let osockStamp: scnOutputSocketStamp;
}

public native struct scnOutputSocketStamp {
  native let name: Uint16;
  native let ordinal: Uint16;
}

public native class scnOverrideInterruptConditions_InterruptionScenarioOperation extends scnIInterruptionScenarioOperation {
  native let interruptConditions: array<ref<scnIInterruptCondition>>;
}

public native class scnOverrideInterruptConditions_Operation extends scnIInterruptManager_Operation {
  native let interruptConditions: array<ref<scnIInterruptCondition>>;
}

public native class scnOverrideInterruptionScenario_InterruptionOperation extends scnIInterruptionOperation {
  native let scenarioId: scnInterruptionScenarioId;
  native let scenarioOperations: array<ref<scnIInterruptionScenarioOperation>>;
}

public native class scnOverridePhantomParamsEvent extends scnSceneEvent {
  native let params: scnOverridePhantomParamsEventParams;
}

public native struct scnOverridePhantomParamsEventParams {
  native let performer: scnPerformerId;
  native let overrideSpawnEffect: CName;
  native let overrideIdleEffect: CName;
}

public native class scnOverrideReturnConditions_InterruptionScenarioOperation extends scnIInterruptionScenarioOperation {
  native let returnConditions: array<ref<scnIReturnCondition>>;
}

public native class scnOverrideReturnConditions_Operation extends scnIInterruptManager_Operation {
  native let returnConditions: array<ref<scnIReturnCondition>>;
}

public native class scnOverrideTalkOnReturn_InterruptionScenarioOperation extends scnIInterruptionScenarioOperation {
  native let talkOnReturn: Bool;
}

public native struct scnPerformerId {
  native let id: Uint32;
}

public native struct scnPerformerSymbol {
  native let performerId: scnPerformerId;
  native let entityRef: EntityReference;
  native let editorPerformerId: CRUID;
}

public native class scnPlacementEvent extends scnSceneEvent {
  native let actorId: scnActorId;
  native let targetWaypoint: scnMarker;
}

public abstract native class scnPlayAnimEvent extends scnSceneEvent {
  native let animData: scneventsPlayAnimEventExData;
  native let performer: scnPerformerId;
  native let actorComponent: CName;
  native let convertToAdditive: Bool;
  native let neckWeight: Float;
  native let upperFaceBlendAdditive: Bool;
  native let lowerFaceBlendAdditive: Bool;
  native let eyesBlendAdditive: Bool;
}

public native struct scnPlayAnimEventData {
  native let blendIn: Float;
  native let blendOut: Float;
  native let clipFront: Float;
  native let stretch: Float;
  native let weight: Float;
  native let bodyPartMask: CName;
}

public native class scnPlayDefaultMountedSlotWorkspotEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
  native let parentRef: EntityReference;
  native let slotName: CName;
  native let puppetVehicleState: scnPuppetVehicleState;
}

public native struct scnPlayerActorDef {
  native let actorId: scnActorId;
  native let specTemplate: CName;
  native let specCharacterRecordId: TweakDBID;
  native let specAppearance: CName;
  native let voicetagId: scnVoicetagId;
  native let animSets: array<scnSRRefId>;
  native let lipsyncAnimSet: scnLipsyncAnimSetSRRefId;
  native let facialAnimSets: array<scnRidFacialAnimSetSRRefId>;
  native let cyberwareAnimSets: array<scnRidCyberwareAnimSetSRRefId>;
  native let deformationAnimSets: array<scnRidDeformationAnimSetSRRefId>;
  native let bodyCinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let facialCinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let cyberwareCinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let dynamicAnimSets: array<scnDynamicAnimSetSRRefId>;
  native let acquisitionPlan: scnEntityAcquisitionPlan;
  native let findNetworkPlayerParams: scnFindNetworkPlayerParams;
  native let findActorInContextParams: scnFindEntityInContextParams;
  native let playerName: String;
}

public native struct scnPlayerAnimData {
  native let tierData: ref<SceneTierData>;
  native let useZSnapping: Bool;
  native let unmountBodyCarry: Bool;
  native let isEndOfCarryingAnimation: Bool;
}

public native class scnPlayFPPControlAnimEvent extends scnPlayAnimEvent {
  native let gameplayAnimName: ref<scnAnimName>;
  native let FPPControlActive: Bool;
  native let blendOverride: scnfppBlendOverride;
  native let cameraUseTrajectorySpace: Bool;
  native let cameraBlendInDuration: Float;
  native let cameraBlendOutDuration: Float;
  native let stayInScene: Bool;
  native let idleIsMountedWorkspot: Bool;
  native let enableWorldSpaceSmoothing: Bool;
  native let isSceneCarrying: Bool;
  native let cameraParallaxWeight: Float;
  native let cameraParallaxSpace: scnfppParallaxSpace;
  native let vehicleProceduralCameraWeight: Float;
  native let yawLimitLeft: Float;
  native let yawLimitRight: Float;
  native let pitchLimitTop: Float;
  native let pitchLimitBottom: Float;
  native let genderSpecificParams: array<scnfppGenderSpecificParams>;
}

public native class scnPlayRidAnimEvent extends scnPlayFPPControlAnimEvent {
  native let ridVersinon: Uint32;
  native let animResRefId: scnRidAnimationSRRefId;
  native let animOriginMarker: scnMarker;
  native let actorPlacement: scnRidActorPlacement;
  native let actorHasCollision: Bool;
  native let blendInTrajectoryBone: Float;
}

public native class scnPlaySkAnimEvent extends scnPlayFPPControlAnimEvent {
  native let animName: ref<scnAnimName>;
  native let poseBlendOutWorkspot: ref<scnEventBlendWorkspotSetupParameters>;
  native let rootMotionData: scnPlaySkAnimRootMotionData;
  native let playerData: scnPlayerAnimData;
}

public native struct scnPlaySkAnimEventData {
  native let animName: CName;
  native let blendIn: Float;
  native let blendOut: Float;
  native let clipFront: Float;
  native let stretch: Float;
  native let weight: Float;
  native let bodyPartMask: CName;
}

public native struct scnPlaySkAnimRootMotionData {
  native let enabled: Bool;
  native let placementMode: scnRootMotionAnimPlacementMode;
  native let originMarker: scnMarker;
  native let originOffset: Transform;
  native let customBlendInTime: Float;
  native let customBlendInCurve: scnEasingType;
  native let removePitchRollRotation: Bool;
  native let meshDissolvingEnabled: Bool;
  native let snapToGroundStart: Float;
  native let snapToGroundEnd: Float;
  native let snapToGround: Bool;
  native let vehicleChangePhysicsState: Bool;
  native let vehicleEnabledPhysicsOnEnd: Bool;
  native let trajectoryLOD: array<scnAnimationMotionSample>;
}

public native class scnPlayVideoEvent extends scnSceneEvent {
  native let videoPath: String;
  native let isPhoneCall: Bool;
  native let forceFrameRate: Bool;
}

public native class scnPoseCorrectionEvent extends scnSceneEvent {
  native let performerId: scnPerformerId;
  native let poseCorrectionGroup: animPoseCorrectionGroup;
}

public native struct scnPropDef {
  native let propId: scnPropId;
  native let propName: String;
  native let specPropRecordId: TweakDBID;
  native let animSets: array<scnRidAnimSetSRRefId>;
  native let cinematicAnimSets: array<scnCinematicAnimSetSRRefId>;
  native let dynamicAnimSets: array<scnDynamicAnimSetSRRefId>;
  native let entityAcquisitionPlan: scnEntityAcquisitionPlan;
  native let findEntityInEntityParams: scnFindEntityInEntityParams;
  native let spawnDespawnParams: scnSpawnDespawnEntityParams;
  native let spawnSetParams: scnSpawnSetParams;
  native let communityParams: scnCommunityParams;
  native let spawnerParams: scnSpawnerParams;
  native let findEntityInNodeParams: scnFindEntityInNodeParams;
  native let findEntityInWorldParams: scnFindEntityInWorldParams;
}

public native struct scnPropId {
  native let id: Uint32;
}

public native struct scnPropOwnershipTransferOptions {
  native let type: scnPropOwnershipTransferOptionsType;
  native let dettachFromSlot: Bool;
  native let removeFromInventory: Bool;
}

enum scnPropOwnershipTransferOptionsType {
  TransferToWorkspotSystem_Automatic = 0,
  TransferToWorkspotSystem_Custom = 1,
  DisposeAfterScene = 2,
}

public native struct scnprvSpawnDespawnItem {
  native let recordID: TweakDBID;
  native let finalTransform: Transform;
}

enum scnPuppetVehicleState {
  IdleMounted = 0,
  IdleStand = 1,
  CombatWindowed = 2,
  CombatSeated = 3,
  Turret = 4,
  GunnerSlot = 5,
}

public native class scnQuestNode extends scnSceneGraphNode {
  native let questNode: ref<questNodeDefinition>;
  native let isockMappings: array<CName>;
  native let osockMappings: array<CName>;
}

enum scnRandomizerMode {
  Random = 0,
  IgnoreLastUsed = 1,
  IgnoreAllUsed = 2,
}

public native class scnRandomizerNode extends scnSceneGraphNode {
  native let mode: scnRandomizerMode;
  native let numOutSockets: Uint32;
  native let weights: [Uint8; 32];
}

public native struct scnReferencePointDef {
  native let id: scnReferencePointId;
  native let offset: Vector3;
  native let originMarker: scnMarker;
}

public native struct scnReferencePointId {
  native let id: Uint32;
}

public native class scnReminderCondition extends ISerializable {
  native let useCustomReminder: Bool;
  native let reminderActor: scnActorId;
  native let waitTimeForReminderA: scnSceneTime;
  native let waitTimeForReminderB: scnSceneTime;
  native let waitTimeForReminderC: scnSceneTime;
  native let waitTimeForLooping: scnSceneTime;
  native let startTime: scnSceneTime;
  native let processStep: scnReminderConditionProcessStep;
  native let playing: Bool;
  native let running: Bool;
  native let reminderParams: scnChoiceNodeNsReminderParams;
}

enum scnReminderConditionProcessStep {
  ReminderA = 0,
  ReminderB = 1,
  ReminderC = 2,
  Looping = 3,
}

public native class scnRewindableSectionNode extends scnSceneGraphNode {
  native let events: array<ref<scnSceneEvent>>;
  native let sectionDuration: scnSceneTime;
  native let actorBehaviors: array<scnSectionInternalsActorBehavior>;
  native let playSpeedModifiers: scnRewindableSectionPlaySpeedModifiers;
}

public native struct scnRewindableSectionPlaySpeedModifiers {
  native let forwardVeryFast: Float;
  native let forwardFast: Float;
  native let forwardSlow: Float;
  native let backwardVeryFast: Float;
  native let backwardFast: Float;
  native let backwardSlow: Float;
}

enum scnRidActorPlacement {
  SceneOrigin = 0,
  Actual = 1,
  Player = 2,
}

public native struct scnRidAnimationContainerSRRef {
  native let animations: array<scnRidAnimationContainerSRRefAnimContainer>;
}

public native struct scnRidAnimationContainerSRRefAnimContainer {
  native let animation: scnRidAnimationSRRefId;
  native let context: scnRidAnimationContainerSRRefAnimContainerContext;
}

public native struct scnRidAnimationContainerSRRefAnimContainerContext {
  native let genderMask: scnGenderMask;
}

public native struct scnRidAnimationContainerSRRefId {}

public native struct scnRidAnimationSRRef {
  native let resourceId: scnRidResourceId;
  native let animationSN: scnRidSerialNumber;
}

public native struct scnRidAnimationSRRefId {
  native let id: Uint32;
}

public native struct scnRidAnimSetSRRef {
  native let animations: array<scnSRRefId>;
}

public native struct scnRidAnimSetSRRefId {
  native let id: Uint32;
}

public native struct scnRidCameraAnimationSRRef {
  native let resourceId: scnRidResourceId;
  native let animationSN: scnRidSerialNumber;
}

public native struct scnRidCameraAnimationSRRefId {
  native let id: Uint32;
}

public native struct scnRidCyberwareAnimSetSRRefId {
  native let id: Uint32;
}

public native struct scnRidDeformationAnimSetSRRefId {
  native let id: Uint32;
}

public native struct scnRidFacialAnimSetSRRefId {
  native let id: Uint32;
}

public native class scnRidResource extends CResource {
  native let actors: array<scnActorRid>;
  native let cameras: array<scnCameraRid>;
  native let nextSerialNumber: scnRidSerialNumber;
  native let version: Uint32;
}

public native struct scnRidResourceHandler {
  native let id: scnRidResourceId;
  native let ridResource: ResourceRef; // rRef<scnRidResource>
}

public native struct scnRidResourceId {
  native let id: Uint32;
}

public native struct scnRidSerialNumber {
  native let serialNumber: Uint32;
}

public native struct scnRidTag {
  native let signature: CName;
  native let serialNumber: scnRidSerialNumber;
}

enum scnRootMotionAnimPlacementMode {
  Blend = 0,
  TeleportToStart = 1,
  PlayAtActorPosition = 2,
}

public native class scnScalingData_KeepRelationWithOtherEvents extends scnIScalingData {
  native let groupRfrncNdspaceStarttime: scnSceneTime;
  native let groupRfrncNdspaceEndtime: scnSceneTime;
}

enum scnSceneCategoryTag {
  voiceset = 0,
  mainQuests = 1,
  sideQuests = 2,
  minorQuests = 3,
  otherQuests = 4,
  dialoguesQuests = 5,
  streetOpenWorld = 6,
  vendorsOpenWorld = 7,
  dancefloorsOpenWorld = 8,
  cityOpenWorld = 9,
  chatsOpenWorld = 10,
  otherOpenWorld = 11,
  holocalls = 12,
  other = 13,
}

public abstract native class scnSceneEvent extends ISerializable {
  native let id: scnSceneEventId;
  native let type: scnEventType;
  native let startTime: Uint32;
  native let duration: Uint32;
  native let executionTagFlags: Uint8;
  native let scalingData: ref<scnIScalingData>;
}

public native struct scnSceneEventId {
  native let id: Uint64;
}

public native struct scnSceneEventSymbol {
  native let editorEventId: Uint64;
  native let originNodeId: scnNodeId;
  native let sceneEventIds: array<scnSceneEventId>;
}

public native class scnSceneGraph extends ISerializable {
  native let graph: array<ref<scnSceneGraphNode>>;
  native let startNodes: array<scnNodeId>;
  native let endNodes: array<scnNodeId>;
}

public abstract native class scnSceneGraphNode extends ISerializable {
  native let nodeId: scnNodeId;
  native let ffStrategy: scnFastForwardStrategy;
  native let outputSockets: array<scnOutputSocket>;
}

public native struct scnSceneId {
  native let resPathHash: Uint64;
}

public native struct scnSceneInstanceId {
  native let sceneId: scnSceneId;
  native let ownerId: scnSceneInstanceOwnerId;
  native let internalId: Uint8;
  native let hash: Uint64;
}

public native struct scnSceneInstanceOwnerId {
  native let hash: Uint64;
}

public native class scnSceneMarker extends worldIMarker {
  native let markers: array<scnSceneMarkerInternalsAnimEventEntry>;
  native let workspotMarkers: array<scnSceneMarkerInternalsWorkspotEntry>;
}

public native struct scnSceneMarkerInternalsAnimEventEntry {
  native let startName: CName;
  native let endName: CName;
  native let startPos: Vector3;
  native let endPos: Vector3;
  native let startDir: Vector3;
  native let endDir: Vector3;
  native let flags: Uint8;
}

public native struct scnSceneMarkerInternalsWorkspotEntry {
  native let instanceId: CRUID;
  native let instanceOrigin: Transform;
  native let entries: array<scnSceneMarkerInternalsWorkspotEntrySocket>;
  native let exits: array<scnSceneMarkerInternalsWorkspotEntrySocket>;
}

public native struct scnSceneMarkerInternalsWorkspotEntrySocket {
  native let name: CName;
  native let transform: Transform;
}

public native class scnSceneResource extends CResource {
  native let entryPoints: array<scnEntryPoint>;
  native let exitPoints: array<scnExitPoint>;
  native let notablePoints: array<scnNotablePoint>;
  native let executionTagEntries: array<scnExecutionTagEntry>;
  native let actors: array<scnActorDef>;
  native let playerActors: array<scnPlayerActorDef>;
  native let sceneGraph: ref<scnSceneGraph>;
  native let localMarkers: array<scnLocalMarker>;
  native let props: array<scnPropDef>;
  native let ridResources: array<scnRidResourceHandler>;
  native let workspots: array<ref<scnWorkspotData>>;
  native let workspotInstances: array<scnWorkspotInstance>;
  native let resouresReferences: scnSRRefCollection;
  native let screenplayStore: scnscreenplayStore;
  native let locStore: scnlocLocStoreEmbedded;
  native let version: Uint32;
  native let voInfo: array<scnSceneVOInfo>;
  native let effectDefinitions: array<scnEffectDef>;
  native let effectInstances: array<scnEffectInstance>;
  native let executionTags: array<scnExecutionTag>;
  native let referencePoints: array<scnReferencePointDef>;
  native let interruptionScenarios: array<scnInterruptionScenario>;
  native let sceneSolutionHash: scnSceneSolutionHash;
  native let sceneCategoryTag: scnSceneCategoryTag;
  native let debugSymbols: scnDebugSymbols;
}

public native class scnSceneSharedState extends ISerializable {
  native let entrypoint: CName;
  native let syncNodesVisited: array<scnSyncNodeSignal>;
  native let instanceHash: Uint64;
  native let finishedOnServer: Bool;
  native let finishedOnClient: Bool;
}

public native struct scnSceneSolutionHash {
  native let sceneSolutionHash: scnSceneSolutionHashHash;
}

public native struct scnSceneSolutionHashHash {
  native let sceneSolutionHashDate: Uint64;
}

public native class scnScenesVersions extends CResource {
  native let currentVersion: Uint32;
  native let scenes: array<scnScenesVersionsSceneChanges>;
}

public native struct scnScenesVersionsChangedRecord {
  native let changeInVersion: Uint32;
  native let sceneBeforeChange: ResourceAsyncRef; // raRef<scnSceneResource>
}

public native struct scnScenesVersionsSceneChanges {
  native let scene: ResourceAsyncRef; // raRef<scnSceneResource>
  native let sceneChanges: array<scnScenesVersionsChangedRecord>;
}

public native class scnSceneSystem extends SceneSystem {}

public abstract native struct scnSceneSystemGlobalSettings {
  native let syncLipsyncToSceneTime: Bool;
}

public native struct scnSceneTime {
  native let stu: Uint32;
}

public native class scnSceneTimeProvider extends IVisualizerTimeProvider {}

enum scnSceneVersionCheck {
  OlderOrEqual = 0,
  Equal = 1,
}

public native struct scnSceneVOInfo {
  native let inVoTrigger: CName;
  native let outVoTrigger: CName;
  native let duration: Float;
  native let id: Uint16;
}

public native struct scnSceneWorkspotDataId {
  native let id: Uint32;
}

public native struct scnSceneWorkspotInstanceId {
  native let id: Uint32;
}

public native struct scnscreenplayChoiceOption {
  native let itemId: scnscreenplayItemId;
  native let usage: scnscreenplayOptionUsage;
  native let locstringId: scnlocLocstringId;
}

public native struct scnscreenplayDialogLine {
  native let itemId: scnscreenplayItemId;
  native let speaker: scnActorId;
  native let addressee: scnActorId;
  native let usage: scnscreenplayLineUsage;
  native let locstringId: scnlocLocstringId;
  native let maleLipsyncAnimationName: CName;
  native let femaleLipsyncAnimationName: CName;
}

public native struct scnscreenplayItemId {
  native let id: Uint32;
}

enum scnscreenplayItemType {
  invalid = 0,
  dialogLine = 1,
  choiceOption = 2,
  standaloneComment = 3,
}

public native struct scnscreenplayLineUsage {
  native let playerGenderMask: scnGenderMask;
}

public native struct scnscreenplayOptionUsage {
  native let playerGenderMask: scnGenderMask;
}

public native struct scnscreenplayStandaloneComment {
  native let itemId: scnscreenplayItemId;
  native let comment: String;
}

public native struct scnscreenplayStore {
  native let lines: array<scnscreenplayDialogLine>;
  native let options: array<scnscreenplayChoiceOption>;
}

public native struct scnSectionInternalsActorBehavior {
  native let actorId: scnActorId;
  native let behaviorMode: scnSectionInternalsActorBehaviorMode;
}

enum scnSectionInternalsActorBehaviorMode {
  OnlyIfAlive = 0,
  EvenIfDead = 1,
}

public native class scnSectionNode extends scnSceneGraphNode {
  native let events: array<ref<scnSceneEvent>>;
  native let sectionDuration: scnSceneTime;
  native let actorBehaviors: array<scnSectionInternalsActorBehavior>;
  native let isFocusClue: Bool;
}

public native class scnSetupSyncWorkspotRelationshipsEvent extends scnSceneEvent {}

public native struct scnsimActionsScenarios {
  native let allScenarios: array<scnsimActionsScenariosNodeScenarios>;
}

public native struct scnsimActionsScenariosNodeScenarios {
  native let nodeId: scnNodeId;
  native let scenarios: array<ref<scnsimIActionScenario>>;
  native let fallback: ref<scnsimIActionScenario>;
}

public abstract native class scnsimIActionScenario extends ISerializable {}

public native struct scnSpawnDespawnEntityParams {
  native let dynamicEntityUniqueName: CName;
  native let spawnMarker: CName;
  native let spawnMarkerType: scnMarkerType;
  native let spawnMarkerNodeRef: NodeRef;
  native let spawnOffset: Transform;
  native let itemOwnerId: scnPerformerId;
  native let specRecordId: TweakDBID;
  native let appearance: CName;
  native let spawnOnStart: Bool;
  native let isEnabled: Bool;
  native let validateSpawnPostion: Bool;
  native let alwaysSpawned: Bool;
  native let keepAlive: Bool;
  native let findInWorld: Bool;
  native let forceMaxVisibility: Bool;
  native let prefetchAppearance: Bool;
}

public native struct scnSpawnerParams {
  native let reference: NodeRef;
  native let forceMaxVisibility: Bool;
}

public native struct scnSpawnSetParams {
  native let reference: NodeRef;
  native let entryName: CName;
  native let forceMaxVisibility: Bool;
}

public native struct scnSRRefCollection {
  native let ridAnimations: array<scnRidAnimationSRRef>;
  native let ridAnimSets: array<scnRidAnimSetSRRef>;
  native let ridFacialAnimSets: array<scnRidAnimSetSRRef>;
  native let ridCyberwareAnimSets: array<scnRidAnimSetSRRef>;
  native let ridDeformationAnimSets: array<scnRidAnimSetSRRef>;
  native let lipsyncAnimSets: array<scnLipsyncAnimSetSRRef>;
  native let ridCameraAnimations: array<scnRidCameraAnimationSRRef>;
  native let cinematicAnimSets: array<scnCinematicAnimSetSRRef>;
  native let gameplayAnimSets: array<scnGameplayAnimSetSRRef>;
  native let dynamicAnimSets: array<scnDynamicAnimSetSRRef>;
  native let cinematicAnimNames: array<scnAnimSetAnimNames>;
  native let gameplayAnimNames: array<scnAnimSetAnimNames>;
  native let dynamicAnimNames: array<scnAnimSetDynAnimNames>;
  native let ridAnimationContainers: array<scnRidAnimationContainerSRRef>;
}

public native struct scnSRRefId {
  native let id: Uint32;
}

public native class scnStartNode extends scnSceneGraphNode {}

public native struct scnSyncNodeSignal {
  native let nodeId: Uint32;
  native let name: Uint16;
  native let ordinal: Uint16;
  native let numRuns: Uint16;
}

public native struct scnSystemSharedState {}

public native class scnTalkInteractionListener extends ISerializable {}

public native class scnTalkOnReturn_Operation extends scnIInterruptManager_Operation {
  native let talkOnReturn: Bool;
}

public native class scnTimedCondition extends ISerializable {
  native let duration: scnSceneTime;
  native let action: scnChoiceNodeNsTimedAction;
  native let timeLimitedFinish: Bool;
}

public native class scnToggleInterruption_InterruptionOperation extends scnIInterruptionOperation {
  native let enable: Bool;
}

public native class scnToggleScenario_InterruptionScenarioOperation extends scnIInterruptionScenarioOperation {
  native let enable: Bool;
}

public native class scnUnmountEvent extends scnSceneEvent {
  native let performer: scnPerformerId;
}

public native class scnUseSceneWorkspotCommand extends AIBaseUseWorkspotCommand {
  native let sceneInstanceId: scnSceneInstanceId;
  native let workspotInstanceId: scnSceneWorkspotInstanceId;
  native let itemOverride: workWorkspotItemOverride;
  native let nodeId: scnNodeId;
}

public native class scnUseSceneWorkspotParamsV1 extends questUseWorkspotParamsV1 {
  native let workspotInstanceId: scnSceneWorkspotInstanceId;
  native let playAtActorLocation: Bool;
  native let itemOverride: workWorkspotItemOverride;
}

public native class scnVarComparison_FactConditionType extends scnInterruptFactConditionType {
  native let params: scnVarComparison_FactConditionTypeParams;
}

public native struct scnVarComparison_FactConditionTypeParams {
  native let factName: CName;
  native let value: Int32;
  native let comparisonType: EComparisonType;
}

public native class scnVarVsVarComparison_FactConditionType extends scnInterruptFactConditionType {
  native let params: scnVarVsVarComparison_FactConditionTypeParams;
}

public native struct scnVarVsVarComparison_FactConditionTypeParams {
  native let factName1: CName;
  native let factName2: CName;
  native let comparisonType: EComparisonType;
}

public native class scnVehicleMoveOnSpline_Overrides extends questIVehicleMoveOnSpline_Overrides {
  native let useEntry: Bool;
  native let useExit: Bool;
  native let entrySpeed: Float;
  native let exitSpeed: Float;
  native let entryTransform: Transform;
  native let exitTransform: Transform;
  native let entryMarker: scnMarker;
  native let exitMarker: scnMarker;
}

public native class scnVoicesetComponentPS extends GameComponentPS {
  native persistent let blockedInputs: array<entVoicesetInputToBlock>;
  native persistent let voiceTag: CName;
  native persistent let NPCHighLevelState: gamedataNPCHighLevelState;
  native persistent let gruntSetIndex: Uint32;
  native persistent let areVoicesetLinesEnabled: Bool;
  native persistent let areVoicesetGruntsEnabled: Bool;
}

public native struct scnVoicetagId {
  native let id: CRUID;
}

public native class scnWalkToEvent extends scnSceneEvent {
  native let actorId: scnActorId;
  native let targetWaypointTag: CName;
  native let usePathfinding: Bool;
}

public native class scnWorkspotData_EmbeddedWorkspotTree extends scnWorkspotData {
  native let workspotTree: ref<workWorkspotTree>;
}

public native class scnWorkspotData_ExternalWorkspotResource extends scnWorkspotData {
  native let workspotResource: ResourceRef; // rRef<workWorkspotResource>
}

public abstract native class scnWorkspotData extends ISerializable {
  native let dataId: scnSceneWorkspotDataId;
}

public native struct scnWorkspotInstance {
  native let workspotInstanceId: scnSceneWorkspotInstanceId;
  native let dataId: scnSceneWorkspotDataId;
  native let localTransform: Transform;
  native let playAtActorLocation: Bool;
  native let originMarker: scnMarker;
}

public native struct scnWorkspotSymbol {
  native let wsInstance: scnSceneWorkspotInstanceId;
  native let wsNodeId: scnNodeId;
  native let wsEditorEventId: Uint64;
}

public native struct scnWorldMarker {
  native let type: scnWorldMarkerType;
  native let tag: CName;
  native let nodeRef: NodeRef;
}

enum scnWorldMarkerType {
  Tag = 0,
  NodeRef = 1,
}

public native class scnXorNode extends scnSceneGraphNode {}

public native struct Segment {
  native let origin: Vector4;
  native let direction: Vector4;
}

public native struct senseShapes {
  native let shapes: array<ref<ISenseShape>>;
}

enum senseTracingFreq {
  Never = 0,
  Lowest = 1,
  Low = 2,
  Medium = 3,
  High = 4,
  Highest = 5,
}

public native class SenseVisibilityPartsEvent extends Event {
  native let target: wref<GameObject>;
  native let isPrimaryVisible: Bool;
  native let isSecondaryVisible: Bool;
  native let description: CName;
}

public native class SensorObject extends ISerializable {
  native let presetID: TweakDBID;
  native let detectionFactor: Float;
  native let detectionDropFactor: Float;
  native let detectionCoolDownTime: Float;
  native let detectionPartCoolDownTime: Float;
  native let hearingEnabled: Bool;
  native let sensorObjectType: gamedataSenseObjectType;
}

public native class ServerBlackboardUpdateProxy extends BlackboardUpdateProxy {}

public native struct servicesGameServicesGalaxy {}

public native class SetAttributeEnabledEvent extends Event {}

public native class SetAudioOverrideEvent extends Event {
  native let enable: Bool;
}

public native class SetBackgroundEvent extends Event {}

public native class SetCasinoChipsAmountEvent extends Event {
  native let value: Uint32;
}

public native class SetCategoryEnabledEvent extends Event {}

public native class SetFrameImageEvent extends Event {}

public importonly native class SetScannableThroughWallsEvent extends Event {
  native let isScannableThroughWalls: Bool;
}

public native class SetSelectedStickerEvent extends Event {}

public native class SetStickerImageEvent extends Event {}

public native class SettingsControlsGameController extends gameuiMenuGameController {
  public final native func GetInputActionDisplayList()
}

public native class SetupGridSelectorForAttributeEvent extends Event {
  native let attribute: Uint32;
}

public native class SetupOptionButtonForAttributeEvent extends Event {
  native let attribute: Uint32;
  native let value: String;
}

public native class SetupOptionSelectorForAttributeEvent extends Event {
  native let attribute: Uint32;
  native let values: array<PhotoModeOptionSelectorData>;
  native let startDataValue: Int32;
  native let doApply: Bool;
}

public native class SetupScrollBarForAttributeEvent extends Event {
  native let attribute: Uint32;
  native let startValue: Float;
  native let minValue: Float;
  native let maxValue: Float;
  native let step: Float;
}

public native struct ShaderDefine {
  native let name: String;
  native let value: String;
}

public native struct ShadowCascadeConfig {
  native let range: Float;
  native let filterSize: Float;
  native let blendRange: Float;
  native let biasOffset: Float;
}

enum shadowsShadowCastingMode {
  Default = 0,
  Always = 1,
  Never = 2,
}

public native struct ShaftsAreaSettings {
  native let shaftsLevelIndex: Uint32;
  native let shaftsIntensity: Float;
  native let shaftsThresholdsScale: Float;
}

enum sharedCommandResult {
  Success = 0,
  NeedOptions = 1,
  Fail = 2,
  Abort = 3,
}

public native struct sharedMenuCollection {
  native let items: array<sharedMenuItem>;
}

public native struct sharedMenuItem {
  native let id: CName;
  native let displayName: String;
  native let tooltip: String;
  native let subItems: array<sharedMenuItem>;
  native let isEnabled: Bool;
  native let type: sharedMenuItemType;
  native let isChecked: Bool;
  native let checkGroup: String;
}

enum sharedMenuItemType {
  Action = 0,
  Checked = 1,
  Group = 2,
  Separator = 3,
}

public native struct sharedResourceCommandOutcome {
  native let result: sharedCommandResult;
  native let modifiedFiles: array<String>;
  native let message: String;
}

public native struct SharedVarBool {
  native let varName: LibTreeSharedVarReferenceName;
  public final static native func Get()
  public final static native func IsValid()
  public final static native func Set()
}

public native struct SharedVarFloat {
  native let varName: LibTreeSharedVarReferenceName;
  public final static native func Get()
  public final static native func IsValid()
  public final static native func Set()
}

public native struct SharedVarInt {
  native let varName: LibTreeSharedVarReferenceName;
  public final static native func Get()
  public final static native func IsValid()
  public final static native func Set()
}

public native struct SharedVarName {
  native let varName: LibTreeSharedVarReferenceName;
  public final static native func Get()
  public final static native func IsValid()
  public final static native func Set()
}

public native struct SharedVarPosition {
  native let varName: LibTreeSharedVarReferenceName;
  public final static native func Get()
  public final static native func IsValid()
  public final static native func Set()
}

public native struct SharedVarTarget {
  native let varName: LibTreeSharedVarReferenceName;
  public final static native func Get()
  public final static native func IsValid()
  public final static native func Set()
}

public native class SharpeningAreaSettings extends IAreaSettings {
  native let sharpeningStrength: Float;
  native let sharpeningStrengthWhenUpsaling: Float;
  native let sharpeningStrengthUpscalingTreshold: Float;
}

public native class ShooterPlayerController extends gameuiarcadeArcadePlayerController {}

public native class ShooterTraumaTeamController extends inkLogicController {}

public native class ShooterWeaponController extends inkLogicController {}

public native class ShowCustomTooltipEvent extends Event {
  native let text: String;
  native let inputAction: String;
}

public native struct SideScrollerCheatCodeAdvanced {
  native let name: CName;
  native let keys: array<CName>;
}

public native class SideScrollerSpawnerAdvanced extends IScriptable {}

public abstract native class SignalUserDataDefinition extends ISerializable {}

public importonly native class SmartObjectManager extends ISmartObjectManager {}

public native struct SMeshChunkPacked {
  native let vertexType: EMeshVertexType;
  native let materialID: array<CName>;
  native let numBonesPerVertex: Uint8;
  native let numVertices: Uint32;
  native let numIndices: Uint32;
  native let firstVertex: Uint32;
  native let firstIndex: Uint32;
  native let useForShadowmesh: Bool;
  native let streams: array<SMeshStream>;
  native let streamMask: Uint64;
  native let lodMask: Uint8;
}

public native struct SMeshStream {
  native let type: EMeshStreamType;
}

public native struct SMeshTopology {}

public native struct SOMState {
  native let depthStencilModeDesc: PSODescDepthStencilModeDesc;
  native let rasterizerModeDesc: PSODescRasterizerModeDesc;
  native let blendModeDesc: PSODescBlendModeDesc;
  native let stencilReadMask: Uint8;
  native let stencilWriteMask: Uint8;
  native let stencilRef: Uint8;
}

public native struct SParticleEmitterLODLevel {
  native let emitterDurationSettings: EmitterDurationSettings;
  native let emitterDelaySettings: EmitterDelaySettings;
  native let burstList: array<ParticleBurst>;
  native let birthRate: ref<IEvaluatorFloat>;
  native let sortingMode: rendEParticleSortingMode;
  native let lodSwitchDistance: Float;
  native let isEnabled: Bool;
}

public native class SpawnBoxEvaluator extends PhysicsParticleInitializer {}

public native class SpawnSphereEvaluator extends PhysicsParticleInitializer {}

public native class SplashScreenLoadingScreenLogicController extends ILoadingLogicController {
  native let trailerBink: ResourceAsyncRef; // raRef<Bink>
  native let logosTrainAnimation: CName;
  native let localizedMessageAnimation: CName;
  native let gameIntroAnimation: CName;
  native let longLogosTrainAnimation: CName;
  native let stopIntroAudioEventName: CName;
  native let afterSkipAnimation: CName;
  native let videoPlayer: inkVideoRef;
  native let skipButtonPanel: inkCompoundRef;
}

public native class Spline extends ISerializable {
  native let points: array<SplinePoint>;
  native let looped: Bool;
  native let reversed: Bool;
  native let hasDirection: Bool;
}

public native struct SplinePoint {
  native let position: Vector3;
  native let rotation: Quaternion;
  native let tangents: [Vector3; 2];
  native let continuousTangents: Bool;
  native let automaticTangents: Bool;
  native let id: Uint32;
}

public native struct SpreadingData {
  native let count: Uint32;
  native let targets: Uint32;
  native let damageMultiplier: Float;
  native let range: Float;
  native let coneAngle: Float;
}

public native class SquadBase extends ISerializable {}

public native class SquadManager extends AIISquadManager {}

public native class SSAOAreaSettings extends IAreaSettings {
  native let noiseFilterTolerance: CurveDataFloat;
  native let blurTolerance: CurveDataFloat;
  native let upsampleTolerance: CurveDataFloat;
  native let rejectionFalloff: CurveDataFloat;
  native let combineResolutionsBeforeBlur: Bool;
  native let combineResolutionsWithMul: Bool;
  native let normalsEnable: Bool;
  native let hierarchyDepth: Int32;
  native let normalAOMultiply: CurveDataFloat;
  native let normalBackProjectTolerance: CurveDataFloat;
  native let qualityLevel: ESSAOQualityLevel;
  native let coneAoDiffuseStrength: CurveDataFloat;
  native let coneAoSpecularStrength: CurveDataFloat;
  native let coneAoSpecularTreshold: CurveDataFloat;
  native let lightAoDiffuseStrength: CurveDataFloat;
  native let lightAoSpecularStrength: CurveDataFloat;
  native let foliageDimDiffuse: CurveDataFloat;
  native let foliageDimSpecular: CurveDataFloat;
}

public native class SSSRAreaSettings extends IAreaSettings {
  native let depthFadeStart: Float;
  native let depthFadeEnd: Float;
}

enum StaticShaderInputLayout {
  DebugVertexBase = 0,
  DebugVertexUV = 1,
  DebugVertexUV_Fullscreen = 2,
  NoBuffers_Fullscreen = 3,
  NoBuffers_PointList = 4,
}

public native struct StatsBundle {}

public native struct STextureGroupSetup {
  native let group: GpuWrapApieTextureGroup;
  native let rawFormat: ETextureRawFormat;
  native let compression: ETextureCompression;
  native let isStreamable: Bool;
  native let hasMipchain: Bool;
  native let isGamma: Bool;
  native let platformMipBiasPC: Uint8;
  native let platformMipBiasConsole: Uint8;
  native let allowTextureDowngrade: Bool;
}

public native class StickerEditorEnableCursorInputEvent extends Event {}

public native class StickersRegisterCallbacksEvent extends Event {}

public native struct STonemappingACESParams {
  native let minStops: Float;
  native let maxStops: Float;
  native let midGrayScale: Float;
  native let surroundGamma: Float;
  native let toneCurveSaturation: Float;
  native let adjustWhitePoint: Bool;
  native let desaturate: Bool;
  native let dimSurround: Bool;
  native let tonemapLuminance: Bool;
  native let applyAfterLUT: Bool;
}

public native class StoryTierChangedEvent extends AIEvent {
  native let newTier: gameStoryTier;
}

public native struct StrafingTarget {
  native let position: Vector3;
  native let object: wref<GameObject>;
}

public native class StreetSignWidgetComponent extends IWorldWidgetComponent {
  native let streetSignTDBID: TweakDBID;
  native let isAStreetName: Bool;
  native let streetNameSignTDBID: TweakDBID;
  native let signSelector: ref<TweakDBIDSelector>;
  native let signVersion: Uint32;
}

public importonly native struct SummonLogic {}

public native class SvgResource extends CResource {
  native let vectorGraphicDef: ref<vgVectorGraphicDefinition>;
}

public native struct SWeaponPlaneParams {
  native let weaponNearPlaneCM: Float;
  native let blurIntensity: Float;
}

public native class TaggedSignalUserDataDefinition extends SignalUserDataDefinition {
  native let tags: array<CName>;
}

public native class TargetFilter_Closest extends TargetFilter {}

public native class TargetFilter_ClosestOpaque extends TargetFilter_Closest {}

public native class TargetFilter_Logical extends TargetFilter_Closest {}

public native class TargetFilterResult_Logical extends TargetFilterResult {}

public native class TargetPointComponent extends IPlacedComponent {}

public native class TargetTrackerManager extends AITargetTrackerManagerInterface {}

public abstract native class tempshitIJournalNodeType extends ISerializable {}

public native class tempshitJournalEntryNodeType extends tempshitIJournalNodeType {}

public native class tempshitJournalNodeDefinition extends questDisableableNodeDefinition {}

public native class tempshitMapPinManagerNodeDefinition extends questDisableableNodeDefinition {
  native let mapPinName: CName;
  native let operation: tempshitMapPinOperation;
  native let nodeRef: EntityReference;
  native let position: Vector3;
  native let forceCaption: LocalizationString;
}

enum tempshitMapPinOperation {
  Undefined = 0,
  Add = 1,
  Remove = 2,
}

public native class TestCaseBase_Backend extends IScriptable {
  public final native func AddStep()
  public final native func CreateStep()
  public final native func EngineSetup()
  public final native func GTFManager()
  public final native func GetGamedef()
  public final native func GetVariantInfo()
  public final native func PrepareTestSteps()
  public final native func TestBody()
  public final native func TestSetup()
  public final native func TestWrapup()
}

public native class TestStep extends IScriptable {
  native let stepName: CName;
  native let scriptId: Uint16;
  native let reproStep: String;
  native let args: array<Variant>;
  native let stepTimeout: Float;
  native let stopTestOnFailure: Bool;
  public final native func Param()
  public final native func SetStepLogic()
}

public native class TestStepLogic extends IScriptable {
  native let maxExecutionTimeSec: Float;
  native let executionTimeSec: Float;
  native let paramsData: array<ParamData>;
  public final native func GetATUI()
  public final native func GetAudioFunctionalTests()
  public final native func GetFunctionalTestsGameSystem()
  public final native func GetGameInstance()
  public final native func GetNavigationFunctionalTests()
  public final native func GetOptionalParam()
  public final native func GetParam()
  public final native func GetPhysicsFunctionalTests()
  public final native func GetPlayerFunctionalTests()
  public final native func GetPlayerSystem()
  public final native func GetRenderingFunctionalTests()
  public final native func GetUIFunctionalTests()
  public final native func GetWorldFunctionalTests()
  public final native func RegisterToEntityEvents()
  public final native func ReturnResult()
  public final native func ReturnValue()
  public final native func SetParamTypes()
  public final native func StartTest()
}

public native struct Tetrahedron {
  native let point1: Vector4;
  native let point2: Vector4;
  native let point3: Vector4;
  native let point4: Vector4;
}

enum textJustificationType {
  Left = 0,
  Center = 1,
  Right = 2,
}

enum textOverflowPolicy {
  None = 0,
  DotsEnd = 1,
  DotsEndLastLine = 2,
  AutoScroll = 3,
  PingPongScroll = 4,
  AdjustToSize = 5,
}

public native struct textTextBlockFontStyle {
  native let fontStyle: CName;
  native let outlineSize: Int32;
  native let outlineColor: HDRColor;
}

public native struct textTextBlockStyle {
  native let tintColor: HDRColor;
  native let shadowOffset: Vector2;
  native let shadowColor: HDRColor;
  native let fontStyle: textTextBlockFontStyle;
  native let fontSize: Uint16;
}

enum textTextDirection {
  LeftToRight = 0,
  RightToLeft = 1,
  Mixed = 2,
}

enum textTextFlowDirection {
  Auto = 0,
  LeftToRight = 1,
  RightToLeft = 2,
}

enum textTextShapingMethod {
  Auto = 0,
  KerningOnly = 1,
  FullShaping = 2,
}

public native struct textWrappingInfo {
  native let autoWrappingEnabled: Bool;
  native let wrappingAtPosition: Float;
  native let wrappingPolicy: textWrappingPolicy;
  native let forceMinimumWidthToWrappingAtPosition: Bool;
}

enum textWrappingPolicy {
  Default = 0,
  PerCharacter = 1,
}

public abstract native class ThreatPositionProvider extends IPositionProvider {}

public native class ThreatValid extends AIEvent {
  native let owner: wref<Entity>;
  native let threat: wref<Entity>;
  native let isEnemy: Bool;
  native let isHostile: Bool;
}

public native class TimeOfDayVisibilityResource extends CResource {}

public importonly native class ToggleForbiddenVehicleAreaEvent extends Event {}

public importonly native class ToggleQuestCustomFPPLockOffEvent extends Event {}

public importonly native class ToggleRadioReceiver extends Event {}

public native class TonemappingAreaSettings extends IAreaSettings {
  native let mode: ref<ITonemappingMode>;
  native let hdrMode: ref<ITonemappingMode>;
}

public native class TonemappingModeACES extends ITonemappingMode {
  native let params: STonemappingACESParams;
}

public native class TonemappingModeACESApprox extends ITonemappingMode {}

public native class TonemappingModeLinear extends ITonemappingMode {}

public native class TonemappingModeLottes extends ITonemappingMode {
  native let maxInput: Float;
  native let contrast: Float;
  native let midIn: Float;
  native let midOut: Float;
  native let crosstalk: Vector3;
  native let crosstalkSaturation: Vector3;
}

public native class TonemappingModeLottesACES extends ITonemappingMode {
  native let maxInput: Float;
  native let contrast: Float;
  native let midIn: Float;
  native let midOut: Float;
}

public native struct toolsEditorObjectIDPath {}

public abstract native class toolsIMessageLocation extends ISerializable {}

public abstract native class toolsIMessageToken extends ISerializable {}

public abstract native class toolsIResolverUserContext extends ISerializable {}

public native class toolsJiraAddAttachmentsResult extends ISerializable {
  native let array: array<toolsJiraAttachment>;
}

public native struct toolsJiraAttachment {
  native let id: String;
  native let filename: String;
  native let content: String;
  native let thumbnail: String;
}

public native class toolsJiraCommentIssueBody extends ISerializable {
  native let body: String;
}

public native class toolsJiraCommentIssueResult extends ISerializable {
  native let errorMessages: array<String>;
}

public native class toolsJiraCreateIssueBody extends ISerializable {
  native let fields: toolsJiraIssueFields;
}

public native class toolsJiraCreateIssueResult extends ISerializable {
  native let id: String;
  native let key: String;
  native let errorMessages: array<String>;
  native let errors: toolsJiraIssueFieldsResult;
}

public native class toolsJiraCurrentUserInfo extends ISerializable {
  native let name: String;
}

public native struct toolsJiraCustomFieldId {
  native let id: String;
}

public native struct toolsJiraCustomFieldName {
  native let name: String;
}

public native struct toolsJiraCustomFieldValue {
  native let value: String;
}

public native class toolsJiraEditIssueBody extends ISerializable {
  native let fields: toolsJiraIssueFields;
}

public native class toolsJiraEditIssueResult extends ISerializable {
  native let errorMessages: array<String>;
  native let errors: toolsJiraIssueFieldsResult;
}

public native struct toolsJiraFixVersion {
  native let id: String;
}

public native struct toolsJiraIssue {
  native let id: String;
  native let self: String;
  native let key: String;
  native let fields: toolsJiraIssueFields;
}

public native struct toolsJiraIssueFields {
  native let project: toolsJiraProject;
  native let status: toolsJiraStatus;
  native let resolution: toolsJiraResolution;
  native let summary: String;
  native let issuetype: toolsJiraIssueType;
  native let priority: toolsJiraPriority;
  native let labels: array<String>;
  native let assignee: toolsJiraCustomFieldName;
  native let description: String;
  native let versions: array<toolsJiraCustomFieldId>;
  native let fixVersions: array<toolsJiraFixVersion>;
  native let flagPosition: String;
  native let components: array<toolsJiraCustomFieldName>;
  native let attachment: array<toolsJiraAttachment>;
  native let customfield_17400: toolsJiraCustomFieldId;
  native let customfield_18373: String;
  native let customfield_34100: toolsJiraCustomFieldValue;
  native let customfield_15306: array<toolsJiraCustomFieldValue>;
  native let customfield_13009: String;
  native let customfield_10013: String;
  native let customfield_10503: String;
  native let customfield_10502: String;
  native let customfield_34718: array<toolsJiraCustomFieldValue>;
  native let customfield_36106: array<toolsJiraCustomFieldValue>;
  native let customfield_10006: String;
  native let customfield_10505: toolsJiraCustomFieldValue;
  native let customfield_10603: array<toolsJiraCustomFieldValue>;
  native let customfield_24700: String;
  native let customfield_34706: array<toolsJiraCustomFieldValue>;
  native let customfield_25500: toolsJiraCustomFieldValue;
  native let customfield_15808: array<toolsJiraCustomFieldValue>;
  native let customfield_33701: String;
  native let customfield_18006: String;
  native let customfield_29900: toolsJiraCustomFieldValue;
  native let customfield_10005: String;
  native let customfield_10606: String;
  native let customfield_31700: String;
}

public native struct toolsJiraIssueFieldsResult {
  native let project: String;
  native let summary: String;
  native let issuetype: String;
  native let priority: String;
  native let labels: String;
  native let assignee: String;
  native let description: String;
  native let versions: String;
  native let fixVersions: String;
  native let flagPosition: String;
  native let components: String;
  native let attachments: array<toolsJiraAttachment>;
  native let customfield_17400: String;
  native let customfield_18373: String;
  native let customfield_34100: String;
  native let customfield_15306: String;
  native let customfield_13009: String;
  native let customfield_10013: String;
  native let customfield_10503: String;
  native let customfield_10502: String;
  native let customfield_34718: String;
  native let customfield_36106: String;
  native let customfield_10006: String;
  native let customfield_10505: String;
  native let customfield_10603: String;
  native let customfield_24700: String;
  native let customfield_34706: String;
  native let customfield_25500: String;
  native let customfield_15808: String;
  native let customfield_33701: String;
  native let customfield_18006: String;
  native let customfield_29900: String;
  native let customfield_10005: String;
  native let customfield_10606: String;
  native let customfield_10002: String;
}

public native struct toolsJiraIssueTransition {
  native let id: String;
}

public native struct toolsJiraIssueType {
  native let name: String;
}

public native struct toolsJiraPerson {
  native let name: String;
  native let key: String;
  native let displayName: String;
}

public native struct toolsJiraPriority {
  native let name: String;
}

public native struct toolsJiraProject {
  native let key: String;
  native let name: String;
}

public native struct toolsJiraResolution {
  native let name: String;
  native let id: String;
}

public native class toolsJiraSearchIssuesResult extends ISerializable {
  native let startAt: Uint32;
  native let maxResults: Uint32;
  native let total: Uint32;
  native let issues: array<toolsJiraIssue>;
  native let errorMessages: array<String>;
  native let warningMessages: array<String>;
}

public native struct toolsJiraService {}

public native struct toolsJiraStatus {
  native let name: String;
  native let id: String;
}

public native class toolsJiraTransitionIssueBody extends ISerializable {
  native let transition: toolsJiraIssueTransition;
}

public native struct toolsLastNodeSelection {
  native let editorName: String;
  native let selectedNodeIDPath: toolsEditorObjectIDPath;
}

public native struct toolsMessage {
  native let severity: toolsMessageSeverity;
  native let created: Int64;
  native let location: ref<toolsIMessageLocation>;
  native let tokens: array<ref<toolsIMessageToken>>;
  native let verbosity: toolsMessageVerbosity;
}

public native class toolsMessageLocation_BoundingBox extends toolsIMessageLocation {
  native let box: Box;
}

public native class toolsMessageLocation_EditorObject extends toolsIMessageLocation {
  native let path: toolsEditorObjectIDPath;
}

public native class toolsMessageLocation_Point extends toolsIMessageLocation {
  native let point: Vector3;
}

public native class toolsMessageLocation_Resource extends toolsIMessageLocation {}

public native class toolsMessageLocation_Webpage extends toolsIMessageLocation {
  native let link: String;
  native let text: String;
}

enum toolsMessageSeverity {
  Success = 0,
  Info = 1,
  Warning = 2,
  Error = 3,
}

public native class toolsMessageToken_Location extends toolsIMessageToken {
  native let location: ref<toolsIMessageLocation>;
}

public native class toolsMessageToken_Name extends toolsIMessageToken {
  native let name: CName;
}

public native class toolsMessageToken_Text extends toolsIMessageToken {
  native let text: String;
}

enum toolsMessageTokenType {
  Text = 0,
  Location = 1,
  Tag = 2,
}

enum toolsMessageVerbosity {
  Normal = 0,
  Verbose = 1,
}

public native struct toolsVisualTagsDefinition {
  native let name: CName;
}

public native class toolsVisualTagsGroup extends ISerializable {
  native let name: CName;
  native let tags: array<toolsVisualTagsDefinition>;
}

public native class toolsVisualTagsRoot extends ISerializable {
  native let schemas: array<toolsVisualTagsSchema>;
}

public native class toolsVisualTagsSchema extends ISerializable {
  native let name: CName;
  native let categories: array<toolsVisualTagsGroup>;
  native let presets: array<toolsVisualTagsGroup>;
}

public native class TPPCameraComponent extends CameraComponent {}

enum TrafficGenDynamicImpact {
  Ignored = 0,
  Blocking = 1,
}

public native struct TrafficGenDynamicTrafficSetting {
  native let impact: TrafficGenDynamicImpact;
}

enum TrafficGenMeshImpact {
  UseNavigation = 0,
  ForceIgnored = 1,
  ForceBlocking = 2,
}

public native struct TrafficGenTrafficSetting {
  native let meshImpact: TrafficGenMeshImpact;
}

public native class TriggerDestructionEvent extends Event {
  native let velocity: Float;
}

public native class TweakDBResource extends CResource {}

public native struct TweakExecutionContext {}

public native class UIFunctionalTests extends IScriptable {
  public final native func EnableExitGameAction()
  public final native func GetPlaybackFailInfo()
  public final native func GetPlaybackResult()
  public final native func HideHUD()
  public final native func IsInGameMenuVisible()
  public final native func IsMessageBoxVisible()
  public final native func IsPlaying()
  public final native func LockGameStatesTransitions()
  public final native func Play()
}

public native class UIGameContextChangedEvent extends Event {}

public native class UIIconsGeneratorSystem extends IUIIconsGeneratorSystem {}

public native class UIObjectsLoaderSystemListener extends gameuiIUIObjectsLoaderSystemListener {}

enum UpdateBucketEnum {
  Vehicle = 0,
  Character = 1,
  AttachedObject = 2,
}

public native class UsedSpotTokensList extends ISerializable {
  native let tokens: array<AISpotUsageToken>;
}

enum UserSettingsSaveStatus {
  NotSaved = 0,
  InternalError = 1,
  Saved = 2,
}

public importonly native class VehicleAIMountedE3Hack extends Event {}

enum vehicleAIPathTrafficDeletionMode {
  INSTANT = 0,
  OUT_OF_VIEW = 1,
  DEFERRED = 2,
}

public native class vehicleAnimFeature_VehicleProceduralCamera extends AnimFeature {
  native let cameraTranslationVS: Vector4;
  native let cameraOrientationVS: Quaternion;
  native let cameraTargetWeight: Float;
}

public importonly native class VehicleApplyZOffsetFromGroundEvent extends Event {
  native let sampleNavmesh: Bool;
}

public native class vehicleArmedCarBaseObject extends CarObject {}

public importonly native class VehicleAssignConvoyEvent extends Event {}

public importonly native struct vehicleAudio {}

public native class vehicleAudioComponent extends SoundComponentBase {}

public native struct vehicleAudioPSData {
  native persistent let activeRadioStation: CName;
  native persistent let acousticIsolationFactor: Float;
  native persistent let glassAcousticIsolationFactor: Float;
  native persistent let isPlayerVehicleSummoned: Bool;
}

public native class vehicleAudioVehicleCurveSet extends CurveSet {}

public native class vehicleAutonomousData extends ISerializable {
  native let owner: wref<VehicleObject>;
  native let useKinematic: Bool;
  native let needDriver: Bool;
  native let aggressiveRammingEnabled: Bool;
  native let ignoreChaseVehiclesLimit: Bool;
  native let boostDrivingStats: Bool;
  native let targetObjToReach: wref<GameObject>;
  native let targetObjToFollow: wref<GameObject>;
  native let targetRef: NodeRef;
  native let splineRef: NodeRef;
  native let splineRefBackwards: NodeRef;
  native let vehicleRef: EntityReference;
  native let targetPosition: Vector3;
  native let drivingID: TweakDBID;
  native let distanceMin: Float;
  native let distanceMax: Float;
  native let wantToStop: Bool;
  native let stopHasReachedTarget: Bool;
  native let driveBackwards: Bool;
  native let reverseSpline: Bool;
  native let startFromClosest: Bool;
  native let canClearActions: Bool;
  native let keepDistanceParamBool: Bool;
  native let keepDistanceParamCompanion: wref<GameObject>;
  native let keepDistanceParamDistance: Float;
  native let rubberBandingBool: Bool;
  native let rubberBandingTargetRef: wref<GameObject>;
  native let rubberBandingTargetForwardOffset: Float;
  native let rubberBandingMinDistance: Float;
  native let rubberBandingMaxDistance: Float;
  native let rubberBandingStopAndWait: Bool;
  native let rubberBandingTeleportToCatchUp: Bool;
  native let rubberBandingStayInFront: Bool;
  native let secureTimeOut: Float;
  native let portalsList: ref<vehiclePortalsList>;
  native let trafficTryNeighborsForStart: Bool;
  native let trafficTryNeighborsForEnd: Bool;
  native let ignoreNoAIDrivingLanes: Bool;
  native let allowSimplifiedMovement: Bool;
  native let ignoreTickets: Bool;
  native let disableStuckDetection: Bool;
  native let tryDriveAwayFromPlayer: Bool;
  native let useSpeedBasedLookupRange: Bool;
  native let clearTrafficOnPath: Bool;
  native let emergencyPatrol: Bool;
  native let numPatrolLoops: Uint32;
}

public native struct vehicleAutopilot {}

public native struct vehicleAutopilotTransformProvider {}

enum vehicleBikeCurve {
  SpeedToTilt = 0,
  InputToTilt = 1,
  SpeedToTiltSpeed = 2,
}

public native class vehicleBikeCurveSet extends CurveSet {}

public native class vehicleCameraManagerComponentPS extends GameComponentPS {
  native persistent let perspective: vehicleCameraPerspective;
}

public native class vehicleChangeAlarmEvent extends Event {}

public native class vehicleChangeHeadLightModeEvent extends Event {}

public native class vehicleChangeMovableEvent extends Event {}

public native class vehicleChassisComponent extends IPlacedComponent {
  native let collisionResource: ResourceRef; // rRef<physicsSystemResource>
  native let optionalPlayerOnlyCollisionResource: ResourceRef; // rRef<physicsSystemResource>
}

public importonly native class VehicleContactEvent extends Event {
  native let otherVehicle: wref<GameObject>;
}

public native struct vehicleDestructionPSData {
  native persistent let gridValues: [Float; 30];
  native persistent let brokenGlass: Uint32;
  native persistent let brokenLights: Uint32;
  native persistent let flatTire: Uint8;
  native persistent let windshieldShattered: Bool;
  native persistent let windshieldPoints: array<Vector3>;
  native persistent let detachedParts: array<CName>;
}

public importonly native class VehicleDetachAllPartsEvent extends Event {}

public native class vehicleDriveFollowEvent extends Event {
  native let targetObjToFollow: wref<GameObject>;
  native let distanceMin: Float;
  native let distanceMax: Float;
  native let stopWhenTargetReached: Bool;
  native let useTraffic: Bool;
}

public native class vehicleDriveFollowSplineEvent extends Event {
  native let splineRef: NodeRef;
  native let backwards: Bool;
  native let reverseSpline: Bool;
}

public native struct vehicleDriver {}

public native class vehicleDriveSplineReverseEvent extends Event {
  native let splineRef: NodeRef;
  native let backwards: Bool;
  native let reverseSpline: Bool;
}

public native class vehicleDriveToGameObjectEvent extends Event {
  native let targetObjToReach: wref<GameObject>;
}

public native class vehicleDriveToNodeRefEvent extends Event {
  native let targetRef: NodeRef;
  native let useTraffic: Bool;
  native let speedInTraffic: Float;
}

public native class vehicleDriveToPointEvent extends Event {
  native let targetPos: Vector3;
  native let useTraffic: Bool;
  native let speedInTraffic: Float;
}

enum vehicleESummonedVehicleType {
  Any = 0,
  Car = 1,
  Motorcycle = 2,
}

enum vehicleEVehicleSpeedConditionType {
  CT_EQUAL = 0,
  CT_NOT_EQUAL = 1,
  CT_GREATER = 2,
  CT_GREATER_EQUAL = 3,
  CT_LESS = 4,
  CT_LESS_EQUAL = 5,
  CT_ABS_GREATER = 6,
  CT_ABS_GREATER_EQUAL = 7,
  CT_ABS_LESS = 8,
  CT_ABS_LESS_EQUAL = 9,
}

public native struct vehicleFollowObject {}

public importonly native struct vehicleForbiddenAreaState {
  native let globalNodeIDHash: Uint64;
  native let enabled: Bool;
  native let dismount: Bool;
  native let blockCombat: Bool;
}

public native struct vehicleFormation {}

enum vehicleFormationType {
  FORMATION_TRIANGLE = 0,
  FORMATION_TURTLE = 1,
  FORMATION_QUINCUNX = 2,
}

public native struct vehicleGarageComponentVehicleData {
  native persistent let spawnRecordID: TweakDBID;
  native persistent let entityID: EntityID;
  native persistent let vehicleNameNodeRef: NodeRef;
  native persistent let despawnOnDistanceEnabled: Bool;
}

public importonly native class VehicleHasExplodedEvent extends Event {}

public native class vehicleLightComponent extends gameLightComponent {
  native let allowSeparateEmissiveColor: Bool;
  native let emissiveColor: Color;
  native let lightType: vehicleELightType;
  native let highBeamPitchAngle: Float;
  native let highBeamRadiusMultiplier: Float;
  native let highBeamConeMultiplier: Float;
}

public native class vehicleNetrunnerQuickhackVehicleEndedEvent extends Event {
  native let vehicleNetrunnerQuickhackType: VehicleNetrunnerQuickhackType;
  native let shouldTriggerPanicDriving: Bool;
  native let shouldRejoinTraffic: Bool;
}

public native class vehiclePersistentData extends GameComponent {}

public native class vehiclePersistentDataPS extends GameComponentPS {
  native persistent let flags: Uint32;
  native persistent let autopilotPos: Float;
  native persistent let autopilotCurrentSpeed: Float;
  native persistent let isHackable: Bool;
  native persistent let questEnforcedTransform: Transform;
  native persistent let destruction: vehicleDestructionPSData;
  native persistent let audio: vehicleAudioPSData;
}

public native struct vehiclePlayerToAIBlendInterpolator {}

enum vehiclePlayerToAIInterpolationType {
  PTAIT_INSTANT = 0,
  PTAIT_LINEAR = 1,
  PTAIT_EASE_IN_QUAD = 2,
  PTAIT_EASE_IN_CUBIC = 3,
  PTAIT_EASE_OUT_CUBIC = 4,
  PTAIT_EASE_IN_OUT_CUBIC = 5,
  PTAIT_EASE_IN_QUANTIC = 6,
  PTAIT_EASE_IN_SIN = 7,
  PTAIT_EASE_OUT_SIN = 8,
  PTAIT_EASE_IN_OUT_SIN = 9,
  PTAIT_LINEAR_NON_SMOOTHED = 10,
  PTAIT_EASE_IN_QUAD_NON_SMOOTHED = 11,
  PTAIT_EASE_IN_CUBIC_NON_SMOOTHED = 12,
  PTAIT_EASE_OUT_CUBIC_NON_SMOOTHED = 13,
  PTAIT_EASE_IN_OUT_CUBIC_NON_SMOOTHED = 14,
  PTAIT_EASE_IN_QUANTIC_NON_SMOOTHED = 15,
  PTAIT_EASE_IN_SIN_NON_SMOOTHED = 16,
  PTAIT_EASE_OUT_SIN_NON_SMOOTHED = 17,
  PTAIT_EASE_IN_OUT_SIN_NON_SMOOTHED = 18,
}

public native class VehicleSlotsState extends ISerializable {
  native persistent let vehicleDoorState: VehicleDoorState;
  native persistent let vehicleWindowState: EVehicleWindowState;
  native persistent let vehicleInteractionState: VehicleDoorInteractionState;
}

public native struct vehicleSplineSlot_NonAnimSpline {}

public native struct vehicleSplineSlot {}

public importonly native class VehicleStartConvoyEvent extends Event {}

public native class vehicleStartDynamicMovementEvent extends Event {
  native let targetPosition: Vector3;
}

public native class vehicleStopDriveToPointEvent extends Event {}

enum vehicleSummonFinishState {
  Arrived = 0,
}

public importonly native class VehicleTeleportEvent extends Event {}

public importonly native class VehicleToggleDoorOpenEvent extends Event {}

public importonly native class VehicleToggleQuestForceBrakingEvent extends Event {}

public importonly native class VehicleToggleQuestWeaponEnabledEvent extends Event {}

public native class vehicleTPPCameraComponent extends CameraComponent {}

enum vehicleTPPCameraDistance {
  Close = 0,
  Medium = 1,
  Far = 2,
  DriverCombatClose = 3,
  DriverCombatMedium = 4,
  DriverCombatFar = 5,
}

enum vehicleTPPCameraHeight {
  Low = 0,
  High = 1,
}

public importonly native class VehicleTryKnockPlayerCarSurfingDownEvent extends Event {
  native let impactPoint: Vector3;
}

public native struct vehicleUnlockedVehicle {
  native persistent let vehicleID: GarageVehicleID;
  native persistent let health: Float;
}

public importonly native class vehicleVehicleAudioMultipliersEvent extends Event {
  native let multipliers: audioVehicleMultipliers;
}

public native class vehicleVehicleMountableComponent extends MountableComponent {}

public native class vehicleVehicleProxyBlendCamera extends CameraComponent {}

public native struct vehicleVisualPerception {}

public importonly native class VehicleWheelPressureEvent extends Event {
  native let contactPoint: Vector3;
  native let impulse: Vector3;
}

public native struct vehicleWheelRuntimePSData {
  native persistent let previousTouchedMaterial: CName;
  native persistent let previousVisualDisplacement: Float;
  native persistent let previousLogicalSpringCompression: Float;
  native persistent let previousSwaybarDisplacement: Float;
  native persistent let previousDampedSpringForce: Float;
}

public native class VelocityEvaluator extends PhysicsParticleInitializer {}

public native class VelocityInheritEvaluator extends PhysicsParticleInitializer {}

public native class VelocitySpreadEvaluator extends PhysicsParticleInitializer {}

public native class vgAttributeTypeValuePair extends ISerializable {
  native let pe: vgEStyleAttributeType;
  native let lue: Variant;
}

public abstract native class vgBaseVectorGraphicShape extends ISerializable {
  native let calTransform: Matrix;
  native let yle: ref<vgVectorGraphicStyle>;
}

enum vgEStyleAttributeType {
  FillColor = 0,
  StrokeColor = 1,
  StrokeSize = 2,
  StrokeMiterLimit = 3,
  FontFamily = 4,
  FontSize = 5,
}

public native class vgVectorGraphicDefinition extends ISerializable {
  native let rootShapeGroup: ref<vgVectorGraphicShape_Group>;
  native let dimensions: Vector2;
}

public native class vgVectorGraphicShape_Circle extends vgBaseVectorGraphicShape {
  native let dius: Float;
}

public native class vgVectorGraphicShape_Group extends vgBaseVectorGraphicShape {
  native let childShapes: array<ref<vgBaseVectorGraphicShape>>;
}

public native class vgVectorGraphicShape_Polygon extends vgBaseVectorGraphicShape {
  native let ints: array<Vector2>;
}

public native class vgVectorGraphicShape_PolyLine extends vgBaseVectorGraphicShape {
  native let ints: array<Vector2>;
  native let roke: Float;
}

public native class vgVectorGraphicShape_Rect extends vgBaseVectorGraphicShape {
  native let mensions: Vector2;
}

public native class vgVectorGraphicShape_Text extends vgBaseVectorGraphicShape {
  native let xt: String;
}

public native class vgVectorGraphicStyle extends ISerializable {
  native let attributes: array<vgAttributeTypeValuePair>;
}

public native class ViewportWidget extends inkCanvas {}

public native class VignetteAreaSettings extends IAreaSettings {
  native let vignetteEnabled: Bool;
  native let vignetteRadius: Float;
  native let vignetteExp: Float;
  native let vignetteColor: Color;
}

public abstract native class visIOccluderResource extends ISerializable {
  native let resourceHash: Uint32;
}

public native class visOccluderMeshResource extends visIOccluderResource {
  native let resourceVersion: Uint32;
  native let boundingBox: Box;
  native let twoSided: Bool;
}

public native class VisualStateBlackBarsVisibilityChangedEvent extends Event {
  native let blackBarsVisible: Bool;
}

enum visWorldOccluderType {
  Default = 0,
  None = 1,
  Detail = 2,
  MinorInterior = 3,
  MajorInterior = 4,
  Exterior = 5,
}

public native class VoicePlayedEvent extends Event {
  native let eventName: CName;
  native let gruntType: audioVoGruntType;
  native let isV: Bool;
}

public native class VoicePlayEvent extends Event {
  native let eventName: CName;
  native let gruntType: audioVoGruntType;
  native let gruntInterruptMode: audioVoGruntInterruptMode;
  native let isV: Bool;
}

public native class VolumetricFogAreaSettings extends IAreaSettings {
  native let albedo: CurveDataHDRColor;
  native let range: CurveDataFloat;
  native let fogHeight: CurveDataFloat;
  native let fogHeightFalloff: CurveDataFloat;
  native let fogHeightMaxCut: CurveDataFloat;
  native let density: CurveDataFloat;
  native let absorption: CurveDataFloat;
  native let ambientScale: CurveDataFloat;
  native let localAmbientScale: CurveDataFloat;
  native let globalLightScale: CurveDataFloat;
  native let globalLightAnisotropy: CurveDataFloat;
  native let globalLightAnisotropyBase: CurveDataFloat;
  native let globalLightAnisotropyScale: CurveDataFloat;
  native let localLightRange: CurveDataFloat;
  native let localLightScale: CurveDataFloat;
  native let distantAlbedo: CurveDataHDRColor;
  native let distantGlobalLightScale: CurveDataFloat;
  native let distantGroundIrradiance: CurveDataFloat;
  native let distantGroundSaturation: CurveDataFloat;
  native let distantSkyIrradiance: CurveDataFloat;
  native let distantShadowAmbientDarkening: CurveDataFloat;
}

public native class WasScannedPrereqState extends PrereqState {}

public native class WaterAreaSettings extends IAreaSettings {
  native let blurMin: Float;
  native let blurMax: Float;
  native let blurExponent: Float;
  native let depth: Float;
  native let density: Float;
  native let lightAbsorptionColor: HDRColor;
  native let lightDecayColor: HDRColor;
  native let globalWaterMask: ResourceRef; // rRef<CBitmapTexture>
  native let windDir: CurveDataFloat;
  native let windSpeed: CurveDataFloat;
  native let windScale: CurveDataFloat;
  native let amplitude: CurveDataFloat;
  native let lambda: CurveDataFloat;
}

public importonly native class WeaponReloadFinishEvent extends Event {}

public importonly native class WeaponReloadInterruptedEvent extends Event {}

public importonly native class WeaponReloadStartEvent extends Event {}

public native class WetnessComponent extends IComponent {}

public native class WidgetMenuComponent extends WidgetMenuComponentInterface {}

public native class WidgetMenuComponentInterface extends WidgetBaseComponent {
  native let widgetResource: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let cursorResource: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let externalMaterial: ResourceRef; // rRef<CMaterialTemplate>
  native let meshTargetBinding: ref<worlduiMeshTargetBinding>;
}

public native class WindAreaSettings extends IAreaSettings {
  native let strength: CurveDataFloat;
  native let direction: CurveDataVector4;
}

public native class workActorTagCondition extends workIWorkspotCondition {
  native let tag: CName;
}

public native class workAnimClip extends workIEntry {
  native let animName: CName;
  native let blendOutTime: Float;
}

public native class workAnimClipWithItem extends workAnimClip {
  native let itemActions: array<ref<workIWorkspotItemAction>>;
}

public native class workBodytypeCondition extends workIWorkspotCondition {
  native let rig: ResourceAsyncRef; // raRef<animRig>
}

public native class workConditionalSequence extends workSequence {
  native let multipleConditionOperator: workLogicalOperation;
  native let conditionList: array<ref<workIWorkspotCondition>>;
}

public native class workCoverTypeCondition extends workIWorkspotCondition {
  native let isHighCover: Bool;
}

public abstract native struct workDebuggingTool {}

public native class workEntryAnim extends workIEntry {
  native let animName: CName;
  native let idleAnim: CName;
  native let movementType: moveMovementType;
  native let orientationType: moveMovementOrientationType;
  native let isSynchronized: Bool;
  native let slotName: CName;
  native let syncOffset: Transform;
  native let blendOutTime: Float;
}

public native class workEquipInventoryWeaponAction extends workIWorkspotItemAction {
  native let weaponType: workWeaponType;
  native let keepEquippedAfterExit: Bool;
  native let fallbackItem: TweakDBID;
  native let fallbackSlot: TweakDBID;
}

public native class workEquipItemToSlotAction extends workIWorkspotItemAction {
  native let item: TweakDBID;
  native let itemSlot: TweakDBID;
}

public native class workEquipPropToSlotAction extends workIWorkspotItemAction {
  native let itemId: CName;
  native let itemSlot: TweakDBID;
  native let attachMethod: workPropAttachMethod;
  native let customOffsetPos: Vector3;
  native let customOffsetRot: Quaternion;
}

public native class workExitAnim extends workIEntry {
  native let animName: CName;
  native let disableAutoTransition: Bool;
  native let idleAnim: CName;
  native let movementType: moveMovementType;
  native let isSynchronized: Bool;
  native let stayOnNavmesh: Bool;
  native let snapZToNavmesh: Bool;
  native let forceNoZSnap: Bool;
  native let slotName: CName;
  native let syncOffset: Transform;
  native let disableRandomExit: Bool;
}

public native class workFastExit extends workIEntry {
  native let animName: CName;
  native let forcedBlendIn: Float;
  native let movementType: moveMovementType;
}

public abstract native class workIContainerEntry extends workIEntry {
  native let list: array<ref<workIEntry>>;
  native let disableAutoTransition: Bool;
  native let idleAnim: CName;
}

public abstract native class workIEntry extends ISerializable {
  native let id: WorkEntryId;
  native let flags: Uint32;
}

public native class workInSyncCondition extends workIWorkspotCondition {}

public native class workIsPlayerCondition extends workIWorkspotCondition {}

public native class workIsSyncMasterCondition extends workIWorkspotCondition {}

public native class workIsSyncSlaveCondition extends workIWorkspotCondition {}

public abstract native struct workIWorkspotCommandData {}

public abstract native class workIWorkspotCondition extends ISerializable {
  native let expectedResult: workWorkspotLogic;
  native let equals: Bool;
}

public abstract native class workIWorkspotItemAction extends ISerializable {}

public abstract native class workIWorkspotQuestAction extends ISerializable {}

enum workLogicalOperation {
  AND = 0,
  OR = 1,
}

public native class workLookAtDrivenTurn extends workIEntry {
  native let turnAngle: Int32;
  native let turnAnimName: CName;
  native let blendTime: Float;
}

public native class workMotionAnimClip extends workAnimClip {}

public native class workPauseClip extends workIEntry {
  native let timeMin: Float;
  native let timeMax: Float;
  native let blendOutTime: Float;
}

enum workPropAttachMethod {
  BonePosition = 0,
  RelativePosition = 1,
  Custom = 2,
}

public native class workRandomList extends workIContainerEntry {
  native let minClips: Int8;
  native let maxClips: Int8;
  native let pauseBetweenLength: Float;
  native let pauseLengthDeviation: Float;
  native let weights: array<Float>;
  native let pauseBlendOutTime: Float;
  native let dontRepeatLastAnims: Int8;
}

public native class workReactionSequence extends workIContainerEntry {
  native let forcedBlendIn: Float;
  native let reactionTypes: array<TweakDBID>;
  native let mainEmotionalState: CName;
  native let emotionalExpression: CName;
  native let facialKeyWeight: Float;
  native let facialIdleMaleAnimation: CName;
  native let facialIdleKey_MaleAnimation: CName;
  native let facialIdleFemaleAnimation: CName;
  native let facialIdleKey_FemaleAnimation: CName;
}

public native class workScriptedCondition extends workIWorkspotCondition {
  native let script: ref<WorkspotCondition>;
}

public native class workSelector extends workRandomList {}

public native class workSequence extends workIContainerEntry {
  native let previousLoopInfinitely: Bool;
  native let loopInfinitely: Bool;
  native let category: gamedataWorkspotCategory;
}

public importonly native class WorkspotManager extends IWorkspotManager {}

public native class workStopWorkspotQuestAction extends workIWorkspotQuestAction {
  native let allowCurrAnimToFinish: Bool;
  native let exitAnim: CName;
}

public native class workSyncAnimClip extends workAnimClip {
  native let slotName: CName;
  native let syncOffset: Transform;
}

public native class workSyncMasterEntryAnim extends workEntryAnim {}

public native class workTagNode extends workIEntry {
  native let tag: CName;
}

public native class workTimeOfDayCondition extends workIWorkspotCondition {
  native let activeAfter: GameTime;
  native let activeUntil: GameTime;
}

public native struct workTransitionAnim {
  native let idleA: CName;
  native let idleB: CName;
  native let transitionAtoB: CName;
  native let transitionBtoA: CName;
}

public native class workUnequipFromSlotAction extends workIWorkspotItemAction {
  native let itemSlot: TweakDBID;
}

public native class workUnequipItemAction extends workIWorkspotItemAction {
  native let item: TweakDBID;
}

public native class workUnequipPropAction extends workIWorkspotItemAction {
  native let itemId: CName;
}

enum workWeaponType {
  Any = 0,
  Ranged = 1,
  OneHandedRanged = 2,
  AssaultRifle = 3,
  Hammer = 8,
  Handgun = 9,
  HeavyMachineGun = 10,
  Katana = 11,
  Knife = 12,
  LightMachineGun = 13,
  LongBlade = 14,
  Melee = 16,
  OneHandedClub = 17,
  PrecisionRifle = 18,
  Revolver = 19,
  Rifle = 20,
  ShortBlade = 21,
  Shotgun = 22,
  ShotgunDual = 23,
  SniperRifle = 24,
  SubmachineGun = 25,
  TwoHandedClub = 27,
}

public native struct workWorkspotAnimsetEntry {
  native let rig: ResourceAsyncRef; // raRef<animRig>
  native let animations: animAnimSetup;
  native let loadingHandles: array<ResourceRef>;
}

public native struct workWorkspotGlobalProp {
  native let id: CName;
  native let boneName: CName;
  native let prop: ResourceAsyncRef; // raRef<entEntityTemplate>
}

public native struct workWorkspotItemOverride {
  native let propOverrides: array<workWorkspotItemOverridePropOverride>;
  native let itemOverrides: array<workWorkspotItemOverrideItemOverride>;
}

public native struct workWorkspotItemOverrideItemOverride {
  native let prevItemId: TweakDBID;
  native let newItemId: TweakDBID;
}

public native struct workWorkspotItemOverridePropOverride {
  native let prevItemId: CName;
  native let newItemId: CName;
}

enum workWorkspotLogic {
  Allow = 0,
  Deny = 1,
}

public native class workWorkspotResource extends animAnimGraph {
  native let workspotTree: ref<workWorkspotTree>;
}

public native class workWorkspotSystem extends worldIWorkspotSystem {}

public native class workWorkspotTree extends ISerializable {
  native let workspotRig: ResourceAsyncRef; // raRef<animRig>
  native let globalProps: array<workWorkspotGlobalProp>;
  native let propsPlaySyncAnim: Bool;
  native let rootEntry: ref<workIEntry>;
  native let idCounter: Uint32;
  native let dontInjectWorkspotGraph: Bool;
  native let animGraphSlotName: CName;
  native let autoTransitionBlendTime: Float;
  native let initialActions: array<ref<workIWorkspotItemAction>>;
  native let initialCanUseExits: Bool;
  native let blendOutTime: Float;
  native let finalAnimsets: array<workWorkspotAnimsetEntry>;
  native let tags: redTagList;
  native let customTransitionAnims: array<workTransitionAnim>;
  native let inertializationDurationEnter: Float;
  native let inertializationDurationExitNatural: Float;
  native let inertializationDurationExitForced: Float;
  native let useTimeLimitForSequences: Bool;
  native let frezeAtTheLastFrame_UseWithCaution: Bool;
  native let sequencesTimeLimit: Float;
  native let snapToTerrain: Bool;
  native let unmountBodyCarry: Bool;
  native let statusEffectID: TweakDBID;
  native let whitelistVisualTags: redTagList;
  native let blacklistVisualTags: redTagList;
}

public native struct worldAcousticDataCell {
  native let sectorId: Uint32;
}

public native class worldAcousticDataResource extends resStreamedResource {
  native let cells: array<worldAcousticDataCell>;
}

public native class worldAcousticPortalNode extends worldNode {
  native let radius: Uint8;
  native let nominalRadius: Uint8;
}

public native class worldAcousticPortalNodeInstance extends worldINodeInstance {}

public native class worldAcousticSectorNode extends worldNode {
  native let data: ResourceAsyncRef; // raRef<worldAcousticDataResource>
  native let inSectorCoordsX: Uint32;
  native let inSectorCoordsY: Uint32;
  native let inSectorCoordsZ: Uint32;
  native let generatorId: Uint32;
  native let edgeMask: Uint8;
}

public native class worldAcousticSectorNodeInstance extends worldINodeInstance {}

public native class worldAcousticsOutdoornessAreaNode extends worldAreaShapeNode {
  native let outdoor: Float;
}

public native class worldAcousticsOutdoornessAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldAcousticZoneNode extends worldNode {
  native let isBlocker: Bool;
  native let tagName: CName;
  native let tagSpread: Float;
}

public native class worldAcousticZoneNodeInstance extends worldINodeInstance {}

public native struct worldAdvertisementLightData {
  native let transform: Transform;
  native let isEnabled: Bool;
  native let lightName: CName;
  native let useAutoHideDistance: Bool;
  native let autoHideDistance: Float;
  native let type: ELightType;
  native let color: Color;
  native let radius: Float;
  native let unit: ELightUnit;
  native let intensity: Float;
  native let EV: Float;
  native let temperature: Float;
  native let sceneDiffuse: Bool;
  native let sceneSpecularScale: Uint8;
  native let directional: Bool;
  native let roughnessBias: Int8;
  native let scaleGI: Uint8;
  native let scaleEnvProbes: Uint8;
  native let useInTransparents: Bool;
  native let scaleVolFog: Uint8;
  native let useInParticles: Bool;
  native let attenuation: rendLightAttenuation;
  native let clampAttenuation: Bool;
  native let group: rendLightGroup;
  native let areaShape: EAreaLightShape;
  native let areaTwoSided: Bool;
  native let spotCapsule: Bool;
  native let sourceRadius: Float;
  native let capsuleLength: Float;
  native let areaRectSideA: Float;
  native let areaRectSideB: Float;
  native let innerAngle: Float;
  native let outerAngle: Float;
  native let softness: Float;
  native let enableLocalShadows: Bool;
  native let enableLocalShadowsForceStaticsOnly: Bool;
  native let contactShadows: rendContactShadowReciever;
  native let shadowAngle: Float;
  native let shadowRadius: Float;
  native let shadowFadeDistance: Float;
  native let shadowFadeRange: Float;
  native let shadowSoftnessMode: ELightShadowSoftnessMode;
  native let rayTracedShadowsPlatform: rendRayTracedShadowsPlatform;
  native let rayTracingLightSourceRadius: Float;
  native let rayTracingContactShadowRange: Float;
  native let iesProfile: ResourceAsyncRef; // raRef<CIESDataResource>
  native let flicker: rendSLightFlickering;
  native let envColorGroup: EEnvColorGroup;
  native let colorGroupSaturation: Uint8;
  native let portalAngleCutoff: Uint8;
  native let allowDistantLight: Bool;
  native let rayTracingIntensityScale: Float;
  native let pathTracingLightUsage: rendEPathTracingLightUsage;
  native let pathTracingOverrideScaleGI: Bool;
  native let rtxdiShadowStartingDistance: Float;
}

public native class worldAdvertisementNode extends worldStaticMeshNode {
  native let meshInitialScale: Vector3;
  native let format: AdvertisementFormat;
  native let adGroupTDBID: TweakDBID;
  native let enableOverride: Bool;
  native let adOverrideTDBID: TweakDBID;
  native let adVersion: Uint32;
  native let glitchValue: Float;
  native let lightsData: array<worldAdvertisementLightData>;
}

public native class worldAdvertisementNodeInstance extends worldStaticMeshNodeInstance {}

public native class worldAIDirectorSpawnAreaNode extends worldAreaShapeNode {
  native let groupKey: CName;
}

public native class worldAIDirectorSpawnAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldAIDirectorSpawnMarker extends worldIMarker {}

public native class worldAIDirectorSpawnNode extends worldNode {
  native let tags: redTagList;
}

public native class worldAIDirectorSpawnNodeInstance extends worldINodeInstance {}

public native class worldAISpotNode extends worldSocketNode {
  native let spot: ref<AISpot>;
  native let isWorkspotInfinite: Bool;
  native let isWorkspotStatic: Bool;
  native let markings: array<CName>;
  native let spotDef: ref<worldTrafficSpotDefinition>;
  native let disableBumps: Bool;
  native let lookAtTarget: NodeRef;
  native let useCrowdWhitelist: Bool;
  native let useCrowdBlacklist: Bool;
  native let crowdWhitelist: redTagList;
  native let crowdBlacklist: redTagList;
}

public native class worldAISpotNodeInstance extends worldSocketNodeInstance {}

public native class worldAmbientAreaNode extends worldTriggerAreaNode {
  native let useCustomColor: Bool;
}

public native class worldAmbientAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldAmbientPaletteExclusionAreaNode extends worldAreaShapeNode {
  native let exclusionPaletteEntries: array<audioAmbientPaletteEntry>;
}

public native class worldAmbientPaletteExclusionAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldAnimationSystem extends worldIRuntimeSystem {}

public native class worldAreaProxyMeshNode extends worldPrefabProxyMeshNode {}

public native class worldAreaShapeNode extends worldNode {
  native let color: Color;
  native let outline: ref<AreaShapeOutline>;
}

public native class worldAreaShapeNodeInstance extends worldINodeInstance {}

public native class worldAudioAttractAreaNode extends worldTriggerAreaNode {
  native let interestingConversationsNodeRef: NodeRef;
  native let audioAttractSoundSettings: array<worldAudioAttractAreaNodeSettings>;
}

public native class worldAudioAttractAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native struct worldAudioAttractAreaNodeSettings {
  native let metadataName: CName;
}

public native class worldAudioAttractAreaNotifier extends worldITriggerAreaNotifer {}

public native class worldAudioAttractAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldAudioSignpostTriggerNode extends worldTriggerAreaNode {
  native let enterSignpost: CName;
  native let exitSignpost: CName;
  native let reEnterSignpost: CName;
  native let preExitSignpost: CName;
  native let exitCooldown: Float;
}

public native class worldAudioSignpostTriggerNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldAudioSignpostTriggerNotifier extends worldITriggerAreaNotifer {}

public native class worldAudioSignpostTriggerNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldAudioTagNode extends worldNode {
  native let audioTag: CName;
  native let radius: Float;
}

public native class worldAudioTagNodeInstance extends worldINodeInstance {}

public native class worldAugmentedRealityWorldMarkers extends ISerializable {
  native let transforms: array<Transform>;
}

public native class worldAutoFoliageMapping extends CResource {
  native let Items: array<worldAutoFoliageMappingItem>;
}

public native struct worldAutoFoliageMappingItem {
  native let Material: CName;
  native let LayerIndex: Uint32;
  native let FoliageBrush: ResourceAsyncRef; // raRef<worldFoliageBrush>
}

public native class worldBakedDestructionNode extends worldMeshNode {
  native let meshFractured: ResourceAsyncRef; // raRef<CMesh>
  native let meshFracturedAppearance: CName;
  native let numFrames: Float;
  native let frameRate: Float;
  native let playOnlyOnce: Bool;
  native let restartOnTrigger: Bool;
  native let disableCollidersOnTrigger: Bool;
  native let filterDataSource: physicsFilterDataSource;
  native let filterData: ref<physicsFilterData>;
  native let damageThreshold: Float;
  native let damageEndurance: Float;
  native let impulseToDamage: Float;
  native let contactToDamage: Float;
  native let accumulateDamage: Bool;
  native let destructionEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let audioMetadata: CName;
  native let navigationSetting: NavGenNavigationSetting;
  native let useMeshNavmeshSettings: Bool;
}

public native class worldBakedDestructionNodeInstance extends worldMeshNodeInstance {}

public native class worldBendedMeshNode extends worldNode {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let meshAppearance: CName;
  native let deformationData: array<Matrix>;
  native let deformedBox: Box;
  native let isBendedRoad: Bool;
  native let castShadows: shadowsShadowCastingMode;
  native let castLocalShadows: shadowsShadowCastingMode;
  native let removeFromRainMap: Bool;
  native let navigationSetting: NavGenNavigationSetting;
  native let version: Uint8;
}

public native class worldBendedMeshNodeInstance extends worldINodeInstance {}

public native class worldBlockoutArea extends ISerializable {
  native let name: String;
  native let color: Color;
  native let parent: Uint32;
  native let children: array<Uint32>;
  native let outlines: array<ref<worldBlockoutAreaOutline>>;
  native let isFree: Bool;
  native let increaseTerrainStreamingDistance: Bool;
}

public native class worldBlockoutAreaOutline extends ISerializable {
  native let points: array<Uint32>;
  native let edges: array<Uint32>;
}

public native class worldBlockoutData extends ISerializable {
  native let points: array<worldBlockoutPoint>;
  native let edges: array<worldBlockoutEdge>;
  native let areas: array<worldBlockoutArea>;
  native let worldSize: Vector2;
  native let freePoints: array<Uint32>;
  native let freeEdges: array<Uint32>;
  native let freeAreas: array<Uint32>;
}

public native struct worldBlockoutEdge {
  native let points: [Uint32; 2];
  native let areas: [Uint32; 2];
  native let isFree: Bool;
}

public native class worldBlockoutPoint extends ISerializable {
  native let position: Vector2;
  native let edges: array<Uint32>;
  native let constraint: Int32;
  native let isFree: Bool;
}

public native class worldBlockoutResource extends CResource {
  native let blockoutData: ref<worldBlockoutData>;
}

public native class worldBuildingProxyMeshNode extends worldPrefabProxyMeshNode {}

public native class worldCableMeshNode extends worldBendedMeshNode {
  native let destructionHashes: [Uint64; 2];
  native let cableLength: Float;
  native let cableRadius: Float;
}

public native class worldCableMeshNodeInstance extends worldBendedMeshNodeInstance {}

public native class worldClothMeshNode extends worldMeshNode {
  native let affectedByWind: Bool;
}

public native class worldClothMeshNodeInstance extends worldMeshNodeInstance {}

public native class worldCollisionAreaNode extends worldAreaShapeNode {
  native let material: CName;
  native let navigationSetting: NavGenNavigationSetting;
  native let filterData: ref<physicsFilterData>;
}

public native class worldCollisionAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native struct worldCollisionGroupEntry {
  native let neRef: NodeRef;
  native let Reversed: Bool;
}

public native class worldCollisionNode extends worldNode {
  native let numActors: Uint16;
  native let numShapeInfos: Uint16;
  native let numShapePositions: Uint16;
  native let numShapeRotations: Uint16;
  native let numScales: Uint16;
  native let numMaterials: Uint16;
  native let numPresets: Uint16;
  native let numMaterialIndices: Uint16;
  native let numShapeIndices: Uint16;
  native let sectorHash: Uint64;
  native let extents: Vector4;
  native let lod: Uint8;
  native let resourceVersion: Uint8;
}

public native class worldCollisionNodeInstance extends worldINodeInstance {}

public native struct worldCommunityEntryInitialState {
  native let entryName: CName;
  native let initialPhaseName: CName;
  native let entryActiveOnStart: Bool;
}

public native struct worldCommunityRegistryItem {
  native let entriesInitialState: array<worldCommunityEntryInitialState>;
  native let template: ref<communityCommunityTemplateData>;
  native let communityId: gameCommunityID;
  native let communityAreaType: worldCommunityRegistryItemAreaNodeType;
}

enum worldCommunityRegistryItemAreaNodeType {
  Regular = 0,
  Streamable = 1,
  Background = 2,
  Count = 3,
}

public native class worldCommunityRegistryNode extends worldNode {
  native let spawnSetNameToCommunityID: gameCommunitySpawnSetNameToID;
  native let crowdCreationRegistry: ref<gameCrowdCreationDataRegistry>;
  native let communitiesData: array<worldCommunityRegistryItem>;
  native let workspotsPersistentData: array<AISpotPersistentData>;
  native let representsCrowd: Bool;
}

public native class worldCommunityRegistryNodeInstance extends worldINodeInstance {}

public native class worldCompiledCommunityAreaNode_Streamable extends worldCompiledCommunityAreaNode {
  native let streamingDistance: Float;
}

public native class worldCompiledCommunityAreaNode extends worldNode {
  native let area: ref<communityArea>;
  native let sourceObjectId: EntityID;
}

public native class worldCompiledCommunityAreaNodeInstance extends worldINodeInstance {}

public native class worldCompiledCrowdParkingSpaceNode extends worldNode {
  native let crowdCreationIndex: Uint32;
  native let parkingSpaceId: Uint32;
}

public native class worldCompiledCrowdParkingSpaceNodeInstance extends worldINodeInstance {}

public native struct worldCompiledEffectEventInfo {
  native let eventRUID: CRUID;
  native let placementIndexMask: Uint64;
  native let componentIndexMask: Uint64;
  native let flags: Uint8;
}

public native struct worldCompiledEffectInfo {
  native let placementTags: array<CName>;
  native let componentNames: array<CName>;
  native let relativePositions: array<Vector3>;
  native let relativeRotations: array<Quaternion>;
  native let placementInfos: array<worldCompiledEffectPlacementInfo>;
  native let eventsSortedByRUID: array<worldCompiledEffectEventInfo>;
}

public native struct worldCompiledEffectPlacementInfo {
  native let placementTagIndex: Uint8;
  native let relativePositionIndex: Uint8;
  native let relativeRotationIndex: Uint8;
  native let flags: Uint8;
}

public native struct worldCompiledNodeInstanceSetupInfo {}

public native struct worldCompiledNodeInstanceSetupInfoBuffer {}

public native struct worldCompiledSector {}

public native class worldCompiledSmartObjectsNode extends worldNode {
  native let resource: ResourceAsyncRef; // raRef<gameSmartObjectsCompiledResource>
}

public native class worldCompiledSmartObjectsNodeInstance extends worldINodeInstance {}

public native class worldConversationData extends ISerializable {
  native let sceneFilename: ResourceAsyncRef; // raRef<scnSceneResource>
  native let condition: ref<questIBaseCondition>;
  native let interruptionOperations: array<ref<scnIInterruptionOperation>>;
  native let ignoreLocalLimit: Bool;
  native let ignoreGlobalLimit: Bool;
}

public native class worldConversationGroupData extends ISerializable {
  native let conversationGroup: ResourceRef; // rRef<scnInterestingConversationsResource>
  native let interruptionOperations: array<ref<scnIInterruptionOperation>>;
  native let ignoreLocalLimit: Bool;
  native let ignoreGlobalLimit: Bool;
}

public native class worldCookedPrefabData extends CResource {
  native let precookedDependencies: array<ResourceAsyncRef>;
  native let dependencies: array<ResourceRef>;
}

public native class worldCorpseSystem extends worldIRuntimeSystem {}

public native struct worldCrowdNullAreaCollisionData {
  native let areaID: Uint64;
  native let collisions: array<worldTrafficStaticCollisionSphere>;
}

public native struct worldCrowdNullAreaCollisionHeader {
  native let direction: Vector3;
  native let radius: Float;
  native let speed: Float;
  native let flags: Uint8;
  native let userData: Uint64;
}

public native class worldCrowdNullAreaNode extends worldAreaShapeNode {
  native let IsForBlockade: Bool;
  native let permanentlyEnabledByDefault: Bool;
}

public native class worldCrowdNullAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldCrowdParkingSpaceNode extends worldNode {}

public native class worldCrowdParkingSpaceNodeInstance extends worldINodeInstance {}

public native class worldCrowdPortalNode extends worldNode {}

public native class worldCrowdPortalNodeInstance extends worldINodeInstance {}

public native class worldCurvePathNode extends worldSplineNode {
  native let userInput: animCurvePathBakerUserInput;
  native let defaultForwardVector: Vector4;
  native let globalInBlendTime: Float;
  native let globalOutBlendTime: Float;
  native let defaultPoseAnimationName: CName;
  native let defaultPoseSampleTime: Float;
  native let initialDiffYaw: Float;
  native let turnCharacterToMatchVelocity: Bool;
  native let rig: ResourceRef; // rRef<animRig>
  native let animSets: array<ResourceRef>;
  native let timeDeltaMultiplier: Float;
}

public native class worldCurvePathNodeInstance extends worldSplineNodeInstance {}

public native struct worldDbgOverlapBox {
  native let box: Box;
  native let transform: Transform;
  native let level: Uint32;
  native let isHit: Bool;
}

public native class worldDebugColoring_BoostedPrefabProxy extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_Climbable extends worldEditorDebugColoringSettings {
  native let climbableColour: Color;
  native let notClimbableColour: Color;
}

public native class worldDebugColoring_CollisionMeshes extends worldEditorDebugColoringSettings {
  native let defaultColor: Color;
  native let prefabColor: Color;
  native let collisionMeshColor: Color;
}

public native class worldDebugColoring_CookedResource extends worldEditorDebugColoringSettings {
  native let alpha: Uint8;
}

public native class worldDebugColoring_Device extends worldEditorDebugColoringSettings {
  native let defaultColor: Color;
}

public native class worldDebugColoring_Discarded extends worldEditorDebugColoringSettings {
  native let color: Color;
}

public abstract native class worldDebugColoring_DistanceAbstractBase extends worldEditorDebugColoringSettings {
  native let maxColor: Color;
  native let minColor: Color;
  native let minDistance: Float;
  native let maxDistance: Float;
}

public native class worldDebugColoring_Duplicates extends worldEditorDebugColoringSettings {
  native let defaultColor: Color;
  native let duplicateColor: Color;
  native let refreshPrefab: ResourceRef; // rRef<worldPrefab>
  native let refresh: Bool;
}

public native class worldDebugColoring_EPContext extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_GameVisualFluff extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_GIDebug extends worldEditorDebugColoringSettings {
  native let GIVisibleColor: Color;
  native let GITransparentColor: Color;
}

public native class worldDebugColoring_GPUMemoryUsage extends worldDebugColoring_MetricsUsageAbstractBase {}

public native class worldDebugColoring_InteriorExterior extends worldEditorDebugColoringSettings {
  native let interiorColor: Color;
  native let openInteriorColor: Color;
  native let exteriorColor: Color;
}

public native class worldDebugColoring_Loot extends worldEditorDebugColoringSettings {
  native let defaultColor: Color;
}

public native class worldDebugColoring_MergedMeshes extends worldEditorDebugColoringSettings {
  native let defaultColor: Color;
  native let mergedMeshColor: Color;
}

public native class worldDebugColoring_MeshLod extends worldEditorDebugColoringSettings {}

public abstract native class worldDebugColoring_MetricsUsageAbstractBase extends worldEditorDebugColoringSettings {
  native let maxColor: Color;
  native let minColor: Color;
  native let minSize: Uint32;
  native let maxSize: Uint32;
}

public native class worldDebugColoring_NavigationImpact extends worldEditorDebugColoringSettings {
  native let walkable: Color;
  native let ignored: Color;
  native let blocking: Color;
  native let road: Color;
  native let drones: Color;
  native let terrain: Color;
}

public native class worldDebugColoring_ObjectTag extends worldEditorDebugColoringSettings {
  native let tag: worldObjectTag;
  native let color: Color;
}

public native class worldDebugColoring_ObjectTagExt extends worldEditorDebugColoringSettings {
  native let tag: worldObjectTagExt;
  native let color: Color;
}

public native class worldDebugColoring_PrefabProxy extends worldEditorDebugColoringSettings {
  native let regularMeshColor: Color;
  native let instancedMeshColor: Color;
  native let prefabProxyMeshColor: Color;
  native let distinguishInstancedMesh: Bool;
}

public native class worldDebugColoring_ProxyMeshDependency extends worldEditorDebugColoringSettings {
  native let noneColor: Color;
  native let hasProxyColor: Color;
  native let discardColor: Color;
}

public native class worldDebugColoring_ResourceName extends worldEditorDebugColoringSettings {
  native let names: array<worldNameColorPair>;
  native let defaultColor: Color;
}

public native class worldDebugColoring_ResourceReadiness extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_SameResourceName extends worldEditorDebugColoringSettings {
  native let alpha: Uint8;
}

public native class worldDebugColoring_SecondaryRefPointDistance extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_StreamingCullingFlag extends worldEditorDebugColoringSettings {
  native let cullableColor: Color;
  native let forceCulledAlwaysColor: Color;
  native let forceCulledPeripheralColor: Color;
  native let defaultColor: Color;
}

public native class worldDebugColoring_StreamingDistance extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_StreamingPriority extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_TrianglesPerMesh extends worldEditorDebugColoringSettings {
  native let maxColor: Color;
  native let minColor: Color;
  native let minCount: Uint32;
  native let maxCount: Uint32;
}

public native class worldDebugColoring_UniqueInstanceMeshNode extends worldEditorDebugColoringSettings {}

public native class worldDebugColoring_UniqueMeshColors extends worldEditorDebugColoringSettings {
  native let alpha: Uint8;
}

public native class worldDebugFilterSetting_MeshResource extends worldEditorDebugFilterSettings {
  native let resourcePaths: array<String>;
}

public native class worldDecorationMeshNode extends worldMeshNode {
  native let startAsleep: Bool;
  native let filterDataSource: physicsFilterDataSource;
  native let filterData: ref<physicsFilterData>;
}

public native class worldDecorationMeshNodeInstance extends worldMeshNodeInstance {}

public native class worldDecorationProxyMeshNode extends worldPrefabProxyMeshNode {}

public native struct worldDesiredSlotsCountInfo {
  native let siredSlotsCount: Float;
  native let nCoeff: Float;
  native let nCoeffWhenMounted: Float;
}

public native class worldDestructibleEntityProxyMeshNode extends worldEntityProxyMeshNode {}

public native class worldDestructibleEntityProxyMeshNodeInstance extends worldEntityProxyMeshNodeInstance {}

public native class worldDestructibleProxyMeshNode extends worldPrefabProxyMeshNode {
  native let ownerHash: Uint64;
}

public native class worldDestructibleProxyMeshNodeInstance extends worldPrefabProxyMeshNodeInstance {}

public native struct worldDeviceConnections {
  native let deviceClassName: CName;
  native let nodeRefs: array<NodeRef>;
}

public native class worldDeviceNode extends worldEntityNode {
  native let deviceClassName: CName;
  native let alphaHackStreamingDistanceOverride: Float;
  native let deviceConnections: array<worldDeviceConnections>;
}

public native class worldDeviceNodeInstance extends worldEntityNodeInstance {}

public native class worldDistantGINode extends worldNode {
  native let dataAlbedo: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let dataNormal: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let dataHeight: ResourceAsyncRef; // raRef<CBitmapTexture>
  native let sectorSpan: Vector4;
}

public native class worldDistantGINodeInstance extends worldINodeInstance {}

public native class worldDistantLightsNode extends worldNode {
  native let data: ResourceAsyncRef; // raRef<CDistantLightsResource>
}

public native class worldDistantLightsNodeInstance extends worldINodeInstance {}

public native class worldDynamicMeshNode extends worldMeshNode {
  native let startAsleep: Bool;
  native let isDebris: Bool;
  native let initialGuess: Bool;
  native let dynamicTrafficSetting: TrafficGenDynamicTrafficSetting;
  native let navigationSetting: NavGenNavigationSetting;
  native let useMeshNavmeshSettings: Bool;
}

public native class worldDynamicMeshNodeInstance extends worldMeshNodeInstance {}

enum worldEClusteringModel {
  HierarchicalGrid = 0,
  AlwaysLoaded = 1,
  Discard = 2,
}

enum worldEditablePrefabType {
  Regular = 0,
  Decoration = 1,
  Quest = 2,
  Building = 3,
  Road = 4,
}

public abstract native class worldEditorDebugColoringSettings extends ISerializable {}

public native class worldEditorDebugFilterSettings_NodeConditional extends worldEditorDebugFilterSettings {
  native let isDiscarded: Bool;
  native let isProxyDependencyModeAutoSet: Bool;
  native let isProxyDependencyModeDiscardedSet: Bool;
}

public abstract native class worldEditorDebugFilterSettings extends ISerializable {}

public native class worldEditorForceAutoHideDistance extends ISerializable {
  native let minAutoHideDistance: Float;
  native let multiplier: Float;
}

public native class worldEffect extends resStreamedResource {
  native let name: CName;
  native let length: Float;
  native let inputParameterNames: array<CName>;
  native let trackRoot: ref<effectTrackGroup>;
  native let events: array<ref<effectTrackItem>>;
  native let effectLoops: array<effectLoopData>;
}

public native class worldEffectNode extends worldNode {
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let streamingDistanceOverride: Float;
}

public native class worldEffectNodeInstance extends worldINodeInstance {}

public native class worldEntityNode extends worldNode {
  native let entityTemplate: ResourceAsyncRef; // raRef<entEntityTemplate>
  native let instanceData: ref<entEntityInstanceData>;
  native let appearanceName: CName;
  native let ioPriority: entEntitySpawnPriority;
  native let entityLod: Uint16;
}

public native class worldEntityNodeInstance extends worldINodeInstance {}

public native class worldEntityProxyMeshNode extends worldPrefabProxyMeshNode {
  native let ownerGlobalId: GlobalNodeID;
  native let entityAttachDistance: Float;
}

public native class worldEntityProxyMeshNodeInstance extends worldPrefabProxyMeshNodeInstance {}

public native class worldEnvAreaNotifier extends worldITriggerAreaNotifer {
  native let priority: Uint8;
  native let horizontalFadeDistance: Float;
  native let verticalFadeDistance: Float;
  native let blendTimeIn: Float;
  native let blendTimeOut: Float;
  native let env: ResourceRef; // rRef<worldEnvironmentAreaParameters>
  native let params: WorldRenderAreaSettings;
  native let weatherStateNames: array<CName>;
  native let weatherStateValues: array<Bool>;
  native let resourceVersion: Uint8;
}

public native class worldEnvAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldEnvironmentAreaParameters extends CResource {
  native let renderAreaSettings: WorldRenderAreaSettings;
  native let resourceVersion: Uint8;
}

public native class worldEnvironmentDefinition extends CResource {
  native let worldRenderSettings: WorldRenderAreaSettings;
  native let worldShadowConfig: WorldShadowConfig;
  native let worldLightingConfig: WorldLightingConfig;
  native let renderSettingFactors: RenderSettingFactors;
  native let weatherStates: array<ref<worldWeatherState>>;
  native let weatherStateTransitions: array<ref<worldWeatherStateTransition>>;
  native let areaEnvironmentParameterLayers: array<ResourceRef>;
  native let resourceVersion: Uint8;
}

enum worldenvUtilsEBlendParamsType {
  EBPS_Tick = 0,
  EBPS_Game = 1,
  EBPS_Frame = 2,
}

public native struct worldExtractedNodeSocket {
  native let name: CName;
  native let displayName: CName;
  native let position: Vector3;
  native let rotation: Quaternion;
  native let direction: Vector3;
  native let type: worldNodeSocketType;
  native let isSnapped: Bool;
  native let color: Color;
}

enum worldFindLaneFilter {
  None = 0,
  Road = 1,
  PatrolRoute = 2,
  Pavement = 3,
}

public native class worldFoliageBakedDestructionMapping extends worldFoliageDestructionMapping {
  native let numFrames: Float;
  native let frameRate: Float;
  native let audioMetadata: CName;
  native let destructionEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let filterDataSource: physicsFilterDataSource;
  native let filterData: ref<physicsFilterData>;
}

public native class worldFoliageBrush extends CResource {
  native let items: array<ref<worldFoliageBrushItem>>;
}

public native class worldFoliageBrushItem extends ISerializable {
  native let Mesh: ResourceRef; // rRef<CMesh>
  native let MeshAppearance: CName;
  native let Params: worldFoliageBrushParams;
  native let Selected: Bool;
}

public native struct worldFoliageBrushParams {
  native let Proximity: Float;
  native let Scale: Float;
  native let ScaleVariation: Float;
}

public native class worldFoliageCompiledResource extends CResource {
  native let version: Uint32;
  native let populationCount: Uint32;
  native let bucketCount: Uint32;
}

public native class worldFoliageDestructionMapping extends ISerializable {
  native let baseMesh: ResourceAsyncRef; // raRef<CMesh>
  native let destructibleMesh: ResourceAsyncRef; // raRef<CMesh>
}

public native class worldFoliageDestructionNode extends worldCollisionNode {
  native let populationIndex: array<Uint32>;
  native let foliageResourceHash: Uint64;
  native let dataVersion: Uint32;
}

public native class worldFoliageDestructionNodeInstance extends worldCollisionNodeInstance {}

public native class worldFoliageDestructionResource extends CResource {
  native let mappings: array<ref<worldFoliageDestructionMapping>>;
}

public native class worldFoliageNode extends worldNode {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let meshAppearance: CName;
  native let foliageResource: ResourceAsyncRef; // raRef<worldFoliageCompiledResource>
  native let foliageLocalBounds: Box;
  native let autoHideDistanceScale: Float;
  native let lodDistanceScale: Float;
  native let streamingDistance: Float;
  native let populationSpanInfo: worldFoliagePopulationSpanInfo;
  native let destructionHash: Uint64;
  native let meshHeight: Float;
}

public native class worldFoliageNodeInstance extends worldINodeInstance {}

public native class worldFoliagePhysicalDestructionMapping extends worldFoliageDestructionMapping {
  native let audioMetadata: CName;
  native let destructionParams: physicsDestructionParams;
  native let destructionLevelData: array<physicsDestructionLevelData>;
}

public native struct worldFoliagePopulationSpanInfo {
  native let stancesBegin: Uint32;
  native let cketBegin: Uint32;
  native let stancesCount: Uint32;
  native let cketCount: Uint32;
}

public native class worldFoliageRawData extends ISerializable {
  native let items: array<ref<worldFoliageRawItem>>;
}

public native class worldFoliageRawItem extends ISerializable {
  native let Mesh: ResourceAsyncRef; // raRef<CMesh>
  native let MeshAppearance: CName;
  native let Position: Vector3;
  native let Rotation: Quaternion;
  native let Scale: Float;
}

public native class worldForbiddenAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class WorldFunctionalTests extends IScriptable {
  public final native func DespawnEntity()
  public final native func GetCurrentLightColor()
  public final native func SpawnEntity()
  public final native func TogglePrefabVariant()
}

public native class worldGenericProxyMeshNode extends worldPrefabProxyMeshNode {}

public native class worldgeometryCoverDescriptionQuery extends ISerializable {}

public native class worldgeometryCoverDescriptionResult extends ISerializable {}

public native class worldgeometryRuntimeSystemGeomDescription extends worldIRuntimeSystem {}

public native class worldGeometryShapeNode extends worldNode {
  native let color: Color;
  native let shape: ref<GeometryShape>;
}

public native class worldGeometryShapeNodeInstance extends worldINodeInstance {}

public native class worldGINode extends worldNode {
  native let data: ResourceAsyncRef; // raRef<CGIDataResource>
  native let location: [Int16; 3];
}

public native class worldGINodeInstance extends worldINodeInstance {}

public native class worldGIShapeNode extends worldGeometryShapeNode {
  native let priority: Uint32;
  native let group: rendGIGroup;
  native let interior: Bool;
  native let runtime: Bool;
  native let updated: Bool;
}

public native class worldGIShapeNodeInstance extends worldGeometryShapeNodeInstance {}

public native class worldGISpaceNode extends worldAreaShapeNode {
  native let priority: Uint32;
  native let group: rendGIGroup;
  native let interior: Bool;
  native let runtime: Bool;
  native let updated: Bool;
}

public native class worldGISpaceNodeInstance extends worldINodeInstance {}

public native class worldGuardAreaNode extends worldAreaShapeNode {
  native let communityEntries: array<AIGuardAreaConnectedCommunity>;
  native let combatCommunityEntries: array<AICombatGuardAreaConnectedCommunity>;
  native let pursuitArea: NodeRef;
  native let pursuitRange: Float;
}

public native class worldGuardAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldHeatmapLayer extends CResource {
  native let minValue: Uint32;
  native let maxValue: Uint32;
  native let name: String;
  native let units: String;
  native let invert: Bool;
}

public native class worldHeatmapResource extends CResource {
  native let setup: worldHeatmapSetup;
  native let name: String;
  native let layerNames: array<String>;
  native let layers: array<ResourceAsyncRef>;
}

public native struct worldHeatmapSetup {
  native let volumeBox: Box;
  native let verticalResolution: Uint32;
  native let horizontalResolution: Uint32;
}

public abstract native struct worldIDynamicCollisionRepresentation {}

public abstract native class worldIMarker extends ISerializable {}

public abstract native class worldINodeInstanceRegistry extends worldIRuntimeSystem {}

public native class worldInspectorNodeInstanceProperties extends ISerializable {
  native let setupInfo: worldCompiledNodeInstanceSetupInfo;
  native let meshNode: ref<worldMeshNode>;
  native let instancedMeshNode: ref<worldInstancedMeshNode>;
  native let lastObserverDistanceToStreamingPoint: Float;
  native let lastObserverDistanceToSecondaryReferencePoint: Float;
  native let renderProxyAddressForDebug: Uint64;
}

public native class worldInstancedDestructibleMeshNode extends worldMeshNode {
  native let staticMesh: ResourceAsyncRef; // raRef<CMesh>
  native let staticMeshAppearance: CName;
  native let simulationType: physicsSimulationType;
  native let filterDataSource: physicsFilterDataSource;
  native let startInactive: Bool;
  native let turnDynamicOnImpulse: Bool;
  native let useAggregate: Bool;
  native let enableSelfCollisionInAggregate: Bool;
  native let isDestructible: Bool;
  native let filterData: ref<physicsFilterData>;
  native let damageThreshold: Float;
  native let damageEndurance: Float;
  native let accumulateDamage: Bool;
  native let impulseToDamage: Float;
  native let fracturingEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let idleEffect: ResourceAsyncRef; // raRef<worldEffect>
  native let instanceTransforms: array<Transform>;
  native let cookedInstanceTransforms: worldTransformBuffer;
  native let isPierceable: Bool;
  native let isWorkspot: Bool;
  native let navigationSetting: NavGenNavigationSetting;
  native let useMeshNavmeshSettings: Bool;
  native let systemsToNotifyFlags: Uint16;
}

public native class worldInstancedDestructibleMeshNodeInstance extends worldMeshNodeInstance {}

public native class worldInstancedMeshNode extends worldNode {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let meshAppearance: CName;
  native let castShadows: shadowsShadowCastingMode;
  native let castLocalShadows: shadowsShadowCastingMode;
  native let occluderType: visWorldOccluderType;
  native let meshLODScales: Uint32;
  native let occluderAutohideDistanceScale: Uint8;
  native let worldTransformsBuffer: worldRenderProxyTransformBuffer;
  native let version: Uint8;
}

public native class worldInstancedMeshNodeInstance extends worldINodeInstance {}

public native class worldInstancedOccluderNode extends worldNode {
  native let worldBounds: Box;
  native let occluderType: visWorldOccluderType;
  native let autohideDistanceScale: Uint8;
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
}

public native class worldInstancedOccluderNodeInstance extends worldINodeInstance {}

public native class worldInterestingConversationsAreaNode extends worldTriggerAreaNode {
  native let conversationGroups: array<ResourceRef>;
  native let conversationResources: array<ref<worldConversationGroupData>>;
  native let conversations: array<ref<worldConversationData>>;
  native let workspots: array<NodeRef>;
  native let savingStrategy: audioConversationSavingStrategy;
}

public native class worldInterestingConversationsAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldInterestingConversationsAreaNotifier extends worldITriggerAreaNotifer {}

public native class worldInterestingConversationsAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldInteriorAreaNode extends worldTriggerAreaNode {}

public native class worldInteriorAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldInteriorAreaNotifier extends worldITriggerAreaNotifer {
  native let gameRestrictionIDs: array<TweakDBID>;
  native let treatAsInterior: Bool;
  native let setTier2: Bool;
}

public native class worldInteriorAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldInteriorMapNode extends worldNode {
  native let version: Uint32;
  native let coords: Uint64;
}

public native class worldInteriorMapNodeInstance extends worldINodeInstance {}

public native class worldInvalidProxyMeshNode extends worldPrefabProxyMeshNode {}

public abstract native class worldIQuestPrefabStateListener extends ISerializable {}

public abstract native class worldIRuntimeSystem extends IUpdatableSystem {}

public abstract native class worldIRuntimeSystemNavigation extends worldIRuntimeSystem {}

public abstract native class worldITrafficSystem extends worldIRuntimeSystem {}

public abstract native class worldIWorkspotSystem extends worldIRuntimeSystem {}

public native class worldLightChannelShapeNode extends worldGeometryShapeNode {
  native let streamingDistanceFactor: Float;
}

public native class worldLightChannelShapeNodeInstance extends worldINodeInstance {}

public native class worldLightChannelVolumeNode extends worldAreaShapeNode {
  native let streamingDistanceFactor: Float;
}

public native class worldLightChannelVolumeNodeInstance extends worldINodeInstance {}

public native struct WorldLightingConfig {
  native let lightAttenuationClamp: Float;
}

public native class worldLocationAreaNode extends worldTriggerAreaNode {
  native let locationName: String;
}

public native class worldLocationAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldLocationAreaNotifier extends worldITriggerAreaNotifer {
  native let districtID: TweakDBID;
  native let sendNewLocationNotification: Bool;
}

public native class worldLocationAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class WorldMapDebugOutlineLogicController extends inkLogicController {
  native let outlineWidget: inkShapeRef;
}

public native class WorldMapPlayerInitData extends MappinControllerCustomData {}

public native class worldMeshNode extends worldNode {
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
  native let meshAppearance: CName;
  native let forceAutoHideDistance: Float;
  native let occluderType: visWorldOccluderType;
  native let occluderAutohideDistanceScale: Uint8;
  native let castShadows: shadowsShadowCastingMode;
  native let castLocalShadows: shadowsShadowCastingMode;
  native let castRayTracedGlobalShadows: shadowsShadowCastingMode;
  native let castRayTracedLocalShadows: shadowsShadowCastingMode;
  native let windImpulseEnabled: Bool;
  native let removeFromRainMap: Bool;
  native let lodLevelScales: Uint32;
  native let version: Uint8;
}

public native class worldMeshNodeInstance extends worldSnappableNodeInstance {}

public native class worldMinimapConfigAreaNode extends worldAreaShapeNode {
  native let streamingRadius: Float;
}

public native class worldMinimapConfigAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldMinimapModeOverrideAreaNode extends worldTriggerAreaNode {
  native let streamingOcclusion: worldPrefabStreamingOcclusion;
}

public native class worldMinimapModeOverrideAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldMinimapModeOverrideAreaNotifier extends worldITriggerAreaNotifer {}

public native class worldMinimapModeOverrideAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldMirrorNode extends worldMeshNode {
  native let cullingBoxExtents: Vector3;
  native let cullingBoxOffset: Vector3;
}

public native class worldMirrorNodeInstance extends worldMeshNodeInstance {}

public native struct worldNameColorPair {
  native let name: String;
  native let color: Color;
}

public native class worldNavigationConfigAreaNode extends worldAreaShapeNode {
  native let generateVariantsNavmesh: Bool;
  native let detailSamplingDensity: NavGenSamplingDensity;
  native let smoothWalkableAreas: Bool;
  native let generateCrouchableAreas: Bool;
}

public native class worldNavigationConfigAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldNavigationDeniedAreaNode extends worldAreaShapeNode {
  native let human: Bool;
  native let vehicle: Bool;
}

public native class worldNavigationDeniedAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldNavigationNode extends worldNode {
  native let navigationTileResource: ResourceAsyncRef; // raRef<worldNavigationTileResource>
}

public native class worldNavigationNodeInstance extends worldINodeInstance {}

public native struct worldNavigationTileData {
  native let tileX: Int32;
  native let tileY: Int32;
  native let tileIndex: Uint32;
  native let bufferIndex: Uint32;
  native let agentSize: NavGenAgentSize;
  native let offMeshConnections: worldOffMeshConnectionsData;
  native let tileRef: Uint64;
  native let activeVariantIDs: array<Uint32>;
  native let allVariantIDs: array<Uint32>;
}

public native class worldNavigationTileResource extends resStreamedResource {
  native let localBoundingBox: Box;
  native let tilesData: array<worldNavigationTileData>;
  native let agentSize: NavGenAgentSize;
}

public native class worldNode extends ISerializable {
  native let isVisibleInGame: Bool;
  native let isHostOnly: Bool;
}

public native class worldNodeEditorData extends ISerializable {
  native let id: Uint64;
  native let name: CName;
  native let globalName: String;
  native let alternativeGlobalName: String;
  native let isGlobalNameLocked: Bool;
  native let isAlternativeGlobalNameLocked: Bool;
  native let isDestructibleNode: Bool;
  native let shouldSkipStreamingInEditor: Bool;
  native let excludeOnConsole: Bool;
  native let excludeOnNextGenConsoles: Bool;
  native let proxyMeshDependency: worldProxyMeshDependencyMode;
  native let transform: worldNodeTransform;
  native let pivotTransform: Transform;
  native let variantId: Uint32;
  native let questPrefabRefHash: Uint64;
  native let isInterior: Bool;
  native let isDiscarded: Bool;
  native let isSnapTarget: Bool;
  native let isSnapSource: Bool;
  native let maxStreamingDistance: Float;
  native let initialGlobalNameHash: String;
}

enum worldNodeGroupType {
  RegularGroup = 0,
  PrefabVariant = 1,
  DecorationCell = 2,
  ProxyGroup = 3,
}

public native class worldNodeInstanceRegistry extends worldINodeInstanceRegistry {}

public native class worldNodesGroup extends ISerializable {
  native let name: CName;
  native let id: Uint64;
  native let groupUniqueId: CRUID;
  native let nodes: array<ref<worldNode>>;
  native let subGroups: array<ref<worldNodesGroup>>;
  native let type: worldNodeGroupType;
  native let keepPosition: Bool;
  native let transform: Transform;
  native let transformCalculated: Bool;
  native let customPivotOffset: Transform;
  native let proxyMeshGroupBuildParams: worldProxyMeshGroupBuildParams;
  native let proxyMesh: ResourceAsyncRef; // raRef<CMesh>
  native let proxyDistanceFactor: Float;
  native let metadataArray: array<ref<worldPrefabMetadata>>;
}

public native struct worldNodesGroupPath {
  native let elements: array<CName>;
}

enum worldNodeSocketType {
  Bidirectional = 0,
  Inward = 1,
  Outward = 2,
  Disabled = 3,
}

public native struct worldNodeTransform {
  native let translation: Vector3;
  native let rotation: Quaternion;
  native let scale: Vector3;
}

public native class worldNullMarker extends worldIMarker {}

enum worldObjectTag {
  None = 1701736270,
  WallInterior = 1231839575,
  WallExterior = 1164730711,
  Floor = 1869573190,
  Stairs = 1936880723,
  Ladder = 1684300108,
  Decoration = 1868784964,
  Discard = 1668507972,
  Cover = 1920364355,
}

enum worldObjectTagExt {
  None = 1701736270,
  Default = 1634100548,
  NonClimbable = 1651262286,
}

public native class worldOffMeshConnectionNode extends worldSplineNode {
  native let isBidirectional: Bool;
  native let radius: Float;
  native let type: worldOffMeshConnectionType;
  native let tags: array<CName>;
}

public native class worldOffMeshConnectionNodeInstance extends worldSplineNodeInstance {}

public native struct worldOffMeshConnectionPayload {}

public native struct worldOffMeshConnectionsData {
  native let verts: array<Float>;
  native let radii: array<Float>;
  native let flags: array<Uint16>;
  native let areas: array<Uint8>;
  native let directions: array<Uint8>;
  native let ids: array<Uint64>;
  native let tagIntervals: array<Uint16>;
  native let tagsX: array<CName>;
  native let globalNodeIDs: array<GlobalNodeID>;
  native let userData: array<ref<worldOffMeshUserData>>;
}

public native class worldOffMeshSmartObjectNode extends worldOffMeshConnectionNode {
  native let object: ref<gameSmartObjectDefinition>;
}

public native class worldOffMeshSmartObjectNodeInstance extends worldOffMeshConnectionNodeInstance {}

public native class worldOffMeshSmartObjectUserData extends worldOffMeshUserData {
  native let nodeTransform: WorldTransform;
  native let localSpaceTrajectoryStartPoint: Vector3;
  native let localSpaceTrajectoryEndPoint: Vector3;
  native let smartObjectDefinition: ref<gameSmartObjectDefinition>;
  native let type: worldOffMeshConnectionType;
}

public native class worldOffMeshUserData extends ISerializable {}

public native struct worldOnAreaShapeCompiledEvent {}

public native class worldPatrolSplineNode extends worldSplineNode {
  native let patrolPointDefs: array<ref<worldPatrolSplinePointDefinition>>;
  native let patrolPoints: array<NodeRef>;
  native let spots: array<ref<worldTrafficSpotDefinition>>;
}

public native class worldPatrolSplineNodeInstance extends worldSplineNodeInstance {}

public native class worldPatrolSplinePointDefinition extends ISerializable {
  native let pointType: worldPatrolSplinePointTypes;
  native let node: NodeRef;
  native let target: EntityReference;
}

enum worldPatrolSplinePointTypes {
  Workspot = 0,
  LookAt = 1,
  ClearLookAt = 2,
}

public native class worldPerformanceAreaNode extends worldTriggerAreaNode {
  native let qualitySettingsArray: array<worldQualitySetting>;
  native let disableCrowdUniqueName: CName;
  native let globalStreamingDistanceScale: Float;
  native let globalEntityLODDistanceScale: Float;
}

public native class worldPerformanceAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldPerformanceAreaNotifier extends worldITriggerAreaNotifer {}

public native class worldPerformanceAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native struct worldPersistentSnapData {
  native let targetObjectPath: worldRelativeNodePath;
  native let targetSocketName: CName;
  native let snapTangent: Bool;
  native let reverseTangent: Bool;
  native let preserveLength: Bool;
}

public native class worldPhysicalDestructionNodeInstance extends worldSnappableNodeInstance {}

public native class worldPhysicalFractureFieldNodeInstance extends worldINodeInstance {}

public native class worldPhysicalImpulseAreaNode extends worldPhysicalTriggerAreaNode {
  native let impulse: Vector3;
  native let impulseRadius: Float;
}

public native class worldPhysicalImpulseAreaNodeInstance extends worldPhysicalTriggerAreaNodeInstance {}

public native class worldPhysicalTriggerAreaNode extends worldNode {
  native let simulationType: physicsSimulationType;
  native let shape: physicsTriggerShape;
  native let filterData: ref<physicsFilterData>;
}

public abstract native class worldPhysicalTriggerAreaNodeInstance extends worldINodeInstance {}

public native class worldPopulationSpawnerNode extends worldNode {
  native let objectRecordId: TweakDBID;
  native let appearanceName: CName;
  native let spawnOnStart: Bool;
  native let alwaysSpawned: gameAlwaysSpawnedState;
  native let spawnInView: gameSpawnInViewState;
  native let prefetchAppearance: Bool;
  native let isVehicle: Bool;
}

public native class worldPopulationSpawnerNodeInstance extends worldINodeInstance {}

public native class worldPrefab extends resStreamedResource {
  native let mainGroup: ref<worldNodesGroup>;
  native let type: worldPrefabType;
  native let teamOwnership: worldPrefabOwnership;
  native let streamingOcclusion: worldPrefabStreamingOcclusion;
  native let streamingImportance: worldPrefabStreamingImportance;
  native let defaultVariants: ref<worldPrefabVariantsList>;
  native let isLocked: Bool;
  native let maxBounds: Box;
  native let environmentDefinition: ResourceAsyncRef; // raRef<worldEnvironmentDefinition>
  native let terrainMultilayerSetup: ResourceAsyncRef; // raRef<Multilayer_Setup>
  native let foliageBrushToTerrainLayerMapping: ResourceAsyncRef; // raRef<worldAutoFoliageMapping>
  native let prefabUniqueId: CRUID;
  native let metadataArray: array<ref<worldPrefabMetadata>>;
  native let isMerged: Bool;
  native let proxyMeshBuildParams: worldProxyMeshBuildParams;
  native let isProxyMeshOnly: Bool;
  native let proxyMesh: ResourceAsyncRef; // raRef<CMesh>
  native let proxyScale: Vector3;
  native let maxProxyStreamingDistance: Float;
  native let proxyDistanceFactor: Float;
  native let averageNodeDiagonal: Float;
  native let boostInnerNodesToProxyDistance: Bool;
  native let overrideStreamingPosWithBBoxCenter: Bool;
  native let ignoreMeshEmbeddedOccluders: Bool;
  native let ignoreAllOccluders: Bool;
  native let excludeOnConsole: Bool;
  native let excludeOnNextGenConsoles: Bool;
  native let isTerrainPrefab: Bool;
  native let minimapContribution: worldPrefabMinimapContribution;
  native let interiorMapContribution: worldPrefabInteriorMapContribution;
  native let booleanProxyHelper: ResourceAsyncRef; // raRef<worldPrefab>
  native let proxyLimiterHelper: ResourceAsyncRef; // raRef<worldPrefab>
  native let customProxyMeshHelper: ResourceAsyncRef; // raRef<CMesh>
}

public native class worldPrefabInstanceData extends ISerializable {}

enum worldPrefabInteriorMapContribution {
  Auto = 0,
  Include = 1,
  Discard = 2,
}

public native class worldPrefabMetadata extends IScriptable {}

enum worldPrefabMinimapContribution {
  Auto = 0,
  Include = 1,
  Discard = 2,
}

public native class worldPrefabNode extends worldNode {
  native let prefab: ResourceAsyncRef; // raRef<worldPrefab>
  native let instanceData: ref<worldPrefabInstanceData>;
  native let enabledVariants: ref<worldPrefabVariantsList>;
  native let canBeToggledInGame: Bool;
  native let noCollisions: Bool;
  native let enableRenderSceneLayerOverride: Bool;
  native let streamingImportance: worldPrefabStreamingImportance;
  native let streamingOcclusionOverride: worldPrefabStreamingOcclusion;
  native let interiorMapContribution: worldPrefabInteriorMapContribution;
  native let ignoreMeshEmbeddedOccluders: Bool;
  native let ignoreAllOccluders: Bool;
  native let occluderAutoHideDistanceScale: Uint8;
  native let proxyMeshOnly: worldPrefabProxyMeshOnly;
  native let proxyScaleOverride: Bool;
  native let proxyScale: Vector3;
  native let applyMaxStreamingDistance: Bool;
}

public native class worldPrefabNodeInstance extends worldSnappableNodeInstance {}

enum worldPrefabOwnership {
  None = 0,
  Quest = 1,
  Audio = 2,
  Environment = 3,
  FX = 4,
  LevelDesign = 5,
  Lighting = 6,
  OpenWorld = 7,
  Cinematics = 8,
}

public abstract native class worldPrefabProxyMeshNode extends worldMeshNode {
  native let nearAutoHideDistance: Float;
  native let nbNodesUnderProxy: Uint32;
}

public native class worldPrefabProxyMeshNodeInstance extends worldMeshNodeInstance {}

enum worldPrefabProxyMeshOnly {
  SettingFromResource = 0,
  Enabled = 1,
  Disabled = 2,
}

enum worldPrefabStreamingImportance {
  Auto = 0,
  P1 = 1,
  P2 = 2,
  P3 = 3,
  P4 = 4,
  P5 = 5,
}

enum worldPrefabStreamingOcclusion {
  Default = 0,
  Exterior = 1,
  Interior = 2,
  OpenInterior = 3,
}

enum worldPrefabType {
  Regular = 0,
  Area = 1,
  Generated = 2,
  Decoration = 3,
  Quest = 4,
  Road = 5,
  Building = 6,
  Terrain = 7,
}

public native class worldPrefabVariantsList extends ISerializable {
  native let activeVariants: array<CName>;
}

public native class worldPreventionFreeAreaNode extends worldAreaShapeNode {}

public native class worldPreventionFreeAreaNodeInstance extends worldAreaShapeNodeInstance {}

enum worldProxWindowsType {
  SkipWindows = 0,
  PropagateWindows = 1,
  BakeLongDistantWindows = 2,
  BakeWindowsToBuffer = 3,
}

enum worldProxyBBoxSyncOptions {
  Do_Nothing = 0,
  Pull = 1,
  Pull_And_Delete = 2,
}

public native struct worldProxyBoundingBoxSyncParams {
  native let positiveAxis: worldProxyBBoxSyncOptions;
  native let negativeAxis: worldProxyBBoxSyncOptions;
  native let pullRange: Float;
  native let makeStackable: Bool;
  native let stackOffset: Vector3;
}

enum worldProxyCoreAxis {
  X = 0,
  Y = 1,
  Z = 2,
}

public native struct worldProxyCustomGeometryParams {
  native let useLimiterHelper: Bool;
  native let uvType: worldProxyMeshUVType;
}

enum worldProxyGroupingNormals {
  Around_Core_Axis = 0,
  Around_All_Axes = 1,
}

public native struct worldProxyMeshAdvancedBuildParams {
  native let boundingBoxSyncParams: worldProxyBoundingBoxSyncParams;
  native let surfaceFlattenParams: worldProxySurfaceFlattenParams;
  native let misc: worldProxyMiscAdvancedParams;
  native let rayBias: Float;
  native let rayMaxDistance: Float;
}

public native struct worldProxyMeshBuildParams {
  native let buildProxy: Bool;
  native let type: worldProxyMeshBuildType;
  native let usedMesh: worldProxyMeshOutputType;
  native let resolution: Uint32;
  native let polycount: Uint32;
  native let polycountPercentage: Float;
  native let coreAxis: worldProxyCoreAxis;
  native let groupingNormals: worldProxyGroupingNormals;
  native let forceSurfaceFlattening: Bool;
  native let forceSeamlessModule: Bool;
  native let enableAlphaMask: Bool;
  native let windows: worldProxyWindowsParams;
  native let textures: worldProxyTextureParams;
  native let customGeometry: worldProxyCustomGeometryParams;
  native let advancedParams: worldProxyMeshAdvancedBuildParams;
}

enum worldProxyMeshBuildType {
  ProxyFromScratch = 1,
  ProxyFromProxy = 0,
  OnlyFromChildProxies = 2,
}

enum worldProxyMeshDependencyMode {
  Auto = 0,
  Include = 1,
  Discard = 2,
}

public native struct worldProxyMeshGroupBuildParams {
  native let overridePrefabBuildParams: Bool;
  native let buildParams: worldGroupProxyMeshBuildParams;
}

enum worldProxyMeshOutputType {
  RayScan = 0,
  SurfaceReconstruction = 1,
  LegacyFromVoxels = 2,
  FromCustomMesh = 3,
  FromBoxes = 4,
  FromCollision = 5,
  FromConvexHull = 6,
  BoundsCombine = 7,
  BlobCrowd = 8,
  ReduceTarps = 9,
  KeepCurrent = 127,
}

enum worldProxyMeshTexRes {
  RES_64 = 0,
  RES_128 = 1,
  RES_256 = 2,
  RES_512 = 3,
  RES_1024 = 4,
}

enum worldProxyMeshUVType {
  UvUseExisting = 0,
  UvGenerateNew = 1,
}

public native struct worldProxyMiscAdvancedParams {
  native let useLod1: Bool;
  native let smoothVolume: Bool;
  native let blurCutout: Uint8;
  native let occlusionRatio: Uint8;
  native let capTop: Bool;
  native let capBottom: Bool;
  native let fillHolesBeforeReduceRatio: Float;
  native let fillHolesAfterReduceRatio: Float;
  native let rsSweepOrder: Int32;
  native let rsDetailDrop: Float;
  native let rsAxisPrecision: Vector3;
  native let rsAxisExpand: Vector3;
  native let rsAliasingReduction: Float;
  native let bcMergeRange: Float;
  native let bcSizeCutoff: Float;
  native let bcIterations: Float;
  native let bcMaxSize: Float;
  native let bcMinSize: Float;
  native let bcMergeSensitivity: Float;
  native let bcMinScale: Float;
  native let bcGridSize: Float;
  native let bcFilterSensitivity: Float;
  native let bcBoundsRatioLimit: Float;
  native let useClosestPointOnMesh: Bool;
  native let removeIslands: Bool;
  native let backgroundColor: Color;
}

enum worldProxyNormalAngleStepSize {
  STEP_90 = 0,
  STEP_45 = 1,
  STEP_15 = 2,
  STEP_5 = 3,
}

public native struct worldProxySurfaceFlattenParams {
  native let flatten: Bool;
  native let groupingStepAngle: worldProxyNormalAngleStepSize;
  native let syncNormalSource: worldProxySyncNormalSource;
  native let coreAxisRotationOffset: Float;
  native let postFlattenReduce: Bool;
}

enum worldProxySyncNormalSource {
  From_Groups = 0,
  From_Face_Average = 1,
}

public native struct worldProxyTextureParams {
  native let exportVertexColor: Bool;
  native let albedoTextureResolution: worldProxyMeshTexRes;
  native let generateAlbedo: Bool;
  native let normalTextureResolution: worldProxyMeshTexRes;
  native let generateNormal: Bool;
  native let roughnessTextureResolution: worldProxyMeshTexRes;
  native let generateRoughness: Bool;
  native let metalnessTextureResolution: worldProxyMeshTexRes;
  native let generateMetalness: Bool;
  native let disableTextureFilter: Bool;
  native let diffuseAlphaAsEmissive: Bool;
}

public native struct worldProxyWindowsParams {
  native let windowsType: worldProxWindowsType;
  native let distance: Float;
  native let distanceAboveProxy: Float;
  native let boolean: Bool;
  native let removeSmallerThan: Float;
  native let distantWindowsEmissive: Float;
  native let distantWindowsSize: Float;
  native let distantWindowsSaturation: Float;
  native let distantWindowsTurnedOf: Float;
}

public native struct worldQualitySetting {
  native let QualityLevel: ConfigGraphicsQualityLevel;
  native let xEntitiesBudget: Uint32;
}

public native class worldQuestMarker extends worldIMarker {}

enum worldQuestPrefabLoadingMode {
  Disable = 0,
  ForceLoad = 1,
}

public native class worldQuestPreventionNotifier extends worldITriggerAreaNotifer {
  native let type: worldQuestPreventionNotifierType;
  native let activation: worldQuestPreventionNotifierActivation;
}

enum worldQuestPreventionNotifierActivation {
  OnFootOnly = 0,
  InVehicleOnly = 1,
  Always = 2,
}

public native class worldQuestPreventionNotifierInstance extends worldITriggerAreaNotiferInstance {}

enum worldQuestPreventionNotifierType {
  Deescalation = 0,
  Clear = 1,
}

public native class worldQuestProxyMeshNode extends worldPrefabProxyMeshNode {}

enum worldQuestType {
  MainQuest = 0,
  SideQuest = 1,
  StreetStory = 2,
  MinorActivities = 3,
  MiniWorldStories = 4,
  CyberJunkie = 5,
  Courier = 6,
  CourierQuestGiver = 7,
  StuntChallenges = 8,
  StuntChallengesQuestGiver = 9,
  AirDrop = 10,
  BlackMarket = 11,
  Food = 12,
  TechStore = 13,
  Clothing = 14,
  Medpoint = 15,
  WeaponShop = 16,
  Ripperdoc = 17,
  CyberwareShop = 18,
  MeleeWeaponVendor = 19,
  Netrunner = 20,
  Outpost = 21,
  GangWatch = 22,
}

public native class worldRaceSplineNode extends worldSpeedSplineNode {
  native let offsets: array<worldRaceSplineNodeOffset>;
  native let offsetDefault: Float;
}

public native class worldRaceSplineNodeInstance extends worldSpeedSplineNodeInstance {}

public native struct worldRaceSplineNodeOffset {
  native let from: Float;
  native let to: Float;
  native let left: Float;
  native let right: Float;
}

public native class worldReflectionProbeNode extends worldNode {
  native let probeDataRef: ResourceAsyncRef; // raRef<CReflectionProbeDataResource>
  native let priority: Uint8;
  native let globalProbe: Bool;
  native let boxProjection: Bool;
  native let neighborMode: envUtilsNeighborMode;
  native let edgeScale: Vector3;
  native let emissiveScale: Float;
  native let reflectionDimming: Float;
  native let simpleFogColor: HDRColor;
  native let simpleFogDensity: Float;
  native let skyScale: Float;
  native let allInShadow: Bool;
  native let hideSkyColor: Bool;
  native let volFogAmbient: Bool;
  native let brightnessEVClamp: Int8;
  native let ambientMode: envUtilsReflectionProbeAmbientContributionMode;
  native let captureOffset: Vector3;
  native let nearClipDistance: Float;
  native let farClipDistance: Float;
  native let blendRange: Uint8;
  native let streamingDistance: Float;
  native let streamingHeight: Float;
  native let subScene: Bool;
  native let noFadeBlend: Bool;
}

public native class worldReflectionProbeNodeInstance extends worldINodeInstance {}

public native struct worldRelativeNodePath {
  native let parentsToSkip: Uint32;
  native let elements: array<worldRelativeNodePathElement>;
}

public native struct worldRelativeNodePathElement {
  native let prefab: String;
  native let nodeID: Uint64;
}

public native struct WorldRenderAreaSettings {
  native let areaParameters: array<ref<IAreaSettings>>;
}

public native struct worldRenderProxyTransformBuffer {
  native let sharedDataBuffer: ref<worldSharedDataBuffer>;
  native let startIndex: Uint32;
  native let numElements: Uint32;
}

enum worldRoadMaterial {
  Concrete = 0,
  ConcreteDestroyed = 1,
  Dirt = 2,
  HardenedDirtDestroyed = 3,
}

public native struct worldRoadMaterialInfo {
  native let startOffset: Float;
  native let material: worldRoadMaterial;
}

public native class worldRoadProxyMeshNode extends worldPrefabProxyMeshNode {}

public native class worldRotatingMeshNode extends worldMeshNode {
  native let rotationAxis: worldRotatingMeshNodeAxis;
  native let fullRotationTime: Float;
  native let reverseDirection: Bool;
}

enum worldRotatingMeshNodeAxis {
  X = 0,
  Y = 1,
  Z = 2,
}

public native class worldRotatingMeshNodeInstance extends worldMeshNodeInstance {}

public native class worldRuntimeEntityRegistry extends worldIRuntimeSystem {}

public native struct worldRuntimeScene {}

public native class worldRuntimeSystemAudio extends worldIRuntimeSystem {}

public native class worldRuntimeSystemBinkUpdate extends worldIRuntimeSystem {}

public native class worldRuntimeSystemCamera extends worldIRuntimeSystem {}

public native class worldRuntimeSystemCompiledTerrain extends worldIRuntimeSystem {}

public native class worldRuntimeSystemDebugRendering extends worldIRuntimeSystem {}

public native class worldRuntimeSystemDestruction extends worldIRuntimeSystem {}

public native class worldRuntimeSystemDismemberment extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEffectAttachments extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEffects extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEntity extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEntityAppearanceChanger extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEntityTransactor extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEntityTransforms extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEntityVisualController extends worldIRuntimeSystem {}

public native class worldRuntimeSystemEnvironment extends worldIRuntimeSystem {}

public native class worldRuntimeSystemFoliage extends worldIRuntimeSystem {}

public native class worldRuntimeSystemMarkers extends worldIRuntimeSystem {}

public native class worldRuntimeSystemMoverComponents extends worldIRuntimeSystem {}

public native class worldRuntimeSystemNavigation extends worldIRuntimeSystemNavigation {}

public native class worldRuntimeSystemNodeStreaming extends worldIRuntimeSystem {}

public native class worldRuntimeSystemPhysics extends worldIRuntimeSystem {}

public native class worldRuntimeSystemPrefabInstancing extends worldIRuntimeSystem {}

public native class worldRuntimeSystemRemoteViews extends worldIRuntimeSystem {}

public native class worldRuntimeSystemRendering extends worldIRuntimeSystem {}

public native class worldRuntimeSystemRepellerComponents extends worldIRuntimeSystem {}

public native class worldRuntimeSystemScenes extends worldIRuntimeSystem {}

public native class worldRuntimeSystemSmartObjects extends worldIRuntimeSystem {}

public native class worldRuntimeSystemSnapSovler extends worldIRuntimeSystem {}

public native class worldRuntimeSystemStreamingQuery extends worldIRuntimeSystem {}

public native class worldRuntimeSystemTraffic extends worldIRuntimeSystem {}

public native class worldRuntimeSystemTransformAnimator extends worldIRuntimeSystem {}

public native class worldRuntimeSystemTriggers extends worldIRuntimeSystem {}

public native class worldRuntimeSystemVisibility extends worldIRuntimeSystem {}

public native class worldRuntimeSystemWeather extends worldIRuntimeSystem {}

public native class worldRuntimeSystemWorldStreaming extends worldIRuntimeSystem {}

public native class worldSaveSanitizationForbiddenAreaNode extends worldTriggerAreaNode {
  native let safeSpotOffset: Vector4;
}

public native class worldSaveSanitizationForbiddenAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldSaveSanitizationForbiddenAreaNotifier extends worldITriggerAreaNotifer {}

public native class worldSceneRecordingContentObserverNode extends worldNode {
  native let filter: worldSceneRecordingNodeFilter;
}

public native class worldSceneRecordingContentObserverNodeInstance extends worldINodeInstance {}

public native struct worldSceneRecordingNodeFilter {
  native let streamInNodesWithStreamingDistanceMoreThan: Float;
  native let streamOutPrefabProxyMeshesWithStreamingDistanceMoreThan: Float;
  native let meshNodesOnly: Bool;
  native let meshResourceFilter: worldSceneRecordingNodeMeshResourceFilter;
}

public native struct worldSceneRecordingNodeMeshResourceFilter {
  native let forceFilterIgnore: array<ResourceAsyncRef>;
  native let forceFilterMatch: array<ResourceAsyncRef>;
}

public native struct WorldShadowConfig {
  native let contactShadows: ContactShadowsConfig;
  native let distantShadowsNumLevels: Uint32;
  native let distantShadowsBaseLevelRadius: Float;
  native let foliageShadowConfig: FoliageShadowConfig;
}

public native class worldSharedDataBuffer extends ISerializable {}

public native class worldSmartObjectNode extends worldNode {
  native let object: ref<gameSmartObjectDefinition>;
}

public native class worldSmartObjectNodeInstance extends worldINodeInstance {}

public abstract native class worldSnappableNodeInstance extends worldINodeInstance {}

public native struct worldSnapTags {
  native let includeTags: array<CName>;
  native let excludeTags: array<CName>;
}

public abstract native class worldSocketNode extends worldNode {}

public abstract native class worldSocketNodeInstance extends worldINodeInstance {}

public native class worldSpawnPointMarker extends worldIMarker {
  native let type: Uint32;
}

public native class worldSpeedSplineNode extends worldSplineNode {
  native let speedChangeSections: array<worldSpeedSplineNodeSpeedChangeSection>;
  native let useDeprecated: Bool;
  native let deprecatedSpeedRestrictions: array<worldSpeedSplineNodeSpeedRestriction>;
  native let deprecatedDefaultSpeed: Float;
  native let deprecatedDefaultAdjustTime: Float;
  native let orientationChangeSections: array<worldSpeedSplineNodeOrientationChangeSection>;
  native let roadAdjustmentFactorChangeSections: array<worldSpeedSplineNodeRoadAdjustmentFactorChangeSection>;
  native let ignoreTerrain: Bool;
}

public native class worldSpeedSplineNodeInstance extends worldSplineNodeInstance {}

public native struct worldSpeedSplineNodeOrientationChangeSection {
  native let pos: Float;
  native let type: worldSpeedSplineOrientationMarkerType;
  native let targetOrientation: EulerAngles;
}

public native struct worldSpeedSplineNodeRoadAdjustmentFactorChangeSection {
  native let pos: Float;
  native let targetFactor: Float;
}

public native struct worldSpeedSplineNodeSpeedChangeSection {
  native let start: Float;
  native let end: Float;
  native let targetSpeed_M_P_S: Float;
}

public native struct worldSpeedSplineNodeSpeedRestriction {
  native let speed: Float;
  native let from: Float;
  native let adjustTime: Float;
}

enum worldSpeedSplineOrientationMarkerType {
  UseSplineOrientation = 0,
  WorldSpace = 1,
  LocalSpace = 2,
  KeepYawRoll_WorldSpacePitch = 3,
  KeepPitchYaw_WorldSpaceRoll = 4,
  KeepPitchRoll_WorldSpaceYaw = 5,
  KeepYaw_WorldSpacePitchRoll = 6,
  KeepRoll_WorldSpacePitchYaw = 7,
  KeepPitch_WorldSpaceYawRoll = 8,
}

public native class worldSplineNode extends worldSocketNode {
  native let splineData: ref<Spline>;
  native let destSnapedNode: NodeRef;
  native let destSnapedSocketName: CName;
  native let entrySnapedNode: NodeRef;
  native let entrySnapedSocketName: CName;
}

public native class worldSplineNodeInstance extends worldSocketNodeInstance {}

public native struct worldStaticCollisionShapeCategories_CollisionNode {}

public native class worldStaticDecalNode extends worldNode {
  native let material: ResourceAsyncRef; // raRef<IMaterial>
  native let autoHideDistance: Float;
  native let verticalFlip: Bool;
  native let horizontalFlip: Bool;
  native let alpha: Float;
  native let normalThreshold: Float;
  native let roughnessScale: Float;
  native let diffuseColorScale: HDRColor;
  native let isStretchingEnabled: Bool;
  native let enableNormalTreshold: Bool;
  native let orderNo: Uint16;
  native let surfaceType: ERenderObjectType;
  native let normalsBlendingMode: RenderDecalNormalsBlendingMode;
  native let decalRenderMode: EDecalRenderMode;
  native let shouldCollectWithRayTracing: Bool;
  native let forcedAutoHideDistance: Float;
  native let decalNodeVersion: Uint8;
}

public native class worldStaticDecalNodeInstance extends worldINodeInstance {}

public native class worldStaticFogVolumeNode extends worldNode {
  native let priority: Uint8;
  native let absolute: Bool;
  native let applyHeightFalloff: Bool;
  native let densityFalloff: Float;
  native let blendFalloff: Float;
  native let densityFactor: Float;
  native let absorption: Float;
  native let streamingDistance: Float;
  native let ambientScale: Float;
  native let envColorGroup: EEnvColorGroup;
  native let color: Color;
}

public native class worldStaticFogVolumeNodeInstance extends worldINodeInstance {}

public native class worldStaticGpsLocationEntranceMarkerNode extends worldNode {}

public native class worldStaticGpsLocationEntranceMarkerNodeInstance extends worldINodeInstance {}

public native struct worldStaticLaneCollisions {
  native let lane: worldTrafficLaneUID;
  native let collisions: array<worldTrafficStaticCollisionSphere>;
  native let deadEndStart: Float;
}

public native class worldStaticLightNode extends worldNode {
  native let type: ELightType;
  native let color: Color;
  native let radius: Float;
  native let unit: ELightUnit;
  native let intensity: Float;
  native let EV: Float;
  native let temperature: Float;
  native let sceneDiffuse: Bool;
  native let sceneSpecularScale: Uint8;
  native let directional: Bool;
  native let roughnessBias: Int8;
  native let scaleGI: Uint8;
  native let scaleEnvProbes: Uint8;
  native let useInTransparents: Bool;
  native let scaleVolFog: Uint8;
  native let useInParticles: Bool;
  native let attenuation: rendLightAttenuation;
  native let clampAttenuation: Bool;
  native let group: rendLightGroup;
  native let areaShape: EAreaLightShape;
  native let areaTwoSided: Bool;
  native let spotCapsule: Bool;
  native let sourceRadius: Float;
  native let capsuleLength: Float;
  native let areaRectSideA: Float;
  native let areaRectSideB: Float;
  native let innerAngle: Float;
  native let outerAngle: Float;
  native let softness: Float;
  native let enableLocalShadows: Bool;
  native let enableLocalShadowsForceStaticsOnly: Bool;
  native let contactShadows: rendContactShadowReciever;
  native let shadowAngle: Float;
  native let shadowRadius: Float;
  native let shadowFadeDistance: Float;
  native let shadowFadeRange: Float;
  native let shadowSoftnessMode: ELightShadowSoftnessMode;
  native let rayTracedShadowsPlatform: rendRayTracedShadowsPlatform;
  native let rayTracingLightSourceRadius: Float;
  native let rayTracingContactShadowRange: Float;
  native let iesProfile: ResourceAsyncRef; // raRef<CIESDataResource>
  native let flicker: rendSLightFlickering;
  native let envColorGroup: EEnvColorGroup;
  native let colorGroupSaturation: Uint8;
  native let portalAngleCutoff: Uint8;
  native let allowDistantLight: Bool;
  native let rayTracingIntensityScale: Float;
  native let pathTracingLightUsage: rendEPathTracingLightUsage;
  native let pathTracingOverrideScaleGI: Bool;
  native let rtxdiShadowStartingDistance: Float;
  native let autoHideDistance: Float;
}

public native class worldStaticLightNodeInstance extends worldINodeInstance {}

public native class worldStaticMarkerNode extends worldSocketNode {
  native let isEnabled: Bool;
  native let tags: redTagList;
  native let data: ref<worldIMarker>;
}

public native class worldStaticMarkerNodeInstance extends worldSocketNodeInstance {}

public native class worldStaticMeshNode extends worldMeshNode {}

public native class worldStaticMeshNodeInstance extends worldMeshNodeInstance {}

public native class worldStaticOccluderMeshNode extends worldNode {
  native let occluderType: visWorldOccluderType;
  native let color: Color;
  native let autohideDistanceScale: Uint8;
  native let mesh: ResourceAsyncRef; // raRef<CMesh>
}

public native class worldStaticOccluderMeshNodeInstance extends worldINodeInstance {}

public native class worldStaticParticleNode extends worldNode {
  native let emissionRate: Float;
  native let particleSystem: ResourceAsyncRef; // raRef<CParticleSystem>
  native let forcedAutoHideDistance: Float;
  native let forcedAutoHideRange: Float;
}

public native class worldStaticParticleNodeInstance extends worldINodeInstance {}

public native class worldStaticQuestMarkerNode extends worldNode {
  native let questType: worldQuestType;
  native let questLabel: String;
  native let mapFilteringTag: CName;
  native let questMarkerHeight: Float;
}

public native class worldStaticQuestMarkerNodeInstance extends worldINodeInstance {}

public native class worldStaticSoundEmitterNode extends worldNode {
  native let radius: Float;
  native let audioName: CName;
  native let Settings: ref<audioAmbientAreaSettings>;
  native let usePhysicsObstruction: Bool;
  native let occlusionEnabled: Bool;
  native let acousticRepositioningEnabled: Bool;
  native let obstructionChangeTime: Float;
  native let useDoppler: Bool;
  native let dopplerFactor: Float;
  native let setOpenDoorEmitter: Bool;
  native let emitterMetadataName: CName;
  native let overrideRolloff: Bool;
  native let rolloffOverride: Float;
  native let ambientPaletteTag: CName;
}

public native class worldStaticSoundEmitterNodeInstance extends worldINodeInstance {}

public native class worldStaticStickerNode extends worldNode {
  native let labels: array<String>;
  native let showBackground: Bool;
  native let textColor: Color;
  native let backgroundColor: Color;
  native let sprites: array<ResourceAsyncRef>;
  native let spriteSize: Int32;
  native let alignSpritesHorizontally: Bool;
  native let scale: Float;
  native let visibilityDistance: Float;
}

public native class worldStaticStickerNodeInstance extends worldINodeInstance {}

public native class worldStaticVectorFieldNode extends worldNode {
  native let direction: Vector3;
  native let autoHideDistance: Float;
}

public native class worldStaticVectorFieldNodeInstance extends worldINodeInstance {}

public native class worldStreamingBlock extends CResource {
  native let descriptors: array<worldStreamingSectorDescriptor>;
  native let index: worldStreamingBlockIndex;
}

public native struct worldStreamingBlockIndex {
  native let rldGridCell: Uint32;
  native let oup: worldStreamingDataGroup;
}

enum worldStreamingDataGroup {
  Base = 0,
  EP1 = 1,
}

public native class worldStreamingQueryDataResource extends CResource {
  native let roadDatas: array<worldStreamingQueryRoadData>;
  native let connectedRoadDataIndices: array<Uint16>;
}

public native struct worldStreamingQueryRoadData {
  native let transform: Transform;
  native let splineData: ref<Spline>;
  native let roadGlobalNodeId: GlobalNodeID;
  native let totalRoadWidth: Float;
  native let connectedRoadsStartIndex: Uint16;
  native let connectedRoadsCount: Uint16;
}

enum worldStreamingSectorCategory {
  Exterior = 0,
  Interior = 1,
  Quest = 2,
  Navigation = 3,
  AlwaysLoaded = 4,
  Unknown = -1,
}

public native struct worldStreamingSectorDescriptor {
  native let data: ResourceAsyncRef; // raRef<worldStreamingSector>
  native let streamingBox: Box;
  native let questPrefabNodeRef: NodeRef;
  native let numNodeRanges: Uint32;
  native let variants: array<worldStreamingSectorVariant>;
  native let blockIndex: worldStreamingBlockIndex;
  native let level: Uint8;
  native let category: worldStreamingSectorCategory;
}

public native class worldStreamingSectorInplaceContent extends CResource {
  native let inplaceResources: array<ResourceRef>;
}

public native struct worldStreamingSectorVariant {
  native let nodeRef: NodeRef;
  native let variantId: Uint32;
  native let parentVariantID: Uint32;
  native let name: CName;
  native let rangeIndex: Uint32;
  native let enabledByDefault: Bool;
}

enum worldStreamingTestCheckpointType {
  BeginMove = 0,
  EndMove = 1,
}

public native class worldStreamingTestSummary extends ISerializable {
  native let gameDefinition: String;
  native let noCrowds: Bool;
  native let testDurationSeconds: Float;
  native let initialBytesRead: Uint64;
  native let bytesReadDuringTest: Uint64;
  native let bytesReadDuringDriving: Uint64;
  native let bytesReadDuringCooldown: Uint64;
  native let totalSeeksBytes: Uint64;
  native let minFps: Float;
  native let maxFps: Float;
  native let averageFps: Float;
}

public native class worldStreamingWorld extends CResource {
  native let version: Uint32;
  native let blockRefs: array<ResourceRef>;
  native let environmentDefinition: ResourceRef; // rRef<worldEnvironmentDefinition>
  native let worldBoundingBox: Box;
  native let persistentStateData: ResourceRef; // rRef<CResource>
  native let deviceResource: ResourceRef; // rRef<CResource>
  native let deviceInitResource: ResourceRef; // rRef<CResource>
  native let mappinResource: ResourceRef; // rRef<CResource>
  native let poiMappinResource: ResourceRef; // rRef<CResource>
  native let areaResource: ResourceRef; // rRef<CResource>
  native let lootResource: ResourceRef; // rRef<CResource>
  native let locationResource: ResourceRef; // rRef<CResource>
  native let locomotionPathResource: ResourceAsyncRef; // raRef<CResource>
  native let autoFoliageMapping: ResourceAsyncRef; // raRef<worldAutoFoliageMapping>
  native let trafficPersistentResource: ResourceAsyncRef; // raRef<CResource>
  native let trafficLaneConnectivityResource: ResourceAsyncRef; // raRef<CResource>
  native let trafficLanePolygonsResource: ResourceAsyncRef; // raRef<CResource>
  native let trafficLaneSpotsResource: ResourceAsyncRef; // raRef<CResource>
  native let trafficSpatialRepresentationResource: ResourceAsyncRef; // raRef<CResource>
  native let trafficCollisionResource: ResourceAsyncRef; // raRef<CResource>
  native let trafficNullAreaCollisionResource: ResourceAsyncRef; // raRef<CResource>
  native let smartObjectCompiledRootResource: ResourceAsyncRef; // raRef<CResource>
  native let geometryCacheResource: ResourceRef; // rRef<CResource>
  native let wasBuiltForSceneRecording: Bool;
  native let streamingQueryDataResource: ResourceAsyncRef; // raRef<worldStreamingQueryDataResource>
}

public native class worldTerrainCollisionNode extends worldNode {
  native let materials: array<CName>;
  native let materialIndices: array<Uint8>;
  native let actorTransform: WorldTransform;
  native let extents: Vector4;
  native let streamingDistance: Float;
  native let rowScale: Float;
  native let columnScale: Float;
  native let heightScale: Float;
  native let increaseStreamingDistance: Bool;
}

public native class worldTerrainCollisionNodeInstance extends worldINodeInstance {}

public native class worldTerrainMeshNode extends worldNode {
  native let mesh: ref<CMesh>;
  native let meshRef: ResourceAsyncRef; // raRef<CMesh>
}

public native class worldTerrainMeshNodeInstance extends worldINodeInstance {}

public native class worldTerrainProxyMeshNode extends worldPrefabProxyMeshNode {}

public native class worldTrafficCollisionDebug extends ISerializable {
  native let overlapBoxes: array<worldDbgOverlapBox>;
}

public native class worldTrafficCollisionDebugResource extends CResource {
  native let data: ref<worldTrafficCollisionDebug>;
}

public native class worldTrafficCollisionGroupNode extends worldNode {
  native let collisionEntries: array<worldCollisionGroupEntry>;
}

public native class worldTrafficCollisionGroupNodeInstance extends worldINodeInstance {}

public native class worldTrafficCollisionResource extends CResource {
  native let data: ref<worldTrafficStaticCollisionData>;
}

public native struct worldTrafficCollisionSphere {
  native let worldPos: Vector3;
  native let direction: Vector3;
  native let radius: Float;
  native let userData: Uint64;
  native let flags: Uint8;
}

public native class worldTrafficCompiledNode extends worldNode {
  native let aabb: Box;
}

public native class worldTrafficCompiledNodeInstance extends worldINodeInstance {}

public native struct worldTrafficConnectivityInLane {}

public native struct worldTrafficConnectivityOutLane {}

public native class worldTrafficGlobalPathPosition extends ISerializable {
  native let worldPosition: Vector3;
  native let pathIdx: Uint32;
}

public native struct worldTrafficLaneCrowdCreationInfo {
  native let connectedFragments: array<worldTrafficLaneCrowdFragment>;
}

public native struct worldTrafficLaneCrowdFragment {
  native let crowdCreationDataIndex: Uint32;
  native let laneX1: Float;
  native let laneX2: Float;
}

public native struct worldTrafficLaneExitDefinition {
  native let outLaneRef: NodeRef;
  native let exitPosition: Vector4;
  native let exitProbability: Float;
  native let endConnection: Bool;
  native let thisLaneReversed: Bool;
  native let outLaneReversed: Bool;
}

public native struct worldTrafficLanePersistent {
  native let outLanes: array<worldTrafficConnectivityOutLane>;
  native let inLanes: array<worldTrafficConnectivityInLane>;
  native let outline: array<Vector3>;
  native let accumulatedLengths: array<Float>;
  native let crowdCreationInfo: worldTrafficLaneCrowdCreationInfo;
  native let maxSpeed: Uint8;
  native let deadEndStart: Float;
  native let length: Float;
  native let width: Float;
  native let area: Float;
  native let flags: Uint16;
  native let subGraphId: Uint16;
  native let playerGPSInfo: worldTrafficLanePlayerGPSInfo;
  native let neighborGroupIndex: Uint16;
  native let nodeRefHash: Uint64;
  native let laneNumber: Uint16;
  native let seqNumber: Uint16;
  native let isReversed: Bool;
  native let roadMaterials: array<worldRoadMaterialInfo>;
  native let polygon: array<Vector2>;
}

enum worldTrafficLanePersistentFlags {
  FromRoadSpline = 1,
  Bidirectional = 2,
  PatrolRoute = 4,
  Pavement = 8,
  Road = 16,
  Intersection = 32,
  NeverDeadEnd = 64,
  TrafficDisabled = 128,
  CrossWalk = 256,
  GPSOnly = 512,
  ShowDebug = 1024,
  Blockade = 2048,
  Yield = 4096,
  NoAIDriving = 8192,
  Highway = 16384,
}

public native struct worldTrafficLanePlayerGPSInfo {
  native let subGraphId: Uint16;
  native let stronglyConnectedComponentId: Uint16;
}

public native struct worldTrafficLanePolygonRepresentation {
  native let outline: array<Vector3>;
  native let polygon: array<Vector2>;
}

public native class worldTrafficLanesSpotsResource extends resStreamedResource {}

public native struct worldTrafficLaneStreamed {}

public native struct worldTrafficLaneUID {
  native let nodeRefHash: Uint64;
  native let laneNumber: Uint16;
  native let seqNumber: Uint16;
  native let isReversed: Bool;
}

public native struct worldTrafficLightDefinition {
  native let positionOnLane: Float;
  native let groupIdx: Uint32;
  native let extent: Float;
  native let timeline: array<worldTrafficLightStage>;
}

public native struct worldTrafficLightStage {
  native let color: worldTrafficLightColor;
  native let duration: Float;
}

enum worldTrafficMovementBehavior {
  Pedestrian = 0,
  Car = 1,
}

public native class worldTrafficNullAreaCollisionData extends ISerializable {
  native let header: worldCrowdNullAreaCollisionHeader;
  native let nullAreaCollisions: array<worldCrowdNullAreaCollisionData>;
}

public native class worldTrafficNullAreaCollisionResource extends CResource {
  native let nullAreasCollisionData: ref<worldTrafficNullAreaCollisionData>;
  native let nullAreaBlockadeData: ref<worldTrafficNullAreaDynamicBlockadeData>;
}

public native struct worldTrafficNullAreaDynamicBlockade {
  native let areaID: Uint64;
  native let offmeshLinks: array<Uint64>;
  native let affectedTrafficLanes: array<worldTrafficLaneUID>;
  native let permanentlyEnabledByDefault: Bool;
}

public native class worldTrafficNullAreaDynamicBlockadeData extends ISerializable {
  native let nullAreasBlockades: array<worldTrafficNullAreaDynamicBlockade>;
}

public native struct worldTrafficPersistentData {
  native let lanes: array<worldTrafficLanePersistent>;
  native let neighborGroups: array<array<Uint16>>;
}

public native class worldTrafficPersistentDebugResource extends resStreamedResource {
  native let brokenUIDs: array<worldTrafficLaneUID>;
  native let brokenUIDsDeadEnds: array<worldTrafficLaneUID>;
}

public native struct worldTrafficPersistentLaneConnections {
  native let outlanes: array<worldTrafficConnectivityOutLane>;
  native let inLanes: array<worldTrafficConnectivityInLane>;
}

public native class worldTrafficPersistentLaneConnectionsResource extends resStreamedResource {}

public native class worldTrafficPersistentLanePolygonResource extends resStreamedResource {}

public native struct worldTrafficPersistentLaneSpots {
  native let spots: array<ref<worldTrafficSpotCompiled>>;
}

public native class worldTrafficPersistentNode extends worldNode {
  native let resource: ResourceAsyncRef; // raRef<worldTrafficPersistentResource>
}

public native class worldTrafficPersistentNodeInstance extends worldINodeInstance {}

public native class worldTrafficPersistentResource extends resStreamedResource {
  native let data: worldTrafficPersistentData;
}

public native class worldTrafficPersistentSpatialResource extends resStreamedResource {
  native let neighborGroups: array<array<Uint16>>;
}

public abstract native class worldTrafficSourceNode extends worldSplineNode {}

public native class worldTrafficSplineNode extends worldTrafficSourceNode {
  native let usage: worldTrafficSplineNodeUsage;
  native let maxSlotMaxSpeed: Float;
  native let width: Float;
  native let pathSamplingDistance: Float;
  native let bidirectional: Bool;
  native let autoConnectionRange: Float;
  native let markings: array<CName>;
  native let outLanes: array<worldTrafficLaneExitDefinition>;
  native let lights: array<worldTrafficLightDefinition>;
  native let neverDeadEnd: Bool;
  native let trafficDisabled: Bool;
  native let laneSamplingAngle: Float;
  native let noAIDriving: Bool;
}

public native class worldTrafficSplineNodeInstance extends worldSplineNodeInstance {}

enum worldTrafficSplineNodeUsage {
  Pavement = 0,
  Road = 1,
}

public abstract native class worldTrafficSpotCompiled extends ISerializable {}

public abstract native class worldTrafficSpotDefinition extends ISerializable {
  native let length: Float;
  native let direction: worldTrafficSpotDirection;
}

enum worldTrafficSpotDirection {
  Forward = 0,
  Backward = 1,
  Both = 2,
}

public native class worldTrafficSpotNode extends worldAISpotNode {}

public native class worldTrafficSpotNodeInstance extends worldAISpotNodeInstance {}

public native class worldTrafficStaticCollisionData extends ISerializable {
  native let laneCollisions: array<worldStaticLaneCollisions>;
}

public native struct worldTrafficStaticCollisionSphere {
  native let worldPos: Vector3;
}

public native struct worldTrafficSyncPointDefinition {
  native let laneRefs: array<NodeRef>;
  native let lanePositions: array<Float>;
  native let length: Float;
}

public native struct worldTransformBuffer {
  native let sharedDataBuffer: ref<worldSharedDataBuffer>;
  native let startIndex: Uint32;
  native let numElements: Uint32;
}

public native struct worldTriggerAreaEventInfo {
  native let nodeInstance: ref<worldTriggerAreaNodeInstance>;
  native let eventWorldPosition: Vector3;
  native let numActivatorsInArea: Uint32;
  native let activatorID: Uint32;
}

public native class worldTriggerAreaNode extends worldAreaShapeNode {
  native let notifiers: array<ref<worldITriggerAreaNotifer>>;
}

public native class worldTriggerAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native struct worlduiDebugPage_GameUI {}

public native class worlduiMeshTargetAttachment extends entIAttachment {}

public native class worlduiMeshTargetBinding extends entISourceBinding {}

public native class worlduiRuntimeSystemUI extends worldIRuntimeSystem {}

public native struct worlduiSceneWidgetProperties {
  native let projectionPlaneSize: Vector2;
  native let renderingPlane: ERenderingPlane;
  native let isAlwaysVisible: Bool;
  native let isInteractable: Bool;
  native let isInteractableFromBehind: Bool;
  native let maxInteractionDistance: Float;
  native let overrideMaxInteractionDistance: Bool;
  native let useCustomFaceVector: Bool;
  native let faceVector: Vector3;
}

public native class worldVehicleForbiddenAreaNode extends worldTriggerAreaNode {}

public native class worldVehicleForbiddenAreaNodeInstance extends worldTriggerAreaNodeInstance {}

public native class worldVehicleForbiddenAreaNotifier extends worldITriggerAreaNotifer {
  native let innerAreaBoundToOuterArea: Bool;
  native let innerAreaOutline: ref<AreaShapeOutline>;
  native let parkingSpots: array<NodeRef>;
  native let innerAreaSpeedLimit: Float;
  native let areaSpeedLimit: Float;
  native let enableNullArea: Bool;
  native let dismount: Bool;
  native let enableSummoning: Bool;
}

public native class worldVehicleForbiddenAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldWaterNullAreaNode extends worldAreaShapeNode {}

public native class worldWaterNullAreaNodeInstance extends worldAreaShapeNodeInstance {}

public native class worldWaterPatchNode extends worldMeshNode {
  native let type: worldWaterPatchNodeType;
  native let depth: Float;
  native let generateNavmesh: Bool;
}

public native class worldWaterPatchNodeInstance extends worldMeshNodeInstance {}

public native struct worldWaterPatchNodeType {
  native let typeName: CName;
}

public native class worldWaterPatchProxyMeshNode extends worldPrefabProxyMeshNode {}

public native class worldWeatherAreaNotifier extends worldITriggerAreaNotifer {
  native let horizontalFadeDistance: Float;
  native let verticalFadeDistance: Float;
  native let weatherStateNames: array<CName>;
  native let weatherStateValues: array<Float>;
}

public native class worldWeatherAreaNotifierInstance extends worldITriggerAreaNotiferInstance {}

public native class worldWeatherState extends ISerializable {
  native let minDuration: CurveDataFloat;
  native let maxDuration: CurveDataFloat;
  native let environmentAreaParameters: ResourceRef; // rRef<worldEnvironmentAreaParameters>
  native let effect: ResourceAsyncRef; // raRef<worldEffect>
  native let name: CName;
  native let probability: CurveDataFloat;
  native let transitionDuration: CurveDataFloat;
}

public native class worldWeatherStateTransition extends ISerializable {
  native let probability: CurveDataFloat;
  native let transitionDuration: CurveDataFloat;
  native let sourceWeatherState: ref<worldWeatherState>;
  native let targetWeatherState: ref<worldWeatherState>;
}

public native class worldWorld extends worldPrefab {}

public native struct worldWorldEnvironmentAreaParameters {
  native let enable: Bool;
  native let globalLight: worldWorldGlobalLightParameters;
}

public native struct worldWorldEnvironmentParameters {
  native let globalLightingTrajectory: GlobalLightingTrajectory;
}

public native struct worldWorldGlobalLightOverrideWithColorParameters {
  native let lightDirOverride: GlobalLightingTrajectoryOverride;
  native let lightColorOverride: HDRColor;
}

public native struct worldWorldGlobalLightParameters {
  native let unit: ELightUnit;
  native let sunColor: CurveDataHDRColor;
  native let moonColor: CurveDataHDRColor;
  native let sunSize: CurveDataFloat;
  native let moonSize: CurveDataFloat;
  native let specularTint: CurveDataHDRColor;
}

public native struct worldWorldID {}

public native class worldWorldListResource extends CResource {
  native let worlds: array<worldWorldListResourceEntry>;
}

public native struct worldWorldListResourceEntry {
  native let world: ResourceAsyncRef; // raRef<CResource>
  native let streamingWorld: ResourceAsyncRef; // raRef<CResource>
  native let worldName: String;
}

public native class XmlResource extends CResource {
  native let data: String;
}

public native struct AIAbsoluteZLimiter {}

public native struct AIActionSpotInstance {}

public native struct AIAngleDistanceCoverSelection {}

public native struct AIAngleDistanceCoverSelectionRuntimeData {}

public native struct AIAvoidLineOfSightCoverSelection {}

public native struct AIBehaviourSpotInstance {}

public native struct AIClearLineOfSightCoverSelection {}

public native struct AIClearLineOfSightCoverSelectionRuntimeData {}

public native struct AICMovementTarget {
  native let position: Vector3;
}

public native struct AICoverHealthCoverSelection {}

public native struct AICoverTypeCoverSelection {}

public native struct AIDistanceFromOthersCoverSelection {}

public native struct AIFriendlyTargetAngleDistanceCoverSelection {}

public native struct AIFriendlyTargetDistanceCoverSelection {}

public native struct AIKeepCurrentCoverSelection {}

public native struct AIOwnerAngleCoverSelection {}

public native struct AIOwnerDistanceCoverSelection {}

public native struct AIOwnerThreatCoverSelection {}

public native struct AIPathLengthCoverSelection {}

public native struct AIPathSecurityCoverSelection {}

public native struct AIRandomCoverSelection {}

public abstract native struct AISmartSpotInstance {}

public native struct AISquadCoverSelection {}

public native struct AITacticLimiter {}

public native struct AITarget {}

public native struct AITargetNodeInstance {}

public native struct AIThreatDistanceCoverSelection {}

public native struct AIUtilityLossCoverSelection {}

public native struct animAnimBreakpointSimple {
  native let enabled: Bool;
  native let hitCount: Uint32;
}

public native struct animAnimDebuggerCommand_ActivationChanges {}

public native struct animAnimDebuggerCommand_BoolOutputApplied {}

public native struct animAnimDebuggerCommand_FloatOutputApplied {}

public native struct animAnimDebuggerCommand_GetAvailableHooks {}

public native struct animAnimDebuggerCommand_HooksRegistered {}

public native struct animAnimDebuggerCommand_HooksUnregistered {}

public native struct animAnimDebuggerCommand_IntOutputApplied {}

public native struct animAnimDebuggerCommand_NormalizedProgressOutputApplied {}

public native struct animAnimDebuggerCommand_RecordActiveChanged {}

public native struct animAnimDebuggerCommand_SetDebugHookState {}

public native struct animAnimDebuggerCommand_TransitionOutputApplied {}

public native struct animAnimDebuggerCommand_VectorOutputApplied {}

public native struct animAnimDebuggerCommand_WeightChanges {}

public native struct audioAdvertPositionStrategy {}

public native struct audioAudioSquadHandler {}

public native struct audioIndexedSinglePositionStrategy {}

public native struct audioMultiplePositionsStrategy {}

public native struct audioNullPositionStrategy {}

public native struct audioQuadPositionStrategy {}

public native struct audioStandaloneSinglePositionStrategy {}

public native struct BaseGameEngine {}

public native struct CameraCustomData_CPFocusMode {}

public native struct CameraCustomData_DataMoshing {}

public native struct CameraCustomData_Histogram {}

public native struct CameraCustomData_Persistent {}

public native struct CameraCustomData_ReflectionProbes {}

public native struct CameraCustomData_RenderProxyData {}

public native struct CDebugConsole {}

public native struct CGameEngine {}

public native struct CGlobalIlluminationSceneData {}

public native struct communityPhaseTimePeriod {
  native let hour: communityECommunitySpawnTime;
  native let quantity: Uint16;
  native let markings: array<CName>;
  native let spotNodeRefs: array<NodeRef>;
  native let categories: array<gameSpotSequenceCategory>;
  native let isSequence: Bool;
}

public native struct ConeAOCustomData {}

public native struct ConsumableParameterBool {
  native let name: CName;
  native let value: Bool;
  native let consumed: Bool;
}

public native struct ConsumableParameterCName {
  native let name: CName;
  native let value: CName;
  native let consumed: Bool;
}

public native struct ConsumableParameterDouble {
  native let name: CName;
  native let value: Double;
  native let consumed: Bool;
}

public native struct ConsumableParameterFloat {
  native let name: CName;
  native let value: Float;
  native let consumed: Bool;
}

public native struct ConsumableParameterInt {
  native let name: CName;
  native let value: Int32;
  native let consumed: Bool;
}

public native struct ConsumableParameterIScriptable {
  native let name: CName;
  native let value: ref<IScriptable>;
  native let consumed: Bool;
}

public native struct ConsumableParameterTweakDBID {
  native let name: CName;
  native let value: TweakDBID;
  native let consumed: Bool;
}

public native struct ConsumableParameterVector {
  native let name: CName;
  native let value: Vector4;
  native let consumed: Bool;
}

public native struct ConsumableParameterWeakIScriptable {
  native let name: CName;
  native let value: wref<IScriptable>;
  native let consumed: Bool;
}

public native struct cpPlayer {
  native let peerID: netPeerID;
  native let nickname: String;
}

public native struct CRenderDistantIrradiancetData {}

public native struct CRenderDistantLightData {}

public native struct CRenderLightVolumeAllocator {}

public native struct CRenderLightVolumeCollector {}

public native struct CRenderSkyData {}

public native struct CRenderStateManagerData {}

public native struct CRenderTerrainCellCollector {}

public native struct CSpeedTreeWindDataUpdater {}

public native struct CWindImpulseCollector {}

public native struct DebugGameEngine {}

public native struct entAnimationControllerReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let animWrapperVarsState: entReplicatedAnimWrapperVars;
  native let animFeaturesState: entReplicatedAnimFeaturesState;
  native let inputSettersState: entReplicatedInputSetters;
}

public native struct entdismembermentFillMeshInfo {
  native let Mesh: ResourceAsyncRef; // raRef<CMesh>
  native let MeshAppearance: CName;
  native let AppearanceMap: array<entdismembermentAppearanceMatch>;
  native let ShouldReceiveDecal: Bool;
  native let Offset: Transform;
  native let Scale: Vector3;
  native let Physics: entdismembermentPhysicsInfo;
  native let Simulation: entdismembermentSimulationTypeE;
  native let Dangle: entdismembermentDangleInfo;
}

public native struct entRagdollComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let transforms: array<Transform>;
  native let isSleeping: Bool;
}

public native struct entReplicatedAnimFeature {
  native let entity: wref<Entity>;
  native let netTime: netTime;
  native let name: CName;
  native let value: ref<AnimFeature>;
  native let invokeCallback: Bool;
}

public native struct entReplicatedInputSetterBool {
  native let name: CName;
  native let applyServerTime: netTime;
  native let value: Bool;
}

public native struct entReplicatedInputSetterFloat {
  native let name: CName;
  native let applyServerTime: netTime;
  native let value: Float;
}

public native struct entReplicatedInputSetterInt {
  native let name: CName;
  native let applyServerTime: netTime;
  native let value: Int32;
}

public native struct entReplicatedInputSetterVector {
  native let name: CName;
  native let applyServerTime: netTime;
  native let value: Vector4;
}

public native struct entReplicatedLookAtAdd {
  native let creationNetTime: netTime;
  native let bodyPart: CName;
  native let request: LookAtRequest;
  native let targetPositionProvider: ref<IPositionProvider>;
  native let ref: LookAtRef;
}

public native struct entReplicatedLookAtRemove {
  native let creationNetTime: netTime;
  native let ref: LookAtRef;
  native let hasOutTransition: Float;
  native let outTransitionSpeed: Float;
}

public native struct EP1RequestFilter {
  native let isEP1: Bool;
}

public native struct FSR2CustomData {}

public native struct FunctionalTestsGameEngine {}

public native struct gameActionAnimationState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let animFeatureName: CName;
  native let animFeature: ref<AnimFeature_AIAction>;
  native let useRootMotion: Bool;
  native let usePoseMatching: Bool;
  native let motionDynamicObjectsCheck: Bool;
  native let slideParams: ActionAnimationSlideParams;
  native let targetObject: wref<GameObject>;
  native let sendLoopEvent: Bool;
}

public native struct gameActionDieState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let owner: wref<GameObject>;
  native let movingAgent: wref<moveComponent>;
  native let ragdollComponent: wref<RagdollComponent>;
  native let slotComponent: wref<SlotComponent>;
}

public native struct gameActionEquipItemState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let slotId: TweakDBID;
  native let itemId: ItemID;
  native let animFeatureNameRight: CName;
  native let animFeatureNameLeft: CName;
  native let duration: Float;
  native let spawnDelay: Float;
}

public native struct gameActionHitReactionState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let animFeature: ref<AnimFeature_HitReactionsData>;
}

public native struct gameActionMoveToDynamicNodeState {
  native let targetPos: Vector3;
  native let toleranceRadius: Float;
  native let rotateEntity: Bool;
  native let moveStyle: Uint32;
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let target: wref<GameObject>;
  native let strafingTarget: wref<GameObject>;
  native let desiredDistanceFromTarget: Float;
  native let stopWhenDestinationReached: Bool;
  native let pathfindingUpdateInterval: Float;
  native let usePathfinding: Bool;
  native let useStart: Bool;
  native let useStop: Bool;
}

public native struct gameActionMoveToPositionState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let target: Vector3;
  native let useSpotReservation: Bool;
  native let usePathfinding: Bool;
  native let useStart: Bool;
  native let useStop: Bool;
  native let movementType: moveMovementType;
  native let strafingTarget: wref<GameObject>;
}

public native struct gameActionMoveToSmartObjectState {
  native let targetPos: Vector3;
  native let toleranceRadius: Float;
  native let rotateEntity: Bool;
  native let moveStyle: Uint32;
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let targetHash: Uint64;
  native let usePathfinding: Bool;
  native let useStart: Bool;
  native let useStop: Bool;
  native let entryType: gameSmartObjectInstanceEntryType;
  native let movementType: moveMovementType;
  native let strafingTarget: wref<GameObject>;
  native let entryDirection: Vector3;
  native let entryPointPos: Vector3;
  native let entryPointDir: Vector4;
  native let animationName: CName;
  native let isInSmartObject: Bool;
}

public native struct gameActionMoveToState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let targetPos: Vector3;
  native let toleranceRadius: Float;
  native let rotateEntity: Bool;
  native let moveStyle: Uint32;
}

public native struct gameActionRotateBaseState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let angleOffset: Float;
  native let angleTolerance: Float;
  native let keepUpdatingTarget: Bool;
  native let useRotationTime: Bool;
  native let rotationSpeed: Float;
  native let rotationTime: Float;
}

public native struct gameActionRotateToObjectState {
  native let angleOffset: Float;
  native let angleTolerance: Float;
  native let keepUpdatingTarget: Bool;
  native let useRotationTime: Bool;
  native let rotationSpeed: Float;
  native let rotationTime: Float;
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let targetObject: wref<GameObject>;
  native let completeWhenRotated: Bool;
}

public native struct gameActionRotateToState {
  native let angleOffset: Float;
  native let angleTolerance: Float;
  native let keepUpdatingTarget: Bool;
  native let useRotationTime: Bool;
  native let rotationSpeed: Float;
  native let rotationTime: Float;
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
}

public native struct gameActionUnequipItemState {
  native let replicationId: Uint32;
  native let type: Uint16;
  native let startTimeStamp: netTime;
  native let stopTimeStamp: netTime;
  native let updateBucket: Uint8;
  native let slotId: TweakDBID;
  native let animFeatureNameRight: CName;
  native let animFeatureNameLeft: CName;
  native let duration: Float;
}

public native struct gameAINetStateComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let replHighLevelState: gameNetAIState;
  native let replUpperBodyState: gameNetAIState;
  native let replStanceState: gameNetAIState;
  native let replHitReactionModeState: gameNetAIState;
  native let replBehaviorState: gameNetAIState;
  native let replPhaseState: gameNetAIState;
  native let replDefenseMode: gameNetAIState;
  native let replLocomotionMode: gameNetAIState;
}

public native struct gameAttachmentSlotsReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let stateVersion: Uint32;
  native let slots: array<gameAttachmentSlotReplicatedState>;
}

public native struct gamecarryReplicatedEntitySetAttachmentToEntity {
  native let time: netTime;
  native let entity: wref<Entity>;
  native let slot: CName;
  native let localTransform: Transform;
}

public native struct gamecarryReplicatedEntitySetAttachmentToNode {
  native let time: netTime;
  native let localTransform: Transform;
}

public native struct gamecarryReplicatedEntitySetAttachmentToWorld {
  native let time: netTime;
  native let localTransform: Transform;
}

public native struct gameCombinedStatModifier {}

public native struct gameConstantStatModifier {}

public native struct gameCoverInstance {}

public native struct gameCoverVisualData {}

public native struct gameCrowdPhaseTimePeriod {
  native let hour: communityECommunitySpawnTime;
  native let mergeMode: gameCrowdCreationDataMergeMode;
  native let density: Float;
  native let Density: CName;
  native let workspotsUsage: Float;
  native let charactersData: array<gameCrowdTemplateCharacterData>;
  native let reducedCharactersData: array<gameCrowdTemplateCharacterData>;
  native let crowdType: gameCrowdEntryType;
  native let useDensityPreset: Bool;
}

public native struct gameCurveStatModifier {}

public native struct gameDeviceBaseReplicationProxy {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
  native let scriptState: ref<DeviceReplicatedState>;
  native let versionId: Uint32;
  native let versionTimestamp: netTime;
  native let initialOrientation: EulerAngles;
  native let initialLocation: Vector3;
}

public native struct gameDynamicCookedDeviceData {
  native let className: CName;
  native let parents: array<Uint64>;
  native let children: array<Uint64>;
  native let nodePosition: Vector3;
  native let componentName: CName;
}

public native struct gameFPPCameraComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
}

public native struct gameGameSession {}

public native struct gameinteractionsPublisherActivationEvent {}

public native struct gameinteractionsPublisherChoiceEvent {}

public native struct gameinteractionsvisDeviceVisualizerFamily {}

public native struct gameinteractionsvisDialogVisualizerFamily {}

public native struct gameinteractionsvisLootVisualizerFamily {}

public native struct gameInventoryListenerData_InventoryEmpty {}

public native struct gameInventoryListenerData_ItemAdded {}

public native struct gameInventoryListenerData_ItemExtracted {}

public native struct gameInventoryListenerData_ItemNotification {}

public native struct gameInventoryListenerData_ItemQuantityChanged {}

public native struct gameInventoryListenerData_ItemRemoved {}

public native struct gameInventoryListenerData_PartAdded {}

public native struct gameInventoryListenerData_PartRemoved {}

public native struct gamemappinsInteractionMappinInitialData {
  native let mappinType: TweakDBID;
  native let variant: gamedataMappinVariant;
  native let active: Bool;
  native let debugCaption: String;
  native let localizedCaption: LocalizationString;
  native let visibleThroughWalls: Bool;
  native let scriptData: ref<MappinScriptData>;
}

public native struct gamemappinsInteractionMappinUpdateData {}

public native struct gamemappinsRuntimeGenericMappinData {}

public native struct gamemappinsRuntimeInteractionMappinData {}

public native struct gamemappinsRuntimePointOfInterestMappinData {}

public native struct gamemappinsRuntimeQuestMappinData {}

public native struct gamemappinsRuntimeStubMappinData {}

public native struct gamemappinsStubMappinData {
  native let mappinType: TweakDBID;
  native let variant: gamedataMappinVariant;
  native let active: Bool;
  native let debugCaption: String;
  native let localizedCaption: LocalizationString;
  native let visibleThroughWalls: Bool;
  native let scriptData: ref<MappinScriptData>;
}

public native struct gameMuppetInputActionActivateScanning {}

public native struct gameMuppetInputActionAimDownSight {}

public native struct gameMuppetInputActionCrouch {}

public native struct gameMuppetInputActionDebugCommand {
  native let debugCommand: gameMuppetDebugCommand;
}

public native struct gameMuppetInputActionJump {}

public native struct gameMuppetInputActionLook {
  native let rotation: Vector2;
}

public native struct gameMuppetInputActionMeleeAttack {}

public native struct gameMuppetInputActionMoveForward {
  native let direction: Vector2;
  native let isSprinting: Bool;
}

public native struct gameMuppetInputActionQuickMelee {}

public native struct gameMuppetInputActionRangedAttack {
  native let actionType: gameMuppetInputActionType;
}

public native struct gameMuppetInputActionReloadWeapon {}

public native struct gameMuppetInputActionSelectSlot {
  native let targetSlot: Int32;
}

public native struct gameMuppetInputActionSelectWeapon {
  native let wantedWeapon: ItemID;
}

public native struct gameMuppetInputActionUseConsumable {}

public native struct gameMuppetReplicatedState {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
  native let state: gameMuppetState;
  native let initialOrientation: EulerAngles;
  native let initialLocation: Vector3;
  native let health: Float;
  native let armor: Float;
}

public native struct gameNpcPuppetReplicatedState {
  native let initialOrientation: EulerAngles;
  native let initialLocation: Vector3;
  native let initialAppearance: CName;
  native let actionsBuffer: gameActionsReplicationBuffer;
  native let health: Float;
  native let armor: Float;
  native let hasCPOMissionData: Bool;
  native let CPOMissionVotedHistory: array<CName>;
  native let animEventsState: gameReplicatedAnimControllerEventsState;
  native let entityEventsState: gameReplicatedEntityEventsState;
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
  native let weaponStates: gameWeaponsReplicatedState;
}

public native struct gamePlayerPuppetReplicatedState {
  native let initialOrientation: EulerAngles;
  native let initialLocation: Vector3;
  native let initialAppearance: CName;
  native let actionsBuffer: gameActionsReplicationBuffer;
  native let health: Float;
  native let armor: Float;
  native let hasCPOMissionData: Bool;
  native let CPOMissionVotedHistory: array<CName>;
  native let animEventsState: gameReplicatedAnimControllerEventsState;
  native let entityEventsState: gameReplicatedEntityEventsState;
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
}

public abstract native struct gamePuppetReplicatedState {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
  native let initialOrientation: EulerAngles;
  native let initialLocation: Vector3;
  native let initialAppearance: CName;
  native let actionsBuffer: gameActionsReplicationBuffer;
  native let health: Float;
  native let armor: Float;
  native let hasCPOMissionData: Bool;
  native let CPOMissionVotedHistory: array<CName>;
  native let animEventsState: gameReplicatedAnimControllerEventsState;
  native let entityEventsState: gameReplicatedEntityEventsState;
}

public native struct gameRandomStatModifier {}

public native struct gameReplAnimTransformOperationRequest {
  native let applyServerTime: netTime;
  native let animName: CName;
  native let operationType: Uint8;
}

public native struct gameReplAnimTransformPlayRequest {
  native let applyServerTime: netTime;
  native let animName: CName;
  native let timeScale: Float;
  native let timesToPlay: Int32;
}

public native struct gameReplAnimTransformSkipRequest {
  native let applyServerTime: netTime;
  native let animName: CName;
  native let skipTime: Float;
}

public native struct gameReplAnimTransformSyncAnimRequest {
  native let applyServerTime: netTime;
}

public native struct gameReplAnimTransformSyncMatrixRequest {
  native let applyServerTime: netTime;
  native let transform: Transform;
}

public native struct gameReplicatedAnimEvent {
  native let entity: wref<Entity>;
  native let netTime: netTime;
  native let name: CName;
}

public native struct gameReplicatedEntityEvent {
  native let entity: wref<Entity>;
  native let netTime: netTime;
  native let value: ref<Event>;
}

public native struct gameScanningComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let scanningState: gameScanningState;
  native let pctScanned: Float;
}

public native struct gameShootingSpotInstance {}

public native struct gamestateMachineComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let stateContext: gamestateMachineStateContext;
  native let enterLadderParameter: ref<LadderDescription>;
  native let exitLadderParameter: Bool;
}

public native struct gameStatusEffectComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let replicatedInfo: array<gameStatusEffectReplicatedInfo>;
}

public native struct gameStreamingSmartObjectsDataExtractor {}

public native struct gameTransformAnimatorComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
}

public native struct gameuiCustomizationAppearance {
  native let censorFlagAction: gameuiCharacterCustomizationActionType;
  native let name: CName;
  native let resource: ResourceAsyncRef; // raRef<appearanceAppearanceResource>
  native let definition: CName;
}

public native struct gameuiCustomizationMorph {
  native let censorFlagAction: gameuiCharacterCustomizationActionType;
  native let regionName: CName;
  native let targetName: CName;
}

public native struct gameuiExternalPhoneElement {
  native let libraryID: CName;
  native let request: wref<inkAsyncSpawnRequest>;
  native let widget: wref<inkWidget>;
  native let slot: inkCompoundRef;
  native let libraryResource: ResourceRef; // rRef<inkWidgetLibraryResource>
}

public native struct gameuiGameStatePropertyChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiGenericNotificationSaveData {
  native let id: Int64;
  native let notificationsData: array<gameuiGenericNotificationData>;
}

public native struct gameuiHoldIndicatorProgressCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiInputHintManagerGameControllerData {
  native let id: Int64;
  native let inputHintsData: array<InputHintData>;
}

public native struct gameuiMoveTargetCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiOnCollideCallbackAdvanced {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiOnHitCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiSetPhotoModeKeyEnabledCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiStickerBackgroundCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiStickerCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiStickerFrameCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiStickerImageCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiZoomChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameuiZoomLevelChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gameWeakspotComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let WeakspotRepInfos: array<gameWeakSpotReplicatedInfo>;
}

public native struct gameweaponGrenadeReplicatedState {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
  native let instigator: wref<GameObject>;
  native let itemID: ItemID;
  native let currentTransform: WorldTransform;
  native let exploded: Bool;
  native let launched: Bool;
}

public native struct gsmgameStateObserver_FunctionalTests {}

public native struct gsmSavingRequesResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct gsmStateObserver_RichPresence {}

public native struct gsmStateObserver_SessionAutomation {}

public native struct gsmStateObserver_SessionChanged {}

public native struct gsmStateObserver_UserSignInOut {}

public native struct HeadlessGameEngine {}

public native struct HeatAgent {
  native let timeToNextUpdate: Float;
  native let heatRadius: Float;
  native let heatValue: Float;
}

public native struct InfluenceObstacleAgent {
  native let useMeshes: Bool;
  native let radius: Float;
}

public native struct InfluenceReservationAgent {
  native let radius: Float;
}

public native struct InfluenceSeparationAgent {
  native let radius: Float;
}

public native struct inkAdditionalContentDataReloadProgress {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkAdditionalContentInstalledCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkAdditionalContentInstallRequestedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkAdditionalContentPurchaseCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkAdditionalContentStatusUpdateCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkAdvertisementsLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkanimAnimationCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkBoolCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkButtonClickCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkButtonHoldCompleteCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkButtonProgressChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkButtonSelectionCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkButtonStateChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkCharacterEventCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkCloudSavesQueryStatusChange {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkCloudSaveUploadFinish {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkComboBoxVisibleChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkCursorContextCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkCustomCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkDebugLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let entries: array<inkDebugLayerEntry>;
}

public native struct inkDefaultCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkDeleteRequestResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkEditorModeState {}

public native struct inkEmptyCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkEndGameLoadingState {}

public native struct inkEngagementScreenState {}

public native struct inkFastTravelLoadingScreenData {}

public native struct inkFastTravelLoadingState {}

public native struct inkFocusEventCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkGameNotificationCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkGameNotificationsLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let cursorResource: ResourceRef; // rRef<inkWidgetLibraryResource>
}

public native struct inkGameState {}

public native struct inkHUDLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let entriesResource: ResourceRef; // rRef<inkHudEntriesResource>
}

public native struct inkHyperlinkCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public abstract native struct inkIAdvertisementWidgetComponentWrapper {}

public native struct inkIconAtlasManager {}

public native struct inkILoadingScreenPersistentData {}

public native struct inkInGameMenuState {}

public native struct inkInitEngineState {}

public native struct inkInitializeUserScreenState {}

public native struct inkInitialLoadingScreenData {}

public native struct inkInitialLoadingScreenSaveData {}

public native struct inkInitialLoadingState {}

public native struct inkInputContextChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkInputDeviceCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkInputDeviceIdCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public abstract native struct inkIStreetSignWidgetComponentWrapper {}

public abstract native struct inkIWorldFluffWidgetComponentWrapper {}

public native struct inkLinePatternRef {
  native let widget: wref<inkWidget>;
}

public native struct inkListControllerCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkListItemControllerCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkLoadingFadeInOutCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkLoadingLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let splashLoadingScreenResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let initialLoadingScreenResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let fastTravelLoadingScreenResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
  native let fallbackLoadingScreenResource: ResourceAsyncRef; // raRef<inkWidgetLibraryResource>
}

public native struct inkLoadingStateChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkMenuCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkMenuLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let menuResource: ResourceRef; // rRef<inkMenuResource>
  native let cursorResource: ResourceRef; // rRef<inkWidgetLibraryResource>
}

public native struct inkMenuVisibilityChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkMinigameMenuState {}

public native struct inkNullIconAtlasManager {}

public native struct inkOffscreenLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkOnGogLoginStatusChangedResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkPauseMenuState {}

public native struct inkPhotoModeLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let photoModeResource: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let stickersResource: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let cursorResource: ResourceRef; // rRef<inkWidgetLibraryResource>
}

public native struct inkPhotoModeState {}

public native struct inkPointerEventCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkPreGameMenuState {}

public native struct inkQuadRef {
  native let widget: wref<inkWidget>;
}

public native struct inkRadioGroupChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSaveMetadataRequestResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSaveTransferRequestUpdate {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkScreenProjectionCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSelectionChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSettingChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSliderControllerHandleReleasedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSliderControllerInputCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSliderControllerValueChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkStateChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkStepperChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkStreetSignsLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkSystemNotificationsLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let cursorResource: ResourceRef; // rRef<inkWidgetLibraryResource>
}

public native struct inkSystemRequesResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkSystemServerRequesResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkTextCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkToggleBreachingCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkToggleChangedCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkTrialOnBuyFullGame {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkTrialVersionRemainingTimeUpdate {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkUserIdResult {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkVariantCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkVector2Callback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkVideoInstanceDoneCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkVideoLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkVirtualCompoundControllerCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkVirtualCompoundItemControllerCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkVirtualCompoundItemSelectControllerCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct inkWaitingSignLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let introAnimName: CName;
  native let waitingAnimName: CName;
  native let outroAnimName: CName;
  native let delayTime: Float;
  native let introTime: Float;
  native let waitingTime: Float;
  native let postWaitTime: Float;
  native let outroTime: Float;
}

public native struct inkWatermarksLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
}

public native struct inkWorldLayerDefinition {
  native let enabled: Bool;
  native let rootLibrary: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let activeByDefault: Bool;
  native let isPermanent: Bool;
  native let useGlobalStyleTheme: Bool;
  native let isAffectedByFadeout: Bool;
  native let useGameInput: Bool;
  native let inputContext: CName;
  native let projectionPlaneSize: Vector2;
  native let renderingPlane: ERenderingPlane;
  native let isAlwaysVisible: Bool;
  native let isInteractableFromBehind: Bool;
  native let maxInteractionDistance: Float;
  native let overrideMaxInteractionDistance: Bool;
  native let useCustomFaceVector: Bool;
  native let faceVector: Vector3;
}

public native struct inputInputSystemEditor {}

public native struct inputInputSystemNullInterface {}

public abstract native struct inputInputSystemWin32Base {}

public native struct inputInputSystemWin32Game {}

public native struct InternalFunctionalTestsGameEngine {}

public native struct locPackageLocalizationStringSerializer {}

public native struct moveMovePoliciesComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
  native let movePolicies: moveReplicatedMovePoliciesState;
}

public native struct moveReplicatedMovePolicies {
  native let entity: wref<Entity>;
  native let netTime: netTime;
  native let key: Uint64;
  native let policies: ref<MovePolicies>;
}

public native struct mpClientGameSession {}

public native struct mpGameSession {}

public native struct mpLocalPlayer {
  native let peerID: netPeerID;
  native let nickname: String;
}

public native struct mpPersistentTestBoxState {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
  native let isOn: Bool;
  native let weakPersistentEntity: wref<mpPersistentTestBox>;
  native let weakPersistentEntityComponent: wref<IComponent>;
  native let weakDynamicEntity: wref<GameObject>;
  native let weakDynamicEntityComponent: wref<IComponent>;
}

public abstract native struct mpPlayer {
  native let peerID: netPeerID;
  native let nickname: String;
}

public native struct mpRemotePlayer {
  native let peerID: netPeerID;
  native let nickname: String;
}

public native struct mpServerGameSession {}

public native struct mpServerPlayer {
  native let peerID: netPeerID;
  native let nickname: String;
}

public native struct netDefaultComponentReplicatedState {
  native let componentName: CName;
  native let enabled: Bool;
}

public native struct netEntityReplicatedState {
  native let recordID: TweakDBID;
  native let persistentID: Uint64;
}

public native struct physicsPhysicsJointAngularLimitPair {
  native let restitution: Float;
  native let bounceThreshold: Float;
  native let stiffness: Float;
  native let damping: Float;
  native let contactDistance: Float;
  native let twist: physicsPhysicsJointMotion;
  native let upper: Float;
  native let lower: Float;
}

public native struct physicsPhysicsJointLimitConePair {
  native let restitution: Float;
  native let bounceThreshold: Float;
  native let stiffness: Float;
  native let damping: Float;
  native let contactDistance: Float;
  native let swingY: physicsPhysicsJointMotion;
  native let swingZ: physicsPhysicsJointMotion;
  native let yAngle: Float;
  native let zAngle: Float;
}

public native struct physicsPhysicsJointLinearLimit {
  native let restitution: Float;
  native let bounceThreshold: Float;
  native let stiffness: Float;
  native let damping: Float;
  native let contactDistance: Float;
  native let x: physicsPhysicsJointMotion;
  native let y: physicsPhysicsJointMotion;
  native let z: physicsPhysicsJointMotion;
  native let value: Float;
}

public native struct PlayerLevelBasedQuestRequestFilter {
  native let percentMargin: Uint32;
}

public importonly native struct PointOfInterestMappinData {
  native let typedVariant: ref<gamemappinsIPointOfInterestVariant>;
  native let active: Bool;
  native let slotName: CName;
  native let slotOffset: Vector3;
  native let dynamicMappinRadius: Float;
  native let staticMappinDef: TweakDBID;
  native let dynamicMappinDef: TweakDBID;
}

public native struct questdbgCallstackPhase {
  native let id: Uint64;
  native let parentId: Uint64;
  native let phases: array<Uint64>;
  native let blocks: array<Uint64>;
}

public native struct QuestDistanceRequestFilter {
  native let distanceSquared: Float;
}

public native struct questRadioAnnouncementPlayer {}

public native struct QuestTypeRequestFilter {
  native let includeMainQuests: Bool;
  native let includeSideQuests: Bool;
  native let includeStreetStories: Bool;
  native let includeCyberPsycho: Bool;
  native let includeContracts: Bool;
}

public native struct RayTracingCustomData {}

public native struct RayTracingRenderDebugCustomData {}

public native struct redCHelpCommandlet {}

public native struct redCVersionCommandlet {}

public native struct redPackageDataBufferSerializer {}

public native struct redPackageRUIDSerializer {}

public native struct redPackageStringSerializer {}

public native struct redPackageTweakDBIDSerializer {}

public native struct RenderProxyCustomData_ClusteredProxyDisabledInstances {}

public native struct RenderProxyCustomData_Garment {}

public native struct RenderProxyCustomData_MaterialParams {}

public native struct RenderProxyCustomData_Mirror {}

public native struct RenderProxyCustomData_MiscMeshParams {}

public native struct RenderProxyCustomData_OriginalLodGroups {}

public native struct RenderProxyCustomData_Skinning {}

public native struct RenderTexturePreviewData {}

public native struct Sample_Customized_Replicated_Root_Object {
  native let bool: Bool;
  native let bool2: Bool;
}

public native struct saveMetadata {
  native let gameDefinition: String;
  native let activeQuests: String;
  native let trackedQuestEntry: String;
  native let trackedQuest: String;
  native let mainQuest: String;
  native let debugString: String;
  native let locationName: String;
  native let playerPosition: Vector3;
  native let playTime: Double;
  native let playthroughTime: Double;
  native let nextSavableEntityID: Uint32;
  native let nextNonSavableEntityID: Uint32;
  native let lifePath: gamedataLifePath;
  native let bodyGender: String;
  native let brainGender: String;
  native let level: Float;
  native let streetCred: Float;
  native let gunslinger: Float;
  native let assault: Float;
  native let demolition: Float;
  native let athletics: Float;
  native let brawling: Float;
  native let coldBlood: Float;
  native let stealth: Float;
  native let engineering: Float;
  native let crafting: Float;
  native let hacking: Float;
  native let combatHacking: Float;
  native let strength: Float;
  native let intelligence: Float;
  native let reflexes: Float;
  native let technicalAbility: Float;
  native let cool: Float;
  native let initialBuildID: String;
  native let finishedQuests: String;
  native let playthroughID: String;
  native let pointOfNoReturnId: String;
  native let visitID: String;
  native let buildSKU: String;
  native let buildPatch: String;
  native let difficulty: gameDifficulty;
  native let facts: array<String>;
  native let saveVersion: Uint32;
  native let gameVersion: Uint32;
  native let timestampString: String;
  native let name: String;
  native let userName: String;
  native let buildID: String;
  native let platform: String;
  native let censorFlags: String;
  native let buildConfiguration: String;
  native let fileSize: Uint32;
  native let isForced: Bool;
  native let isCheckpoint: Bool;
  native let initialLoadingScreenID: Uint64;
  native let isStoryMode: Bool;
  native let isPointOfNoReturn: Bool;
  native let isEndGameSave: Bool;
  native let isModded: Bool;
  native let additionalContentIds: array<CName>;
}

public native struct SceneCustomData_ColorFadeParams {}

public native struct SceneCustomData_DistantShadows {}

public abstract native struct SceneCustomData_DistantShadowsCommon {}

public native struct SceneCustomData_InteriorMap {}

public native struct SceneCustomData_RainMap {}

public native struct SceneCustomData_ReflectionAtlas {}

public native struct SceneCustomData_Selection {}

public native struct SceneCustomData_ShadowManager {}

public native struct servicesCloudSavesQueryStatusChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct servicesCloudSaveUploadFinishCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public abstract native struct servicesGameServices {}

public native struct servicesGameServicesWin {}

public native struct SimpleTemporalCustomData {}

public native struct SSRCustomData {}

public native struct STonemappingACESParamsHDR {
  native let minStops: Float;
  native let maxStops: Float;
  native let midGrayScale: Float;
  native let surroundGamma: Float;
  native let toneCurveSaturation: Float;
  native let adjustWhitePoint: Bool;
  native let desaturate: Bool;
  native let dimSurround: Bool;
  native let tonemapLuminance: Bool;
  native let applyAfterLUT: Bool;
}

public native struct STonemappingACESParamsSDR {
  native let minStops: Float;
  native let maxStops: Float;
  native let midGrayScale: Float;
  native let surroundGamma: Float;
  native let toneCurveSaturation: Float;
  native let adjustWhitePoint: Bool;
  native let desaturate: Bool;
  native let dimSurround: Bool;
  native let tonemapLuminance: Bool;
  native let applyAfterLUT: Bool;
}

public native struct TXAACustomData {}

public native struct VolCloudsCustomData {}

public native struct VolFogCustomData {}

public native struct VRSCustomData {}

public native struct WaterCustomData {}

public native struct workAdjustAndPlayCommandData {}

public native struct workAnimObjectDebuggerCommandData {}

public native struct workDebuggerCommandData {}

public native struct workDebugSourceCommandData {}

public native struct workDynamicSyncBindAnimComponentCommandData {
  native let slave: wref<AnimationControllerComponent>;
}

public native struct workDynamicSyncBindCommandData {
  native let masterID: EntityID;
}

public native struct workEquipItemCommandData {}

public native struct workEventListenerCommandData {}

public native struct workExcludedGesturesData {}

public native struct workFastExitCommandData {}

public native struct workFastForwardData {}

public native struct workFunctionalTestsDebuggerCommandData {}

public native struct workIdleOnlyModeCommandData {}

public native struct workIdleTransitionCommandData {}

public native struct workInternalCached_StopCommandData {}

public native struct workItemOverrideCommandData {}

public native struct workJumpToCommandData {}

public native struct workMaxAnimTimeLimitCommandData {}

public native struct workRegisterCleanupCommandData {}

public native struct workSetInfiniteSequenceCommandData {}

public native struct workSetSequenceCategoriesCommandData {
  native let sequenceCategories: gameCategorySelectionProbability;
}

public native struct workShadowDebugger {}

public native struct workSlowExitCommandData {}

public native struct workSyncBindBaseCommandData {}

public native struct workTransferItemOwnershipCommandData {}

public native struct workworkspotAnimObjectDebugger {}

public native struct workWorkspotFunctionalTestsDebuggingTool {}

public native struct worldGroupProxyMeshBuildParams {
  native let buildProxy: Bool;
  native let type: worldProxyMeshBuildType;
  native let usedMesh: worldProxyMeshOutputType;
  native let resolution: Uint32;
  native let polycount: Uint32;
  native let polycountPercentage: Float;
  native let coreAxis: worldProxyCoreAxis;
  native let groupingNormals: worldProxyGroupingNormals;
  native let forceSurfaceFlattening: Bool;
  native let forceSeamlessModule: Bool;
  native let enableAlphaMask: Bool;
  native let windows: worldProxyWindowsParams;
  native let textures: worldProxyTextureParams;
  native let customGeometry: worldProxyCustomGeometryParams;
  native let advancedParams: worldProxyMeshAdvancedBuildParams;
}

public native struct worldPackageNodeRefSerializer {}

public native struct worlduiAdvertisementWidgetComponentWrapper {}

public native struct worlduiAdvertisementWidgetNodeInstanceWrapper {}

public native struct worlduiStreetSignWidgetComponentWrapper {}

public native struct worlduiWorldInteractionChangeCallback {
  native let callbackName: CName;
  native let listeners: array<inkCallbackListener>;
}

public native struct worlduiWorldLayerWidget {}

public native struct audioAudioEventMetadataArrayElement {
  native let redId: CName;
  native let wwiseId: Uint32;
  native let maxAttenuation: Float;
  native let minDuration: Float;
  native let maxDuration: Float;
  native let isLooping: Bool;
  native let stopActionEvents: array<CName>;
  native let tags: array<CName>;
}

public native class CMaterialInstance extends IMaterial {
  native let baseMaterial: ResourceRef; // rRef<IMaterial>
  native let enableMask: Bool;
  native let audioTag: CName;
  native let resourceVersion: Uint8;
  native let params: array<MaterialParameterInstance>;
}

public native struct CMeshMaterialEntry {
  native let name: CName;
  native let index: Uint16;
  native let isLocalInstance: Bool;
  native let material: wref<IMaterial>;
}

public abstract native class CResource extends ISerializable {
    native let cookingPlatform: ECookingPlatform;
    native let path: ResRef;
}

public native class entVisualControllerComponent extends IComponent {
  native let meshProxy: ResourceRef; // rRef<CMesh>
  native let appearanceDependency: array<entVisualControllerDependency>;
  native let cookedAppearanceData: ResourceAsyncRef; // raRef<appearanceCookedAppearanceData>
  native let forcedLodDistance: entForcedLodDistance;
  public native func LoadAppearanceDependencies(opt wait: Bool) -> Bool
}

public abstract native class gameuiBaseUIData extends ISerializable {
  native let id: Int64;
}

public abstract native class graphGraphSocketDefinition extends graphIGraphObjectDefinition {
  native let name: CName;
  native let connections: array<ref<graphGraphConnectionDefinition>>;
  native let owner: wref<graphGraphNodeDefinition>;
}

public native class inkGrid extends inkCompoundWidget {
    native let orientation: inkEOrientation;
    native let childPadding: inkMargin;
    native let childSizeStep: Vector2;
    public func GetOrientation() -> inkEOrientation {
        return this.orientation;
    }
    public func SetOrientation(value: inkEOrientation) {
        this.orientation = value;
    }
    public func GetChildPadding() -> inkMargin {
        return this.childPadding;
    }
    public func SetChildPadding(value: inkMargin) {
        this.childPadding = value;
    }
    public func GetChildSizeStep() -> Vector2 {
        return this.childSizeStep;
    }
    public func SetChildSizeStep(value: Vector2) {
        this.childSizeStep = value;
    }
}

public native struct inkHudWidgetSpawnEntry {
  native let hudEntryName: CName;
  native let enabled: Bool;
  native let spawnMode: inkSpawnMode;
  native let widgetResource: ResourceRef; // rRef<inkWidgetLibraryResource>
  native let anchorPlace: inkEAnchor;
  native let anchorPoint: Vector2;
  native let margins: inkMargin;
  native let attachToSlot: Bool;
  native let slotParams: inkWidgetSlotAttachmentParams;
  native let useSeparateWindow: Bool;
  native let ignoreHudSafezones: Bool;
  native let affectedByGlitchEffect: Bool;
  native let affectedByBlackwallEffect: Bool;
  native let spawnBeforeSlots: Bool;
  native let ignoreHudScaleOverride: Bool;
  native let hudScalingInterpolationValue: Float;
  native let hudScalingMarginCorrection: inkMargin;
}

public abstract native class inkWorldWidgetInfos extends inkUserData {
    public native func GetComponent() -> ref<IComponent>
}

public abstract native class ISerializable {
    public final native func GetClassName() -> CName
    public final native func IsA(className: CName) -> Bool
    public final native func IsExactlyA(className: CName) -> Bool
    public final native func Clone() -> ref<ISerializable>
    public final native func RefreshResource(opt disablePreInitialization: Bool)
}

public native class scnChatter extends ISerializable {
  native let id: Uint16;
  native let voicesetComponent: wref<VoicesetComponent>;
}

public native class workWorkspotInstance extends ISerializable {
  native let tree: ref<workWorkspotTree>;
  native let resource: ref<workWorkspotResource>;
  native let animName: CName;
  native let idleAnim: CName;
  native let entryId: WorkEntryId;
}

public abstract native class worldINodeInstance extends ISerializable {
    public native func GetNode() -> ref<worldNode>
    public native func GetTransform() -> Transform
    public native func GetScale() -> Vector3
    public native func GetGlobalNodeID() -> GlobalNodeID
    public native func GetProxyNodeID() -> GlobalNodeID
    public native func GetStreamingDistance() -> Float
}

public native class worldStreamingSector extends CResource {
    native let localInplaceResource: array<ResourceRef>;
    native let externInplaceResource: ResourceAsyncRef; // raRef<worldStreamingSectorInplaceContent>
    native let level: Uint8;
    native let category: worldStreamingSectorCategory;
    public native func GetNodes() -> array<ref<worldNode>>
    public native func GetNodeCount() -> Int32
    public native func GetNode(index: Int32) -> ref<worldNode>
    public native func GetNodeSetupCount() -> Int32
    public native func GetNodeSetup(index: Int32) -> ref<WorldNodeSetupWrapper>
    public native func GetNodeRefs() -> array<NodeRef>
    public native func GetNodeRefCount() -> Int32
    public native func GetNodeRef(index: Int32) -> NodeRef
}

enum CallbackLifetime {
    Session = 0,
    Forever = 1,
}

enum CallbackRunMode {
    Default = 0,
    Once = 1,
    OncePerTarget = 2,
}

public native class CallbackSystem extends IGameSystem {
    public native func RegisterCallback(eventName: CName, target: ref<IScriptable>, function: CName, opt sticky: Bool) -> ref<CallbackSystemHandler>
    public native func RegisterStaticCallback(eventName: CName, target: CName, function: CName, opt sticky: Bool) -> ref<CallbackSystemHandler>
    public native func UnregisterCallback(eventName: CName, target: ref<IScriptable>, opt function: CName)
    public native func UnregisterStaticCallback(eventName: CName, target: CName, opt function: CName)
    public native func RegisterEvent(eventName: CName, opt eventType: CName) -> Bool
    public native func DispatchEvent(eventObject: ref<CallbackSystemEvent>)
    public native func DispatchEventAs(eventName: CName, eventObject: ref<CallbackSystemEvent>)
}
@addMethod(GameInstance)
public static native func GetCallbackSystem() -> ref<CallbackSystem>

public abstract native class CallbackSystemEvent {
    public native func GetEventName() -> CName
}

public native class CallbackSystemHandler {
    public native func AddTarget(target: ref<CallbackSystemTarget>) -> ref<CallbackSystemHandler>
    public native func RemoveTarget(target: ref<CallbackSystemTarget>) -> ref<CallbackSystemHandler>
    public native func SetRunMode(runMode: CallbackRunMode) -> ref<CallbackSystemHandler>
    public native func SetLifetime(lifetime: CallbackLifetime) -> ref<CallbackSystemHandler>
    public native func IsRegistered() -> Bool
    public native func Unregister()
}

public abstract native class CallbackSystemTarget {}

public native class AxisInputEvent extends KeyInputEvent {
    public native func GetValue() -> Float
    public native func GetMouseX() -> Uint32
    public native func GetMouseY() -> Uint32
}

public native class EntityBuilderEvent extends CallbackSystemEvent {
    public native func GetEntityBuilder() -> ref<EntityBuilderWrapper>
}

public native class EntityComponentEvent extends EntityLifecycleEvent {
    public native func GetComponent() -> wref<IComponent>
}

public native class EntityLifecycleEvent extends CallbackSystemEvent {
    public native func GetEntity() -> wref<Entity>
}

public native class GameSessionEvent extends CallbackSystemEvent {
    public native func IsRestored() -> Bool
    public native func IsPreGame() -> Bool
}

public native class inkWidgetSpawnEvent extends CallbackSystemEvent {
    public native func GetLibraryPath() -> ResRef
    public native func GetItemName() -> CName
    public native func GetItemInstance() -> ref<inkWidgetLibraryItemInstance>
}

public native class KeyInputEvent extends CallbackSystemEvent {
    public native func GetAction() -> EInputAction
    public native func GetKey() -> EInputKey
    public native func IsShiftDown() -> Bool
    public native func IsControlDown() -> Bool
    public native func IsAltDown() -> Bool
}

public native class ResourceEvent extends CallbackSystemEvent {
    public native func GetResource() -> ref<CResource>
    public native func GetPath() -> ResRef
}

public native class VehicleLightControlEvent extends EntityLifecycleEvent {
    public native func IsEnabled() -> Bool
    public native func IsLightType(lightType: vehicleELightType) -> Bool
}

public native class ComponentTarget extends CallbackSystemTarget {
    public static native func ID(id: CRUID) -> ref<ComponentTarget>
    public static native func Name(name: CName) -> ref<ComponentTarget>
}

public native class DynamicEntityTarget extends CallbackSystemTarget {
    public static native func Tag(tag: CName) -> ref<DynamicEntityTarget>
    public static native func Tags(tags: array<CName>) -> ref<DynamicEntityTarget>
}

public native class EntityTarget extends CallbackSystemTarget {
    public static native func ID(entityID: EntityID) -> ref<EntityTarget>
    public static native func Type(entityType: CName) -> ref<EntityTarget>
    public static native func RecordID(recordID: TweakDBID) -> ref<EntityTarget>
    public static native func Template(templatePath: ResRef) -> ref<EntityTarget>
    public static native func Appearance(appearanceName: CName) -> ref<EntityTarget>
    public static native func Definition(appearancePath: ResRef, opt definitionName: CName) -> ref<EntityTarget>
}

public native class inkWidgetTarget extends CallbackSystemTarget {
    public static native func Library(library: ResRef, opt item: CName) -> ref<inkWidgetTarget>
    public static native func Controller(type: CName) -> ref<inkWidgetTarget>
}

public native class InputTarget extends CallbackSystemTarget {
    public static native func Key(key: EInputKey, opt action: EInputAction) -> ref<InputTarget>
    public static native func Axis(axis: EInputKey, opt threshold: Float) -> ref<InputTarget>
}

public native class ResourceTarget extends CallbackSystemTarget {
    public static native func Path(resourcePath: ResRef) -> ref<ResourceTarget>
    public static native func Type(resourceType: CName) -> ref<ResourceTarget>
}

public native class StaticEntityTarget extends CallbackSystemTarget {
    public static native func Tag(tag: CName) -> ref<StaticEntityTarget>
    public static native func Tags(tags: array<CName>) -> ref<StaticEntityTarget>
}

public native struct CurvePointFloat {
    public native let point: Float;
    public native let value: Float;
}
public native struct CurveDataFloat {
    public static native func GetInterpolationType(self: script_ref<CurveDataFloat>) -> curveEInterpolationType
    public static native func SetInterpolationType(self: script_ref<CurveDataFloat>, type: curveEInterpolationType)
    public static native func GetLinkType(self: script_ref<CurveDataFloat>) -> curveESegmentsLinkType
    public static native func SetLinkType(self: script_ref<CurveDataFloat>, type: curveESegmentsLinkType)
    public static native func GetSize(self: script_ref<CurveDataFloat>) -> Uint32
    public static native func SetSize(self: script_ref<CurveDataFloat>, newSize: Uint32)
    public static native func GetPoint(self: script_ref<CurveDataFloat>, index: Uint32) -> CurvePointFloat
    public static native func GetPointValue(self: script_ref<CurveDataFloat>, index: Uint32, out point: Float, out value: Float)
    public static native func SetPoint(self: script_ref<CurveDataFloat>, index: Uint32, point: CurvePointFloat)
    public static native func SetPointValue(self: script_ref<CurveDataFloat>, index: Uint32, point: Float, value: Float)
}
public native struct CurvePointVector2 {
    public native let point: Float;
    public native let value: Vector2;
}
public native struct CurveDataVector2 {
    public static native func GetInterpolationType(self: script_ref<CurveDataVector2>) -> curveEInterpolationType
    public static native func SetInterpolationType(self: script_ref<CurveDataVector2>, type: curveEInterpolationType)
    public static native func GetLinkType(self: script_ref<CurveDataVector2>) -> curveESegmentsLinkType
    public static native func SetLinkType(self: script_ref<CurveDataVector2>, type: curveESegmentsLinkType)
    public static native func GetSize(self: script_ref<CurveDataVector2>) -> Uint32
    public static native func SetSize(self: script_ref<CurveDataVector2>, newSize: Uint32)
    public static native func GetPoint(self: script_ref<CurveDataVector2>, index: Uint32) -> CurvePointVector2;
    public static native func GetPointValue(self: script_ref<CurveDataVector2>, index: Uint32, out point: Float, out value: Vector2)
    public static native func SetPoint(self: script_ref<CurveDataVector2>, index: Uint32, point: CurvePointVector2)
    public static native func SetPointValue(self: script_ref<CurveDataVector2>, index: Uint32, point: Float, value: Vector2)
}
public native struct CurvePointVector3 {
    public native let point: Float;
    public native let value: Vector3;
}
public native struct CurveDataVector3 {
    public static native func GetInterpolationType(self: script_ref<CurveDataVector3>) -> curveEInterpolationType
    public static native func SetInterpolationType(self: script_ref<CurveDataVector3>, type: curveEInterpolationType)
    public static native func GetLinkType(self: script_ref<CurveDataVector3>) -> curveESegmentsLinkType
    public static native func SetLinkType(self: script_ref<CurveDataVector3>, type: curveESegmentsLinkType)
    public static native func GetSize(self: script_ref<CurveDataVector3>) -> Uint32
    public static native func SetSize(self: script_ref<CurveDataVector3>, newSize: Uint32)
    public static native func GetPoint(self: script_ref<CurveDataVector3>, index: Uint32) -> CurvePointVector3;
    public static native func GetPointValue(self: script_ref<CurveDataVector3>, index: Uint32, out point: Float, out value: Vector3)
    public static native func SetPoint(self: script_ref<CurveDataVector3>, index: Uint32, point: CurvePointVector3)
    public static native func SetPointValue(self: script_ref<CurveDataVector3>, index: Uint32, point: Float, value: Vector3)
}
public native struct CurvePointVector4 {
    public native let point: Float;
    public native let value: Vector4;
}
public native struct CurveDataVector4 {
    public static native func GetInterpolationType(self: script_ref<CurveDataVector4>) -> curveEInterpolationType
    public static native func SetInterpolationType(self: script_ref<CurveDataVector4>, type: curveEInterpolationType)
    public static native func GetLinkType(self: script_ref<CurveDataVector4>) -> curveESegmentsLinkType
    public static native func SetLinkType(self: script_ref<CurveDataVector4>, type: curveESegmentsLinkType)
    public static native func GetSize(self: script_ref<CurveDataVector4>) -> Uint32
    public static native func SetSize(self: script_ref<CurveDataVector4>, newSize: Uint32)
    public static native func GetPoint(self: script_ref<CurveDataVector4>, index: Uint32) -> CurvePointVector4;
    public static native func GetPointValue(self: script_ref<CurveDataVector4>, index: Uint32, out point: Float, out value: Vector4)
    public static native func SetPoint(self: script_ref<CurveDataVector4>, index: Uint32, point: CurvePointVector4)
    public static native func SetPointValue(self: script_ref<CurveDataVector4>, index: Uint32, point: Float, value: Vector4)
}
public native struct CurvePointHDRColor {
    public native let point: Float;
    public native let value: HDRColor;
}
public native struct CurveDataHDRColor {
    public static native func GetInterpolationType(self: script_ref<CurveDataHDRColor>) -> curveEInterpolationType
    public static native func SetInterpolationType(self: script_ref<CurveDataHDRColor>, type: curveEInterpolationType)
    public static native func GetLinkType(self: script_ref<CurveDataHDRColor>) -> curveESegmentsLinkType
    public static native func SetLinkType(self: script_ref<CurveDataHDRColor>, type: curveESegmentsLinkType)
    public static native func GetSize(self: script_ref<CurveDataHDRColor>) -> Uint32
    public static native func SetSize(self: script_ref<CurveDataHDRColor>, newSize: Uint32)
    public static native func GetPoint(self: script_ref<CurveDataHDRColor>, index: Uint32) -> CurvePointHDRColor;
    public static native func GetPointValue(self: script_ref<CurveDataHDRColor>, index: Uint32, out point: Float, out value: HDRColor)
    public static native func SetPoint(self: script_ref<CurveDataHDRColor>, index: Uint32, point: CurvePointHDRColor)
    public static native func SetPointValue(self: script_ref<CurveDataHDRColor>, index: Uint32, point: Float, value: HDRColor)
}

public native class ResourceDepot {
    public native func ArchiveExists(name: String) -> Bool
    public native func ResourceExists(path: ResRef) -> Bool
    public native func LoadResource(path: ResRef) -> ref<ResourceToken>
}
@addMethod(GameInstance)
public static native func GetResourceDepot() -> ref<ResourceDepot>

public native struct ResourceRef {
    public static native func LoadPath(self: script_ref<ResourceRef>, path: ResRef)
    public static native func GetPath(self: script_ref<ResourceRef>) -> ResRef
    public static native func GetHash(self: script_ref<ResourceRef>) -> Uint64
    public static native func GetToken(self: script_ref<ResourceRef>) -> ref<ResourceToken>
    public static native func GetResource(self: script_ref<ResourceRef>) -> ref<CResource>
    public static native func IsEmpty(self: script_ref<ResourceRef>) -> Bool
    public static native func IsLoaded(self: script_ref<ResourceRef>) -> Bool
    public static native func IsFailed(self: script_ref<ResourceRef>) -> Bool
    public static native func ToVariant(self: script_ref<ResourceRef>, type: CName) -> Variant
    public static native func FromVariant(variant: Variant) -> ResourceRef
    public static func FromPath(path: ResRef) -> ResourceRef {
        let reference: ResourceRef;
        ResourceRef.LoadPath(reference, path);
        return reference;
    }
}
public native struct ResourceAsyncRef {
    public static native func SetPath(self: script_ref<ResourceAsyncRef>, path: ResRef)
    public static native func GetPath(self: script_ref<ResourceAsyncRef>) -> ResRef
    public static native func GetHash(self: script_ref<ResourceAsyncRef>) -> Uint64
    public static native func IsEmpty(self: script_ref<ResourceAsyncRef>) -> Bool
}
public static func OperatorAssignMultiply(out res: ResourceRef, path: ResRef) {
    ResourceRef.LoadPath(res, path);
}
public static func OperatorAssignMultiply(out res: ResourceAsyncRef, path: ResRef) {
    ResourceAsyncRef.SetPath(res, path);
}
@addMethod(ResRef)
public static native func GetHash(self: ResRef) -> Uint64
@addMethod(ResRef)
public static native func ToString(self: ResRef) -> String
public static func OperatorEqual(lhs: ResourceAsyncRef, rhs: ResRef) -> Bool {
    return Equals(ResourceAsyncRef.GetPath(lhs), rhs);
}
public static func OperatorNotEqual(lhs: ResourceAsyncRef, rhs: ResRef) -> Bool {
    return NotEquals(ResourceAsyncRef.GetPath(lhs), rhs);
}
public static func OperatorEqual(lhs: ResRef, rhs: ResRef) -> Bool {
    return Equals(lhs, rhs);
}
public static func OperatorNotEqual(lhs: ResRef, rhs: ResRef) -> Bool {
    return NotEquals(lhs, rhs);
}

public native class ResourceToken {
    public native func GetResource() -> ref<CResource>
    public native func GetPath() -> ResRef
    public native func GetHash() -> Uint64
    public native func IsFinished() -> Bool
    public native func IsLoaded() -> Bool
    public native func IsFailed() -> Bool
    public native func RegisterCallback(target: ref<IScriptable>, function: CName)
}

public native class ResetSecuritySystemNetwork extends Event {}

@addMethod(SecuritySystemControllerPS)
protected final func ReinitializeSecuritySystemAttitudeGroup() {
    let attitudeGroup = this.m_attitudeGroup;
    this.m_attitudeGroup = TDBID.None();
    this.SetSecuritySystemAttitudeGroup(attitudeGroup);
}
@addMethod(SecuritySystemControllerPS)
protected func QueueSystemEvent(evt: ref<Event>, opt self: Bool) {
    if self {
        this.QueueEntityEvent(PersistentID.ExtractEntityID(this.GetID()), evt);
    }
    if IsDefined(this.m_agentsRegistry) {
        for agent in this.m_agentsRegistry.GetAgents() {
            this.QueueEntityEvent(PersistentID.ExtractEntityID(this.GetPS(agent.link).GetID()), evt);
        }
    }
}
@addMethod(SecuritySystemControllerPS)
protected func QueueSystemPSEvent(evt: ref<Event>, opt self: Bool) {
    if self {
        this.QueuePSEvent(this, evt);
    }
    if IsDefined(this.m_agentsRegistry) {
        for agent in this.m_agentsRegistry.GetAgents() {
            this.QueuePSEvent(this.GetPS(agent.link), evt);
        }
    }
}
@addMethod(SecuritySystemControllerPS)
protected func OnResetSecuritySystemNetwork(evt: ref<ResetSecuritySystemNetwork>) -> EntityNotificationType {
    if !this.m_agentsRegistry.IsReady() {
        this.CompileSecurityAgentRegistry();
    }
    this.QueueSystemPSEvent(this.ActionQuestForceDisabled());
    this.QueueSystemPSEvent(this.ActionQuestResetDeviceToInitialState());
    this.ReinitializeSecuritySystemAttitudeGroup();
    this.QueueSystemPSEvent(this.ActionQuestRestoreQuickHacks());
    this.QueueSystemPSEvent(this.ActionQuestForceEnabled());
    this.OnQuestForceON(this.ActionQuestForceON());
    this.QueueSystemPSEvent(this.ActionQuestResetPerfomedActionsStorage(), true);
    return EntityNotificationType.SendThisEventToEntity;
}

@addMethod(EngineTime)
public final static native func GetFrequency() -> Uint64
@addMethod(EngineTime)
public final static native func FromTicks(value: Uint64) -> EngineTime
@addMethod(EngineTime)
public final static native func ToTicks(self: EngineTime) -> Uint64

@addMethod(Entity)
public native func GetTemplatePath() -> ResRef
@addMethod(Entity)
public native func GetComponents() -> array<ref<IComponent>>
@addMethod(Entity)
public native func FindComponentByType(type: CName) -> ref<IComponent>
@addMethod(Entity)
public native func AddComponent(component: ref<IComponent>)
@addMethod(Entity)
public native func ApplyMorphTarget(target: CName, region: CName, value: Float) -> Bool
@addMethod(Entity)
public native func SetWorldTransform(transform: WorldTransform)

public native class EntityBuilderWrapper {
    public native func HasEntity() -> Bool
    public native func HasAppearance() -> Bool
    public native func HasCustomAppearances() -> Bool
    public native func GetRecordID() -> TweakDBID
    public native func GetTemplatePath() -> ResRef
    public native func GetAppearanceName() -> CName
    public native func GetEntityID() -> EntityID
    public native func GetEntityType() -> CName
    public native func GetEntityParams() -> ref<entEntityParametersStorage>
    public native func GetTemplate() -> ref<EntityBuilderTemplateWrapper>
    public native func GetAppearance() -> ref<EntityBuilderAppearanceWrapper>
    public native func GetCustomAppearances() -> array<ref<EntityBuilderAppearanceWrapper>>
}
public native class EntityBuilderTemplateWrapper {
    public native func GetResource() -> ref<entEntityTemplate>
    public native func GetAppearanceName() -> CName
    public native func GetEntity() -> ref<Entity>
    public native func GetComponents() -> array<ref<IComponent>>
    public native func AddComponent(component: ref<IComponent>)
}
public native class EntityBuilderAppearanceWrapper {
    public native func GetResource() -> ref<appearanceAppearanceResource>
    public native func GetDefinition() -> ref<appearanceAppearanceDefinition>
    public native func GetComponents() -> array<ref<IComponent>>
    public native func AddComponent(component: ref<IComponent>)
}

@addMethod(EntityID)
public static native func FromHash(hash: Uint64) -> EntityID
@addMethod(EntityID)
public static native func ToHash(id: script_ref<EntityID>) -> Uint64

@addMethod(GameObject)
public native func AddTag(tag: CName)

@addMethod(IComponent)
public native func ChangeResource(path: ResRef, opt wait: Bool) -> Bool
@addMethod(IComponent)
public native func LoadResource(opt wait: Bool) -> Bool
@addMethod(IComponent)
public native func ChangeAppearance(name: CName, opt wait: Bool) -> Bool
@addMethod(IComponent)
public native func LoadAppearance(opt wait: Bool) -> Bool
@addMethod(IComponent)
public native func RefreshAppearance() -> Bool

@addMethod(PersistentID)
public static native func ForEntity(id: EntityID) -> PersistentID
@addMethod(PersistentID)
public static native func ForComponent(id: EntityID, component: CName) -> PersistentID
@addMethod(PersistentID)
public static native func ToHash(id: script_ref<PersistentID>) -> Uint64

public native struct TagList {
    native let tags: array<CName>;
    public static native func IsEmpty(self: script_ref<TagList>) -> Bool
    public static native func Clear(self: script_ref<TagList>)
    public static native func HasTag(self: script_ref<TagList>, tag: CName) -> Bool
    public static native func AddTag(self: script_ref<TagList>, tag: CName)
    public static native func RemoveTag(self: script_ref<TagList>, tag: CName)
    public static native func HasTags(self: script_ref<TagList>, tags: array<CName>) -> Bool
    public static native func AddTags(self: script_ref<TagList>, tags: array<CName>)
    public static native func RemoveTags(self: script_ref<TagList>, tags: array<CName>)
}

@addMethod(JournalManager)
public native func GetEntries(request: script_ref<JournalRequestContext>) -> array<wref<JournalEntry>>

@addMethod(TraceResult)
public final static native func GetHitObject(self: script_ref<TraceResult>) -> ref<ISerializable>
@addMethod(TraceResult)
public final static native func GetHitEntity(self: script_ref<TraceResult>) -> ref<Entity>

@addField(PlayerSystem)
private let m_customizationPuppet: wref<gamePuppet>;
@addField(PlayerSystem)
private let m_inventoryPuppet: wref<gamePuppet>;
@addField(PlayerSystem)
private let m_photoPuppet: wref<gamePuppet>;
@addMethod(PlayerSystem)
public func GetPlayer() -> ref<PlayerPuppet> {
    return this.GetLocalPlayerControlledGameObject() as PlayerPuppet;
}
@addMethod(PlayerSystem)
public func GetCustomizationPuppet() -> wref<gamePuppet> {
    return this.m_customizationPuppet;
}
@addMethod(PlayerSystem)
public func GetInventoryPuppet() -> wref<gamePuppet> {
    return this.m_inventoryPuppet;
}
@addMethod(PlayerSystem)
public func GetPhotoPuppet() -> wref<gamePuppet> {
    return this.m_photoPuppet;
}
@wrapMethod(inkPuppetPreviewGameController)
protected cb func OnPreviewInitialized() -> Bool {
    wrappedMethod();
    switch this.GetClassName() {
        case n"gameuiInventoryPuppetPreviewGameController":
            GameInstance.GetPlayerSystem(this.GetPlayerControlledObject().GetGame()).m_inventoryPuppet = this.GetGamePuppet();
            break;
        case n"gameuiCharacterCreationPuppetPreviewGameController":
            GameInstance.GetPlayerSystem(this.GetPlayerControlledObject().GetGame()).m_customizationPuppet = this.GetGamePuppet();
            break;
    }
}
@wrapMethod(PhotoModePlayerEntityComponent)
private final func SetupInventory(isCurrentPlayerObjectCustomizable: Bool) {
    wrappedMethod(isCurrentPlayerObjectCustomizable);
    GameInstance.GetPlayerSystem(this.GetOwner().GetGame()).m_photoPuppet = this.fakePuppet;
}

@addMethod(VehicleSystem)
public native func ToggleGarageVehicle(garageID: GarageVehicleID, enable: Bool) -> Bool
@addMethod(VehicleSystem)
public func EnablePlayerVehicleID(vehicleID: TweakDBID, enable: Bool, opt despawnIfDisabling: Bool) -> Bool {
    let playerVehicles = TweakDBInterface.GetForeignKeyArray(t"Vehicle.vehicle_list.list");
    if !ArrayContains(playerVehicles, vehicleID) {
        return false;
    }
    let garageID: GarageVehicleID;
    garageID.recordID = vehicleID;
    let success = this.ToggleGarageVehicle(garageID, enable);
    if success && !enable && despawnIfDisabling {
        this.DespawnPlayerVehicle(garageID);
    }
    return success;
}

@addMethod(WardrobeSystem)
public native func ForgetItemID(itemID: ItemID) -> Bool

enum ERTTIType
{
    Name = 0,
    Fundamental = 1,
    Class = 2,
    Array = 3,
    Simple = 4,
    Enum = 5,
    StaticArray = 6,
    NativeArray = 7,
    Pointer = 8,
    Handle = 9,
    WeakHandle = 10,
    ResourceReference = 11,
    ResourceAsyncReference = 12,
    BitField = 13,
    LegacySingleChannelCurve = 14,
    ScriptReference = 15,
    FixedArray = 16
}

public native struct Reflection {
    public static native func GetTypeOf(value: Variant) -> ref<ReflectionType>
    public static native func GetClassOf(object: Variant, opt actual: Bool) -> ref<ReflectionClass>
    public static native func GetType(name: CName) -> ref<ReflectionType>
    public static native func GetClass(name: CName) -> ref<ReflectionClass>
    public static native func GetEnum(name: CName) -> ref<ReflectionEnum>
    public static native func GetGlobalFunction(name: CName) -> ref<ReflectionStaticFunc>
    public static native func GetTypes() -> array<ref<ReflectionType>>
    public static native func GetClasses() -> array<ref<ReflectionClass>>
    public static native func GetDerivedClasses(base: CName) -> array<ref<ReflectionClass>>
    public static native func GetEnums() -> array<ref<ReflectionEnum>>
    public static native func GetGlobalFunctions() -> array<ref<ReflectionStaticFunc>>
}

public native class ReflectionClass extends ReflectionType {
    public native func GetAlias() -> CName
    public native func GetParent() -> ref<ReflectionClass>
    public native func GetProperty(name: CName) -> ref<ReflectionProp>
    public native func GetFunction(name: CName) -> ref<ReflectionMemberFunc>
    public native func GetStaticFunction(name: CName) -> ref<ReflectionStaticFunc>
    public native func GetProperties() -> array<ref<ReflectionProp>>
    public native func GetFunctions() -> array<ref<ReflectionMemberFunc>>
    public native func GetStaticFunctions() -> array<ref<ReflectionStaticFunc>>
    public native func IsNative() -> Bool
    public native func IsAbstract() -> Bool
    public native func IsA(base: CName) -> Bool
    public native func MakeHandle() -> ref<ISerializable>
}

public native class ReflectionEnum extends ReflectionType {
    public native func GetConstants() -> array<ref<ReflectionConst>>
    public native func IsNative() -> Bool
    public native func AddConstant(name: CName, value: Int64)
}
public native class ReflectionConst {
    public native func GetName() -> CName
    public native func GetValue() -> Int64
}

public native class ReflectionFunc {
    public native func GetName() -> CName
    public native func GetFullName() -> CName
    public native func GetParameters() -> array<ref<ReflectionProp>>
    public native func GetReturnType() -> ref<ReflectionType>
    public native func IsNative() -> Bool
    public native func IsStatic() -> Bool
}
public native class ReflectionMemberFunc extends ReflectionFunc {
    public native func Call(self: ref<IScriptable>, opt args: array<Variant>, opt status: script_ref<Bool>) -> Variant
}
public native class ReflectionStaticFunc extends ReflectionFunc {
    public native func Call(opt args: array<Variant>, opt status: script_ref<Bool>) -> Variant
}

public native class ReflectionProp {
    public native func GetName() -> CName
    public native func GetType() -> ref<ReflectionType>
    public native func IsNative() -> Bool
    public native func GetValue(owner: Variant) -> Variant
    public native func SetValue(owner: Variant, value: Variant)
}

public native class ReflectionType {
    public native func GetName() -> CName
    public native func GetMetaType() -> ERTTIType
    public native func GetInnerType() -> ref<ReflectionType>
    public native func MakeInstance() -> Variant
    public func IsArray() -> Bool {
        return Equals(this.GetMetaType(), ERTTIType.Array);
    }
    public func IsClass() -> Bool {
        return Equals(this.GetMetaType(), ERTTIType.Class);
    }
    public func IsEnum() -> Bool {
        return Equals(this.GetMetaType(), ERTTIType.Enum);
    }
    public func AsClass() -> ref<ReflectionClass> {
        return Reflection.GetClass(this.GetName());
    }
    public func AsEnum() -> ref<ReflectionEnum> {
        return Reflection.GetEnum(this.GetName());
    }
}

public class ControllerDelayCallback extends DelayCallback {
    public let controller: wref<IScriptable>;
    public let event: ref<Event>;
    public func Call() {
        if IsDefined(this.controller) {
            if this.controller.IsA(n"gameuiWidgetGameController") {
                (this.controller as inkGameController).QueueEvent(this.event);
                return;
            }
            if this.controller.IsA(n"inkWidgetLogicController") {
                (this.controller as inkLogicController).QueueEvent(this.event);
                return;
            }
        }
    }
}
@addMethod(DelaySystem)
public func DelayEvent(controller: wref<inkGameController>, eventToDelay: ref<Event>, timeToDelay: Float, opt isAffectedByTimeDilation: Bool) -> DelayID {
    let callback = new ControllerDelayCallback();
    callback.controller = controller;
    callback.event = eventToDelay;
    return this.DelayCallback(callback, timeToDelay, isAffectedByTimeDilation);
}
@addMethod(DelaySystem)
public func DelayEventNextFrame(controller: wref<inkGameController>, eventToDelay: ref<Event>) {
    let callback = new ControllerDelayCallback();
    callback.controller = controller;
    callback.event = eventToDelay;
    this.DelayCallbackNextFrame(callback);
}
@addMethod(DelaySystem)
public func DelayEvent(controller: wref<inkLogicController>, eventToDelay: ref<Event>, timeToDelay: Float, opt isAffectedByTimeDilation: Bool) -> DelayID {
    let callback = new ControllerDelayCallback();
    callback.controller = controller;
    callback.event = eventToDelay;
    return this.DelayCallback(callback, timeToDelay, isAffectedByTimeDilation);
}
@addMethod(DelaySystem)
public func DelayEventNextFrame(controller: wref<inkLogicController>, eventToDelay: ref<Event>) {
    let callback = new ControllerDelayCallback();
    callback.controller = controller;
    callback.event = eventToDelay;
    this.DelayCallbackNextFrame(callback);
}

public abstract native class ScriptableService {
}
public abstract class ScriptableEnv extends ScriptableService {
    public static final func Get(name: CName) -> ref<ScriptableService>
        = GameInstance.GetScriptableServiceContainer().GetService(name)
}

public abstract native class ScriptableServiceContainer extends IGameSystem {
    public native func GetService(name: CName) -> ref<ScriptableService>
}
@addMethod(GameInstance)
public static native func GetScriptableServiceContainer() -> ref<ScriptableServiceContainer>

public native struct StackTraceEntry {
    public native let class: CName;
    public native let function: CName;
    public native let object: wref<IScriptable>;
}
public static native func GetStackTrace(opt depth: Int32, opt current: Bool) -> array<StackTraceEntry>

public native class inkSystem extends IGameSystem {
    private let m_clipboard: String;
    public native func GetLayers() -> array<ref<inkLayerWrapper>>
    public native func GetLayer(layer: CName) -> ref<inkLayerWrapper>
    public native func GetWorldWidgets() -> array<wref<inkIGameController>>
    public native func GetClipboardText() -> String
    public native func SetClipboardText(data: String)
    public func SetFocus(widget: ref<inkWidget>) {
        GameInstance.GetInkSystem().GetLayer(n"inkGameNotificationsLayer").GetGameController().RequestSetFocus(widget);
    }
    public func ResetFocus() {
        this.SetFocus(null);
    }
}
@addMethod(GameInstance)
public static native func GetInkSystem() -> ref<inkSystem>

@addMethod(GameInstance)
public static func GetSystemRequestsHandler() -> wref<inkISystemRequestsHandler> {
    return new inkMenuScenario().GetSystemRequestsHandler();
}

@addMethod(inkCharacterEvent)
public native func GetType() -> inkCharacterEventType
@addMethod(inkCharacterEvent)
public native func GetAction() -> EInputAction

@addMethod(inkCircle)
public func GetSegmentsNumber() -> Uint32 {
    return this.segmentsNumber;
}
@addMethod(inkCircle)
public func SetSegmentsNumber(segmentsNumber: Uint32) {
    this.segmentsNumber = segmentsNumber;
}

public abstract native class inkComponent extends inkLogicController {
    public native func IsAttached() -> Bool
    public func Reparent(newParent: wref<inkCompoundWidget>) {
        this.Reparent(newParent, -1);
    }
    public func Reparent(newParent: wref<inkCompoundWidget>, index: Int32) {
        this.GetRootWidget().Reparent(newParent, index);
    }
}

@addMethod(inkImage)
public func UsesNineSliceScale() -> Bool {
    return this.useNineSliceScale;
}
@addMethod(inkImage)
public func SetNineSliceScale(enable: Bool) {
    this.useNineSliceScale = enable;
}
@addMethod(inkImage)
public func GetNineSliceGrid() -> inkMargin {
    return this.nineSliceScale;
}
@addMethod(inkImage)
public func SetNineSliceGrid(grid: inkMargin) {
    this.nineSliceScale = grid;
}
@addMethod(inkImage)
public func GetTileHAlign() -> inkEHorizontalAlign {
    return this.tileHAlign;
}
@addMethod(inkImage)
public func SetTileHAlign(tileHAlign: inkEHorizontalAlign) {
    this.tileHAlign = tileHAlign;
}
@addMethod(inkImage)
public func GetTileVAlign() -> inkEVerticalAlign {
    return this.tileVAlign;
}
@addMethod(inkImage)
public func SetTileVAlign(tileVAlign: inkEVerticalAlign) {
    this.tileVAlign = tileVAlign;
}

public native class inkKeyInputEvent extends inkInputEvent {
    public native func GetKey() -> EInputKey
    public native func GetAction() -> EInputAction
    public native func GetCharacter() -> String
    public native func IsCharacter() -> Bool
}

public native class inkLayerWrapper {
    public native func GetLayerName() -> CName
    public native func GetVirtualWindow() -> wref<inkVirtualWindow>
    public native func GetGameController() -> wref<inkIGameController>
    public native func GetGameControllers() -> array<wref<inkIGameController>>
}

@addMethod(inkMask)
public func GetTextureAtlas() -> ResRef {
    return ResourceAsyncRef.GetPath(this.textureAtlas);
}
@addMethod(inkMask)
public func SetTextureAtlas(path: ResRef) {
    ResourceAsyncRef.SetPath(this.textureAtlas, path);
}
@addMethod(inkMask)
public func GetDynamicTexture() -> CName {
    return this.dynamicTextureMask;
}
@addMethod(inkMask)
public func SetDynamicTexture(value: CName) {
    this.dynamicTextureMask = value;
}
@addMethod(inkMask)
public func GetDataSource() -> inkMaskDataSource {
    return this.dataSource;
}
@addMethod(inkMask)
public func SetDataSource(value: inkMaskDataSource) {
    this.dataSource = value;
}
@addMethod(inkMask)
public func IsInverted() -> Bool {
    return this.invertMask;
}
@addMethod(inkMask)
public func SetInverted(value: Bool) {
    this.invertMask = value;
}
@addMethod(inkMask)
public func GetTransparency() -> Float {
    return this.maskTransparency;
}
@addMethod(inkMask)
public func SetTransparency(value: Float) {
    this.maskTransparency = value;
}

@addMethod(inkScrollArea)
public func GetConstrainContentPosition() -> Bool {
    return this.constrainContentPosition;
}
@addMethod(inkScrollArea)
public func SetConstrainContentPosition(enabled: Bool) {
    this.constrainContentPosition = enabled;
}
@addMethod(inkScrollArea)
public func GetFitToContentDirection() -> inkFitToContentDirection {
    return this.fitToContentDirection;
}
@addMethod(inkScrollArea)
public func SetFitToContentDirection(value: inkFitToContentDirection) {
    this.fitToContentDirection = value;
}

@addMethod(inkScrollController)
public func GetScrollPosition() -> Float {
    return this.position;
}
@addMethod(inkScrollController)
public func GetContentSize() -> Vector2 {
    return this.contentSize;
}
@addMethod(inkScrollController)
public func GetViewportSize() -> Vector2 {
    return this.viewportSize;
}
@addMethod(inkScrollController)
public func SetViewportSize(size: Vector2) {
    this.viewportSize = size;
}
@addMethod(inkScrollController)
public func SetViewportWidth(width: Float) {
    this.viewportSize = new Vector2(width, this.viewportSize.Y);
}
@addMethod(inkScrollController)
public func SetViewportHeight(height: Float) {
    this.viewportSize = new Vector2(this.viewportSize.X, height);
}
@addMethod(inkScrollController)
public func IsEnabled() -> Bool {
    return this.scrollDelta > 0.0;
}
@addMethod(inkScrollController)
public func SetEnabled(enabled: Bool) {
    if enabled {
        if Equals(this.direction, inkEScrollDirection.Horizontal) {
            this.scrollDelta = this.contentSize.X - this.viewportSize.X;
        } else {
            this.scrollDelta = this.contentSize.Y - this.viewportSize.Y;
        }
    } else {
        this.scrollDelta = 0.0;
    }
}

@addMethod(inkShape)
public func GetResource() -> ResRef {
    return ResourceRef.GetPath(this.shapeResource);
}
@addMethod(inkShape)
public func SetResource(path: ResRef) {
    ResourceRef.LoadPath(this.shapeResource, path);
}
@addMethod(inkShape)
public func GetShape() -> CName {
    return this.shapeName;
}
@addMethod(inkShape)
public func SetShape(shape: CName) {
    this.ChangeShape(shape);
}
@addMethod(inkShape)
public func GetVariant() -> inkEShapeVariant {
    return this.shapeVariant;
}
@addMethod(inkShape)
public func SetVariant(variant: inkEShapeVariant) {
    this.shapeVariant = variant;
}
@addMethod(inkShape)
public func UsesNineSliceScale() -> Bool {
    return this.useNineSlice;
}
@addMethod(inkShape)
public func SetNineSliceScale(enable: Bool) {
    this.useNineSlice = enable;
}
@addMethod(inkShape)
public func GetNineSliceGrid() -> inkMargin {
    return this.nineSliceScale;
}
@addMethod(inkShape)
public func SetNineSliceGrid(grid: inkMargin) {
    this.nineSliceScale = grid;
}
@addMethod(inkShape)
public func GetKeepInBounds() -> Bool {
    return this.keepInBounds;
}
@addMethod(inkShape)
public func GetContentHAlign() -> inkEHorizontalAlign {
    return this.contentHAlign;
}
@addMethod(inkShape)
public func GetContentVAlign() -> inkEVerticalAlign {
    return this.contentVAlign;
}
@addMethod(inkShape)
public func GetBorderColor() -> HDRColor {
    return this.borderColor;
}
@addMethod(inkShape)
public func GetBorderOpacity() -> Float {
    return this.borderOpacity;
}
@addMethod(inkShape)
public func GetFillOpacity() -> Float {
    return this.fillOpacity;
}
@addMethod(inkShape)
public func GetLineThickness() -> Float {
    return this.lineThickness;
}
@addMethod(inkShape)
public func GetEndCapStyle() -> inkEEndCapStyle {
    return this.endCapStyle;
}
@addMethod(inkShape)
public func GetJointStyle() -> inkEJointStyle {
    return this.jointStyle;
}
@addMethod(inkShape)
public func GetVertexList() -> array<Vector2> {
    return this.vertexList;
}
@addMethod(inkShape)
public func SetKeepInBounds(keepInBounds: Bool) {
    this.keepInBounds = keepInBounds;
}
@addMethod(inkShape)
public func SetContentHAlign(contentHAlign: inkEHorizontalAlign) {
    this.contentHAlign = contentHAlign;
}
@addMethod(inkShape)
public func SetContentVAlign(contentVAlign: inkEVerticalAlign) {
    this.contentVAlign = contentVAlign;
}
@addMethod(inkShape)
public func SetBorderColor(borderColor: HDRColor) {
    this.borderColor = borderColor;
}
@addMethod(inkShape)
public func SetBorderOpacity(borderOpacity: Float) {
    this.borderOpacity = borderOpacity;
}
@addMethod(inkShape)
public func SetFillOpacity(fillOpacity: Float) {
    this.fillOpacity = fillOpacity;
}
@addMethod(inkShape)
public func SetLineThickness(lineThickness: Float) {
    this.lineThickness = lineThickness;
}
@addMethod(inkShape)
public func SetEndCapStyle(endCapStyle: inkEEndCapStyle) {
    this.endCapStyle = endCapStyle;
}
@addMethod(inkShape)
public func SetJointStyle(jointStyle: inkEJointStyle) {
    this.jointStyle = jointStyle;
}
@addMethod(inkShape)
public func SetVertexList(vertexList: array<Vector2>) {
    this.vertexList = vertexList;
}

@addMethod(inkText)
public func GetContentHAlign() -> inkEHorizontalAlign {
    return this.contentHAlign;
}
@addMethod(inkText)
public func SetContentHAlign(contentHAlign: inkEHorizontalAlign) {
    this.contentHAlign = contentHAlign;
}
@addMethod(inkText)
public func GetContentVAlign() -> inkEVerticalAlign {
    return this.contentVAlign;
}
@addMethod(inkText)
public func SetContentVAlign(contentVAlign: inkEVerticalAlign) {
    this.contentVAlign = contentVAlign;
}
@addMethod(inkText)
public func GetJustificationType() -> textJustificationType {
    return this.justification;
}
@addMethod(inkText)
public func SetJustificationType(justificationType: textJustificationType) {
    this.justification = justificationType;
}
@addMethod(inkText)
public func GetOverflowPolicy() -> textOverflowPolicy {
    return this.textOverflowPolicy;
}
@addMethod(inkText)
public func SetOverflowPolicy(overflowPolicy: textOverflowPolicy) {
    this.textOverflowPolicy = overflowPolicy;
}
@addMethod(inkText)
public func SetWrapping(enabled: Bool, opt width: Float, opt policy: textWrappingPolicy) {
    this.wrappingInfo.autoWrappingEnabled = enabled;
    this.wrappingInfo.wrappingAtPosition = width;
    this.wrappingInfo.wrappingPolicy = policy;
}
@addMethod(inkText)
public func GetWrapping() -> textWrappingInfo {
    return this.wrappingInfo;
}
@addMethod(inkText)
public func GetLineHeight() -> Float {
    return this.lineHeightPercentage;
}
@addMethod(inkText)
public func SetLineHeight(lineHeight: Float) {
    this.lineHeightPercentage = lineHeight;
}
@addMethod(inkText)
public func GetLockFontInGame() -> Bool {
    return this.lockFontInGame;
}
@addMethod(inkText)
public func SetLockFontInGame(lockFont: Bool) {
    this.lockFontInGame = lockFont;
}

@addMethod(inkWidget)
public func GetParentWidget() -> wref<inkWidget> {
    return this.parentWidget;
}
@addMethod(inkWidget)
public func SetUserData(userData: ref<inkUserData>) {
    ArrayPush(this.userData, userData);
}
@addMethod(inkWidget)
public func CanSupportFocus() -> Bool {
    return this.canSupportFocus;
}
@addMethod(inkWidget)
public func SetSupportFocus(enabled: Bool) {
    this.canSupportFocus = enabled;
}
@addMethod(inkWidget)
public func AddEffect(effect: ref<inkIEffect>) {
    ArrayPush(this.effects, effect);
}
@addMethod(inkWidget)
public native func AttachController(controller: ref<inkLogicController>, opt secondary: Bool);

@addMethod(inkWidgetLibraryReference)
public static func Create(path: ResRef, item: CName) -> inkWidgetLibraryReference {
    return new inkWidgetLibraryReference(inkWidgetLibraryResource.Create(path), item);
}

@addMethod(inkWidgetLibraryResource)
public static native func SetPath(self: script_ref<inkWidgetLibraryResource>, path: ResRef);
@addMethod(inkWidgetLibraryResource)
public static func Create(path: ResRef) -> inkWidgetLibraryResource {
    let ref = new inkWidgetLibraryResource();
    inkWidgetLibraryResource.SetPath(ref, path);
    return ref;
}

@addMethod(inkWidgetRef)
public static native func Set(self: script_ref<inkWidgetRef>, widget: ref<inkWidget>);
@addMethod(inkWidgetRef)
public static func Create(widget: ref<inkWidget>) -> inkWidgetRef {
    let ref = new inkWidgetRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkBorderRef)
public static func Create(widget: ref<inkBorder>) -> inkBorderRef {
    let ref = new inkBorderRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkCacheRef)
public static func Create(widget: ref<inkCacheWidget>) -> inkCacheRef {
    let ref = new inkCacheRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkCanvasRef)
public static func Create(widget: ref<inkCanvas>) -> inkCanvasRef {
    let ref = new inkCanvasRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkCircleRef)
public static func Create(widget: ref<inkCircle>) -> inkCircleRef {
    let ref = new inkCircleRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkFlexRef)
public static func Create(widget: ref<inkFlex>) -> inkFlexRef {
    let ref = new inkFlexRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkGridRef)
public static func Create(widget: ref<inkGrid>) -> inkGridRef {
    let ref = new inkGridRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkHorizontalPanelRef)
public static func Create(widget: ref<inkHorizontalPanel>) -> inkHorizontalPanelRef {
    let ref = new inkHorizontalPanelRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkImageRef)
public static func Create(widget: ref<inkImage>) -> inkImageRef {
    let ref = new inkImageRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkMaskRef)
public static func Create(widget: ref<inkMask>) -> inkMaskRef {
    let ref = new inkMaskRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkRectangleRef)
public static func Create(widget: ref<inkRectangle>) -> inkRectangleRef {
    let ref = new inkRectangleRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkScrollAreaRef)
public static func Create(widget: ref<inkScrollArea>) -> inkScrollAreaRef {
    let ref = new inkScrollAreaRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkShapeRef)
public static func Create(widget: ref<inkShape>) -> inkShapeRef {
    let ref = new inkShapeRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkTextRef)
public static func Create(widget: ref<inkText>) -> inkTextRef {
    let ref = new inkTextRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkUniformGridRef)
public static func Create(widget: ref<inkUniformGrid>) -> inkUniformGridRef {
    let ref = new inkUniformGridRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkVerticalPanelRef)
public static func Create(widget: ref<inkVerticalPanel>) -> inkVerticalPanelRef {
    let ref = new inkVerticalPanelRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkVideoRef)
public static func Create(widget: ref<inkVideo>) -> inkVideoRef {
    let ref = new inkVideoRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}
@addMethod(inkVirtualCompoundRef)
public static func Create(widget: ref<inkVirtualCompoundWidget>) -> inkVirtualCompoundRef {
    let ref = new inkVirtualCompoundRef();
    inkWidgetRef.Set(ref, widget);
    return ref;
}

@addMethod(worlduiIGameController)
public func GetWorldWidgetComponent() -> ref<IComponent> {
    let widget = this.GetRootWidget();
    while IsDefined(widget) {
        let userData = widget.GetUserData(n"inkWorldWidgetInfos") as inkWorldWidgetInfos;
        if IsDefined(userData) {
            return userData.GetComponent();
        }
        widget = widget.parentWidget;
    }
    return null;
}

public static native func BitTest8(value: Uint8, n: Int32) -> Bool
public static native func BitSet8(value: Uint8, n: Int32, state: Bool) -> Uint8
public static native func BitShiftL8(value: Uint8, n: Int32) -> Uint8
public static native func BitShiftR8(value: Uint8, n: Int32) -> Uint8
public static native func BitTest16(value: Uint16, n: Int32) -> Bool
public static native func BitSet16(value: Uint16, n: Int32, state: Bool) -> Uint16
public static native func BitShiftL16(value: Uint16, n: Int32) -> Uint16
public static native func BitShiftR16(value: Uint16, n: Int32) -> Uint16
public static native func BitTest32(value: Uint32, n: Int32) -> Bool
public static native func BitSet32(value: Uint32, n: Int32, state: Bool) -> Uint32
public static native func BitShiftL32(value: Uint32, n: Int32) -> Uint32
public static native func BitShiftR32(value: Uint32, n: Int32) -> Uint32
public static native func BitTest64(value: Uint64, n: Int32) -> Bool
public static native func BitSet64(value: Uint64, n: Int32, state: Bool) -> Uint64
public static native func BitShiftL64(value: Uint64, n: Int32) -> Uint64
public static native func BitShiftR64(value: Uint64, n: Int32) -> Uint64

public static func Cast(value: CName) -> Uint64 = NameToHash(value)
public static func Cast(value: Uint64) -> CName = HashToName(value)
public static func Cast(value: CRUID) -> Uint64 = CRUIDToHash(value)
public static func Cast(value: Uint64) -> CRUID = HashToCRUID(value)
public static func Cast(value: EntityID) -> Uint64 = EntityID.ToHash(value)
public static func Cast(value: Uint64) -> EntityID = EntityID.FromHash(value)
public static func Cast(value: NodeRef) -> Uint64 = NodeRefToHash(value)
public static func Cast(value: Uint64) -> NodeRef = HashToNodeRef(value)
public static func Cast(value: NodeRef) -> EntityID = EntityID.FromHash(NodeRefToHash(value))
public static func Cast(value: EntityID) -> NodeRef = HashToNodeRef(EntityID.ToHash(value))
public static func Cast(value: String) -> NodeRef = CreateNodeRef(value)
public static func Cast(value: LocalizationString) -> String = ExtractLocalizationString(value)
public static func Cast(value: String) -> LocalizationString = CreateLocalizationString(value)

public static native func HashToName(value: Uint64) -> CName
public static native func NameToHash(value: CName) -> Uint64
public static func ToName(value: String) -> CName = StringToName(value)
public static func ToName(value: Uint64) -> CName = HashToName(value)

public static native func GameFileExists(path: script_ref<String>) -> Bool

public static native func HashToCRUID(value: Uint64) -> CRUID
public static native func CRUIDToHash(value: CRUID) -> Uint64
public static func CreateCRUID(value: Uint64) -> CRUID = HashToCRUID(value)
public static func ToCRUID(value: Uint64) -> CRUID = HashToCRUID(value)

public static func ToEntityID(value: Uint64) -> EntityID = EntityID.FromHash(value)
public static func ToEntityID(value: NodeRef) -> EntityID = EntityID.FromHash(NodeRefToHash(value))

public static native func FNV1a64(data: script_ref<String>, opt seed: Uint64) -> Uint64
public static native func FNV1a32(data: script_ref<String>, opt seed: Uint32) -> Uint32
public static native func Murmur3(data: script_ref<String>, opt seed: Uint32) -> Uint32

public static native func CreateLocalizationString(value: String) -> LocalizationString
public static native func ExtractLocalizationString(value: LocalizationString) -> String
public static func ToLocalizationString(value: String) -> LocalizationString = CreateLocalizationString(value)
public static func ToString(value: LocalizationString) -> String = ExtractLocalizationString(value)

public static native func Print(text: script_ref<String>)
public static native func ModLog(mod: CName, text: script_ref<String>)

public static native func CreateNodeRef(value: script_ref<String>) -> NodeRef
public static native func HashToNodeRef(value: Uint64) -> NodeRef
public static native func NodeRefToHash(value: NodeRef) -> Uint64
public static func ToNodeRef(value: String) -> NodeRef = CreateNodeRef(value)
public static func ToNodeRef(value: Uint64) -> NodeRef = HashToNodeRef(value)
public static func ToNodeRef(value: EntityID) -> NodeRef = HashToNodeRef(EntityID.ToHash(value))

public static native func ParseInt8(str: String, opt base: Int32) -> Int8
public static native func ParseInt16(str: String, opt base: Int32) -> Int16
public static native func ParseInt32(str: String, opt base: Int32) -> Int32
public static native func ParseInt64(str: String, opt base: Int32) -> Int64
public static native func ParseUint8(str: String, opt base: Int32) -> Uint8
public static native func ParseUint16(str: String, opt base: Int32) -> Uint16
public static native func ParseUint32(str: String, opt base: Int32) -> Uint32
public static native func ParseUint64(str: String, opt base: Int32) -> Uint64

public static native func UTF8StrLen(str: script_ref<String>) -> Int32
public static native func UTF8StrLeft(str: script_ref<String>, length: Int32) -> String
public static native func UTF8StrRight(str: script_ref<String>, length: Int32) -> String
public static native func UTF8StrMid(str: script_ref<String>, offset: Int32, length: Int32) -> String
public static native func UTF8StrLower(str: script_ref<String>) -> String
public static native func UTF8StrUpper(str: script_ref<String>) -> String

enum DynamicEntityEventType
{
    Created = 0,
    Deleted = 1,
    Spawned = 2,
    Despawned = 3,
    Dead = 4,
}
public native class DynamicEntityEvent {
    public native func GetEventType() -> DynamicEntityEventType
    public native func GetEntityID() -> EntityID
    public native func GetEntityTag() -> CName
}

public native class DynamicEntitySpec {
    public native let recordID: TweakDBID;
    public native let templatePath: ResRef;
    public native let appearanceName: CName;
    public native let position: Vector4;
    public native let orientation: Quaternion;
    public native let persistState: Bool;
    public native let persistSpawn: Bool;
    public native let alwaysSpawned: Bool;
    public native let spawnInView: Bool;
    public native let active: Bool;
    public native let tags: array<CName>;
}

public native class DynamicEntitySystem extends IGameSystem {
    public native func IsReady() -> Bool
    public native func IsRestored() -> Bool
    public native func CreateEntity(spec: ref<DynamicEntitySpec>) -> EntityID
    public native func DeleteEntity(id: EntityID) -> Bool
    public native func EnableEntity(id: EntityID) -> Bool
    public native func DisableEntity(id: EntityID) -> Bool
    public native func IsManaged(id: EntityID) -> Bool
    public native func IsTagged(id: EntityID, tag: CName) -> Bool
    public native func IsSpawned(id: EntityID) -> Bool
    public native func IsSpawning(id: EntityID) -> Bool
    public native func GetEntity(id: EntityID) -> ref<Entity>
    public native func GetTags(id: EntityID) -> array<CName>
    public native func AssignTag(id: EntityID, tag: CName)
    public native func UnassignTag(id: EntityID, tag: CName)
    public native func IsPopulated(tag: CName) -> Bool
    public native func GetTagged(tag: CName) -> array<ref<Entity>>
    public native func GetTaggedID(tag: CName) -> EntityID
    public native func GetTaggedIDs(tag: CName) -> array<EntityID>
    public native func DeleteTagged(tag: CName)
    public native func EnableTagged(tag: CName)
    public native func DisableTagged(tag: CName)
    public native func RegisterListener(tag: CName, target: ref<IScriptable>, function: CName)
    public native func UnregisterListener(tag: CName, target: ref<IScriptable>, function: CName)
    public native func UnregisterListeners(tag: CName)
}
@addMethod(GameInstance)
public static native func GetDynamicEntitySystem() -> ref<DynamicEntitySystem>

@addMethod(MappinSystem)
public native func GetAllMappins() -> array<ref<IMappin>>

public native struct OpenWorldActivityRequest {
    public native let kind: CName;
    public native let districts: array<gamedataDistrict>;
    public native let cooldown: Float; // seconds
    public native let force: Bool;
}

enum OpenWorldActivityResult {
    OK = 0,
    Invalid = 1,
    NotFound = 2,
    Undiscovered = 3,
    Unfinished = 4,
    StillSpawned = 5
}

public native struct OpenWorldActivityState {
    public native let name: CName;
    public native let kind: CName;
    public native let timestamp: Uint32;
    public native let completed: Bool;
    public native let discovered: Bool;
}

public native class OpenWorldSystem extends IGameSystem {
    public native func IsReady() -> Bool
    public native func GetActivity(name: CName) -> OpenWorldActivityState
    public native func GetActivities() -> array<OpenWorldActivityState>
    public native func StartActivity(name: CName, opt force: Bool) -> OpenWorldActivityResult
    public native func StartActivities(opt request: OpenWorldActivityRequest) -> Int32
}
@addMethod(GameInstance)
public static native func GetOpenWorldSystem() -> ref<OpenWorldSystem>

public native class StaticEntitySpec {
    public native let templatePath: ResRef;
    public native let appearanceName: CName;
    public native let position: Vector4;
    public native let orientation: Quaternion;
    public native let attached: Bool;
    public native let tags: array<CName>;
}

public native class StaticEntitySystem extends IGameSystem {
    public native func IsReady() -> Bool
    public native func SpawnEntity(spec: ref<StaticEntitySpec>) -> EntityID
    public native func DespawnEntity(id: EntityID) -> Bool
    public native func AttachEntity(id: EntityID) -> Bool
    public native func DetachEntity(id: EntityID) -> Bool
    public native func IsManaged(id: EntityID) -> Bool
    public native func IsTagged(id: EntityID, tag: CName) -> Bool
    public native func IsSpawned(id: EntityID) -> Bool
    public native func IsSpawning(id: EntityID) -> Bool
    public native func GetEntity(id: EntityID) -> ref<Entity>
    public native func GetTags(id: EntityID) -> array<CName>
    public native func AssignTag(id: EntityID, tag: CName)
    public native func UnassignTag(id: EntityID, tag: CName)
    public native func IsPopulated(tag: CName) -> Bool
    public native func GetTagged(tag: CName) -> array<ref<Entity>>
    public native func GetTaggedID(tag: CName) -> EntityID
    public native func GetTaggedIDs(tag: CName) -> array<EntityID>
    public native func DespawnTagged(tag: CName)
    public native func AttachTagged(tag: CName)
    public native func DetachTagged(tag: CName)
}
@addMethod(GameInstance)
public static native func GetStaticEntitySystem() -> ref<StaticEntitySystem>

@addMethod(WeatherSystem)
public native func SetWeather(weather: CName, opt blendTime: Float, opt priority: Uint32) -> Bool
@addMethod(WeatherSystem)
public native func ResetWeather(opt forceRestore: Bool, opt blendTime: Float) -> Bool
@addMethod(WeatherSystem)
public native func GetWeatherState() -> ref<worldWeatherState>
@addMethod(WeatherSystem)
public native func GetEnvironmentDefinition() -> ref<worldEnvironmentDefinition>

@addMethod(WorkspotGameSystem)
public native func GetWorkspotInstance(actorID: EntityID) -> ref<workWorkspotInstance>

public native class WorldNodeSetupWrapper {
    public native func GetNode() -> ref<worldNode>
    public native func GetTransform() -> Transform
    public native func GetPosition() -> Vector4
    public native func GetOrientation() -> Quaternion
    public native func GetScale() -> Vector3
    public native func GetNodeRef() -> NodeRef
    public native func GetGlobalNodeID() -> GlobalNodeID
    public native func GetProxyNodeID() -> GlobalNodeID
    public native func GetStreamingPosition() -> Vector3
    public native func GetStreamingDistance() -> Float
    public native func GetSecondaryRefPointPosition() -> Vector3
    public native func GetSecondaryRefPointDistance() -> Float
    public native func SetTransform(value: Transform)
    public native func SetPosition(value: Vector4)
    public native func SetOrientation(value: Quaternion)
    public native func SetScale(value: Vector3)
    public native func SetNodeRef(value: NodeRef)
    public native func SetGlobalNodeID(value: GlobalNodeID)
    public native func SetProxyNodeID(value: GlobalNodeID)
    public native func SetStreamingPosition(value: Vector3)
    public native func SetStreamingDistance(value: Float)
    public native func SetSecondaryRefPointPosition(value: Vector3)
    public native func SetSecondaryRefPointDistance(value: Float)
}

public native class WorldStateSystem extends IGameSystem {
    public native func IsReady() -> Bool
    public native func ActivateCommunity(community: NodeRef, opt entry: CName)
    public native func DeactivateCommunity(community: NodeRef, opt entry: CName)
    public native func TogglePrefab(prefab: NodeRef, state: Bool)
    public native func TogglePrefabVariant(prefab: NodeRef, variant: CName, state: Bool)
}
@addMethod(GameInstance)
public static native func GetWorldStateSystem() -> ref<WorldStateSystem>
